--------------------------------------------------------------------------------
// File: MainWindow.xaml
--------------------------------------------------------------------------------
ï»¿<Window x:Class="MinimalFirewall.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
        xmlns:shell="clr-namespace:System.Windows.Shell;assembly=PresentationFramework"
        xmlns:local="clr-namespace:MinimalFirewall"
        mc:Ignorable="d"
        Title="Minimal Firewall" Height="700" Width="1000"
        WindowStyle="None" AllowsTransparency="True" Background="Transparent" WindowState="Normal">

    <Window.Resources>
        <Style x:Key="CaptionButtonStyle" TargetType="Button">
            <Setter Property="Width" Value="46"/>
            <Setter Property="Height" Value="32"/>
            <Setter Property="Background" Value="Transparent"/>
            <Setter Property="Foreground" Value="{DynamicResource App.Text.Default}"/>
            <Setter Property="BorderThickness" Value="0"/>
            <Setter Property="VerticalAlignment" Value="Top"/>
            <Setter Property="Template">
                <Setter.Value>
                    <ControlTemplate TargetType="{x:Type Button}">
                        <Border Background="{TemplateBinding Background}" Name="border">
                            <ContentPresenter HorizontalAlignment="Center" VerticalAlignment="Center"/>
                        </Border>
                    </ControlTemplate>
                </Setter.Value>
            </Setter>
            <Style.Triggers>
                <Trigger Property="IsMouseOver" Value="True">
                    <Setter Property="Background" Value="{DynamicResource CaptionButton.Background.MouseOver}" />
                </Trigger>
            </Style.Triggers>
        </Style>
        <Style x:Key="CloseButtonStyle" BasedOn="{StaticResource CaptionButtonStyle}" TargetType="Button">
            <Style.Triggers>
                <Trigger Property="IsMouseOver" Value="True">
                    <Setter Property="Background" Value="#E81123" />
                    <Setter Property="Foreground" Value="White" />
                </Trigger>
            </Style.Triggers>
        </Style>

        <Style x:Key="SortableHeaderStyle" TargetType="{x:Type GridViewColumnHeader}" BasedOn="{StaticResource {x:Type GridViewColumnHeader}}">
            <EventSetter Event="Click" Handler="SortableColumnHeader_Click" />
        </Style>

        <Style x:Key="StatusRowStyle" TargetType="{x:Type ListViewItem}">
            <Setter Property="HorizontalContentAlignment" Value="Stretch" />
            <Setter Property="Background" Value="{DynamicResource App.Window.Background}" />
            <Style.Triggers>
                <DataTrigger Binding="{Binding Status}" Value="Allow (All)">
                    <Setter Property="Background" Value="#C8E6C9" />
                    <Setter Property="Foreground" Value="Black" />
                </DataTrigger>
                <DataTrigger Binding="{Binding Status}" Value="Allow Out, Allow In">
                    <Setter Property="Background" Value="#FFF9C4" />
                    <Setter Property="Foreground" Value="Black" />
                </DataTrigger>
                <DataTrigger Binding="{Binding Status}" Value="Allow Out">
                    <Setter Property="Background" Value="#FFF9C4" />
                    <Setter Property="Foreground" Value="Black" />
                </DataTrigger>
                <DataTrigger Binding="{Binding Status}" Value="Allow In">
                    <Setter Property="Background" Value="#FFF9C4" />
                    <Setter Property="Foreground" Value="Black" />
                </DataTrigger>
                <DataTrigger Binding="{Binding Status}" Value="Block (All)">
                    <Setter Property="Background" Value="#EF9A9A" />
                    <Setter Property="Foreground" Value="Black" />
                </DataTrigger>
                <DataTrigger Binding="{Binding Status}" Value="Block Out, Block In">
                    <Setter Property="Background" Value="#FFCC80" />
                    <Setter Property="Foreground" Value="Black" />
                </DataTrigger>
                <DataTrigger Binding="{Binding Status}" Value="Block Out">
                    <Setter Property="Background" Value="#FFCC80" />
                    <Setter Property="Foreground" Value="Black" />
                </DataTrigger>
                <DataTrigger Binding="{Binding Status}" Value="Block In">
                    <Setter Property="Background" Value="#FFCC80" />
                    <Setter Property="Foreground" Value="Black" />
                </DataTrigger>
                <DataTrigger Binding="{Binding Status}" Value="Block Out, Allow In">
                    <Setter Property="Background" Value="#E1BEE7" />
                    <Setter Property="Foreground" Value="Black" />
                </DataTrigger>
                <DataTrigger Binding="{Binding Status}" Value="Allow Out, Block In">
                    <Setter Property="Background" Value="#E1BEE7" />
                    <Setter Property="Foreground" Value="Black" />
                </DataTrigger>
                <DataTrigger Binding="{Binding Status}" Value="Undefined">
                    <Setter Property="Background" Value="{DynamicResource ListItem.Background.Undefined}" />
                    <Setter Property="Foreground" Value="{DynamicResource ListItem.Text.Undefined}" />
                </DataTrigger>
                <Trigger Property="IsMouseOver" Value="True">
                    <Setter Property="Background" Value="{DynamicResource ListItem.Background.MouseOver}" />
                    <Setter Property="Foreground" Value="{DynamicResource ListItem.Text.Selected}" />
                </Trigger>
                <Trigger Property="IsSelected" Value="True">
                    <Setter Property="Background" Value="{DynamicResource ListItem.Background.Selected}" />
                    <Setter Property="Foreground" Value="{DynamicResource ListItem.Text.Selected}" />
                </Trigger>
            </Style.Triggers>
        </Style>

        <Style x:Key="UndefinedRowStyle" TargetType="{x:Type ListViewItem}">
            <Setter Property="HorizontalContentAlignment" Value="Stretch" />
            <Setter Property="Background" Value="{DynamicResource ListItem.Background.Undefined}" />
            <Setter Property="Foreground" Value="{DynamicResource ListItem.Text.Undefined}" />
            <Style.Triggers>
                <Trigger Property="IsMouseOver" Value="True">
                    <Setter Property="Background" Value="{DynamicResource ListItem.Background.MouseOver}" />
                    <Setter Property="Foreground" Value="{DynamicResource ListItem.Text.Selected}" />
                </Trigger>
                <Trigger Property="IsSelected" Value="True">
                    <Setter Property="Background" Value="{DynamicResource ListItem.Background.Selected}" />
                    <Setter Property="Foreground" Value="{DynamicResource ListItem.Text.Selected}" />
                </Trigger>
            </Style.Triggers>
        </Style>
    </Window.Resources>

    <shell:WindowChrome.WindowChrome>
        <shell:WindowChrome ResizeBorderThickness="8" CaptionHeight="40" CornerRadius="0" GlassFrameThickness="0" UseAeroCaptionButtons="False"/>
    </shell:WindowChrome.WindowChrome>

    <Border BorderBrush="{DynamicResource App.Border.Default}" BorderThickness="1" Background="{DynamicResource App.Window.Background}">
        <DockPanel x:Name="RootPanel">
            <Border DockPanel.Dock="Top" Background="{DynamicResource TitleBar.Background.Default}" BorderBrush="{DynamicResource App.Border.Default}" BorderThickness="0,0,0,1">
                <Grid Height="40" MouseLeftButtonDown="TitleBar_MouseLeftButtonDown">
                    <Grid.ColumnDefinitions>
                        <ColumnDefinition Width="*"/>
                        <ColumnDefinition Width="Auto"/>
                    </Grid.ColumnDefinitions>

                    <StackPanel Grid.Column="0" Orientation="Horizontal">
                        <Button x:Name="FileMenuButton" Content="â˜°" Width="40" Height="30" Margin="5" Click="FileMenuButton_Click" ToolTip="Menu" shell:WindowChrome.IsHitTestVisibleInChrome="True">
                            <Button.ContextMenu>
                                <ContextMenu DataContext="{Binding PlacementTarget.DataContext, RelativeSource={RelativeSource Self}}">
                                    <MenuItem Header="Close to Tray" IsCheckable="True" IsChecked="{Binding IsCloseToTrayEnabled, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}"/>
                                    <MenuItem Header="Start on System Startup" IsCheckable="True" IsChecked="{Binding IsStartupEnabled, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}"/>
                                    <MenuItem Header="Use Dark Mode" IsCheckable="True" IsChecked="{Binding IsDarkModeEnabled, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}"/>
                                    <Separator/>
                                    <MenuItem Header="Show System Rules" IsCheckable="True" IsChecked="{Binding ShowSystemRules, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}"/>
                                    <MenuItem Header="Enable Popups" IsCheckable="True" IsChecked="{Binding IsPopupsEnabled, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}"/>
                                    <MenuItem Header="Enable Event Logging" IsCheckable="True" IsChecked="{Binding IsLoggingEnabled, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}"/>
                                    <Separator/>
                                    <MenuItem Header="{Binding VersionInfo}" IsEnabled="False"/>
                                    <MenuItem Header="Check for updates..." Command="{Binding CheckForUpdatesCommand}"/>
                                </ContextMenu>
                            </Button.ContextMenu>
                        </Button>
                        <Button Command="{Binding ToggleLockdownCommand}" Width="40" Height="30" Margin="0,5,5,5" ToolTip="{Binding FirewallStatus}" shell:WindowChrome.IsHitTestVisibleInChrome="True">
                            <Button.Style>
                                <Style TargetType="Button" BasedOn="{StaticResource {x:Type Button}}">
                                    <Setter Property="Content">
                                        <Setter.Value>
                                            <Path Fill="{DynamicResource App.Text.Default}" Stretch="Uniform" Width="16" Height="16" Data="M12,17A2,2 0 0,0 14,15A2,2 0 0,0 12,13A2,2 0 0,0 10,15A2,2 0 0,0 12,17M17,8H7V4A2,2 0 0,1 9,2H11A2,2 0 0,1 13,4V5H15V4A4,4 0 0,0 11,0H9A4,4 0 0,0 5,4V8A2,2 0 0,0 3,10V20A2,2 0 0,0 5,22H19A2,2 0 0,0 21,20V10A2,2 0 0,0 19,8Z" />
                                        </Setter.Value>
                                    </Setter>
                                    <Style.Triggers>
                                        <DataTrigger Binding="{Binding IsLockedDown}" Value="True">
                                            <Setter Property="Background" Value="#C8E6C9"/>
                                            <Setter Property="Content">
                                                <Setter.Value>
                                                    <Path Fill="Black" Stretch="Uniform" Width="16" Height="16" Data="M12,17A2,2 0 0,0 14,15A2,2 0 0,0 12,13A2,2 0 0,0 10,15A2,2 0 0,0 12,17M6,8A2,2 0 0,0 4,10V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V10A2,2 0 0,0 18,8H6ZM9,8V5A3,3 0 0,1 15,5V8H17V5A5,5 0 0,0 7,5V8H9Z" />
                                                </Setter.Value>
                                            </Setter>
                                        </DataTrigger>
                                    </Style.Triggers>
                                </Style>
                            </Button.Style>
                        </Button>
                        <TextBlock Text="{Binding FirewallStatus}" VerticalAlignment="Center" Margin="5,0" FontWeight="SemiBold" Foreground="{DynamicResource App.Text.Default}"/>
                        <Grid Width="250" Margin="15,0,0,0" VerticalAlignment="Center" shell:WindowChrome.IsHitTestVisibleInChrome="True">
                            <TextBox x:Name="SearchTextBox" Text="{Binding SearchText, UpdateSourceTrigger=PropertyChanged}" Padding="22,0,0,0" ToolTip="Search all lists..."/>
                            <TextBlock Text="ðŸ”" IsHitTestVisible="False" Foreground="{DynamicResource Search.Placeholder.Foreground}" VerticalAlignment="Center" HorizontalAlignment="Left" Margin="5,0,0,0">
                                <TextBlock.Style>
                                    <Style TargetType="TextBlock">
                                        <Setter Property="Visibility" Value="Collapsed"/>
                                        <Style.Triggers>
                                            <DataTrigger Binding="{Binding Text, ElementName=SearchTextBox}" Value="">
                                                <Setter Property="Visibility" Value="Visible"/>
                                            </DataTrigger>
                                        </Style.Triggers>
                                    </Style>
                                </TextBlock.Style>
                            </TextBlock>
                        </Grid>
                        <ComboBox ItemsSource="{Binding SearchModes}" SelectedItem="{Binding CurrentSearchMode}" Margin="5,0,0,0" VerticalAlignment="Center" shell:WindowChrome.IsHitTestVisibleInChrome="True"/>
                        <Button x:Name="SupportButton" Content="â˜•" FontSize="16" VerticalAlignment="Center" Margin="10,0,0,0" ToolTip="Support my work for the price of a coffee!" Click="SupportButton_Click" shell:WindowChrome.IsHitTestVisibleInChrome="True">
                            <Button.Style>
                                <Style TargetType="Button">
                                    <Setter Property="Background" Value="Transparent"/>
                                    <Setter Property="BorderThickness" Value="0"/>
                                    <Setter Property="Foreground" Value="{DynamicResource App.Text.Default}"/>
                                    <Setter Property="Cursor" Value="Hand"/>
                                    <Style.Triggers>
                                        <Trigger Property="IsMouseOver" Value="True">
                                            <Setter Property="Opacity" Value="0.7"/>
                                        </Trigger>
                                    </Style.Triggers>
                                </Style>
                            </Button.Style>
                        </Button>
                        <Button Command="{Binding RefreshCommand}" Content="âŸ³" FontSize="18" ToolTip="Refresh All Rules" Margin="5,0,0,0" VerticalAlignment="Center" shell:WindowChrome.IsHitTestVisibleInChrome="True">
                            <Button.Style>
                                <Style TargetType="Button">
                                    <Setter Property="Background" Value="Transparent"/>
                                    <Setter Property="BorderThickness" Value="0"/>
                                    <Setter Property="Foreground" Value="{DynamicResource App.Text.Default}"/>
                                    <Setter Property="Cursor" Value="Hand"/>
                                    <Style.Triggers>
                                        <Trigger Property="IsMouseOver" Value="True">
                                            <Setter Property="Opacity" Value="0.7"/>
                                        </Trigger>
                                    </Style.Triggers>
                                </Style>
                            </Button.Style>
                        </Button>
                    </StackPanel>

                    <StackPanel Grid.Column="1" Orientation="Horizontal" HorizontalAlignment="Right">
                        <Button x:Name="MinimizeButton" Content="â€”" Style="{StaticResource CaptionButtonStyle}" Click="MinimizeButton_Click" shell:WindowChrome.IsHitTestVisibleInChrome="True"/>
                        <Button x:Name="MaximizeButton" Content="â˜" Style="{StaticResource CaptionButtonStyle}" Click="MaximizeButton_Click" shell:WindowChrome.IsHitTestVisibleInChrome="True"/>
                        <Button x:Name="CloseButton" Content="âœ•" Style="{StaticResource CloseButtonStyle}" Click="CloseButton_Click" shell:WindowChrome.IsHitTestVisibleInChrome="True"/>
                    </StackPanel>
                </Grid>
            </Border>

            <TabControl x:Name="MainTabControl" SelectionChanged="MainTabControl_SelectionChanged">
                <TabItem Header="Pending Connections">
                    <Grid>
                        <ListView x:Name="PendingConnectionsListView" ItemsSource="{Binding PendingConnections}" FontSize="14" SelectionMode="Single" ItemContainerStyle="{StaticResource UndefinedRowStyle}" Background="{DynamicResource App.Window.Background}" BorderThickness="0" ContextMenuOpening="ListView_ContextMenuOpening">
                            <ListView.View>
                                <GridView>
                                    <GridViewColumn Header="Actions" Width="320">
                                        <GridViewColumn.CellTemplate>
                                            <DataTemplate>
                                                <StackPanel Orientation="Horizontal">
                                                    <Button Content="Allow" Style="{StaticResource GreenPendingButton}" Command="{Binding DataContext.AllowPendingCommand, RelativeSource={RelativeSource AncestorType=ListView}}" CommandParameter="{Binding}" Margin="2" Padding="10,2"/>
                                                    <Button Content="Block" Style="{StaticResource RedPendingButton}" Command="{Binding DataContext.BlockPendingCommand, RelativeSource={RelativeSource AncestorType=ListView}}" CommandParameter="{Binding}" Margin="2" Padding="10,2"/>
                                                    <Button Content="Allow Temp..." Style="{StaticResource YellowPendingButton}" x:Name="AllowTempButton" Click="AllowTempButton_Click" Margin="2" Padding="10,2">
                                                        <Button.ContextMenu>
                                                            <ContextMenu>
                                                                <MenuItem Header="1 Minute" Tag="1" Click="AllowTempMenuItem_Click"/>
                                                                <MenuItem Header="5 Minutes" Tag="5" Click="AllowTempMenuItem_Click"/>
                                                                <MenuItem Header="10 Minutes" Tag="10" Click="AllowTempMenuItem_Click"/>
                                                                <MenuItem Header="30 Minutes" Tag="30" Click="AllowTempMenuItem_Click"/>
                                                                <MenuItem Header="1 Hour" Tag="60" Click="AllowTempMenuItem_Click"/>
                                                            </ContextMenu>
                                                        </Button.ContextMenu>
                                                    </Button>
                                                    <Button Content="Ignore" Command="{Binding DataContext.IgnorePendingCommand, RelativeSource={RelativeSource AncestorType=ListView}}" CommandParameter="{Binding}" Margin="2" Padding="10,2"/>
                                                </StackPanel>
                                            </DataTemplate>
                                        </GridViewColumn.CellTemplate>
                                    </GridViewColumn>
                                    <GridViewColumn Header="Application" Width="150" HeaderContainerStyle="{StaticResource SortableHeaderStyle}" DisplayMemberBinding="{Binding FileName}"/>
                                    <GridViewColumn Header="Service" Width="150" HeaderContainerStyle="{StaticResource SortableHeaderStyle}" DisplayMemberBinding="{Binding ServiceName}"/>
                                    <GridViewColumn Header="Direction" Width="100" HeaderContainerStyle="{StaticResource SortableHeaderStyle}" DisplayMemberBinding="{Binding Direction}"/>
                                    <GridViewColumn Header="Path" DisplayMemberBinding="{Binding AppPath}" Width="230" HeaderContainerStyle="{StaticResource SortableHeaderStyle}"/>
                                </GridView>
                            </ListView.View>
                            <ListView.ContextMenu>
                                <ContextMenu>
                                    <MenuItem Header="Create Wildcard Rule..." Click="CreateWildcardFromPending_Click"/>
                                    <Separator/>
                                    <MenuItem Header="Open File Location" Click="OpenFileLocation_Click"/>
                                </ContextMenu>
                            </ListView.ContextMenu>
                        </ListView>
                        <StackPanel VerticalAlignment="Center" HorizontalAlignment="Center">
                            <StackPanel.Style>
                                <Style TargetType="StackPanel">
                                    <Setter Property="Visibility" Value="Collapsed" />
                                    <Style.Triggers>
                                        <MultiDataTrigger>
                                            <MultiDataTrigger.Conditions>
                                                <Condition Binding="{Binding PendingConnections.Count}" Value="0" />
                                                <Condition Binding="{Binding IsLockedDown}" Value="False" />
                                            </MultiDataTrigger.Conditions>
                                            <Setter Property="Visibility" Value="Visible" />
                                        </MultiDataTrigger>
                                    </Style.Triggers>
                                </Style>
                            </StackPanel.Style>
                            <Image Source="/logo.png" Width="256" Height="256" Opacity="1.0" />
                            <TextBlock Text="Firewall is unlocked. No new connections are being blocked." FontSize="16" Foreground="Gray" Margin="0,20,0,0" />
                        </StackPanel>
                        <TextBlock HorizontalAlignment="Center" VerticalAlignment="Center" FontSize="16" Foreground="Gray" Text="Firewall is locked down. Waiting for new connection attempts...">
                            <TextBlock.Style>
                                <Style TargetType="TextBlock">
                                    <Setter Property="Visibility" Value="Collapsed" />
                                    <Style.Triggers>
                                        <MultiDataTrigger>
                                            <MultiDataTrigger.Conditions>
                                                <Condition Binding="{Binding PendingConnections.Count}" Value="0" />
                                                <Condition Binding="{Binding IsLockedDown}" Value="True" />
                                            </MultiDataTrigger.Conditions>
                                            <Setter Property="Visibility" Value="Visible" />
                                        </MultiDataTrigger>
                                    </Style.Triggers>
                                </Style>
                            </TextBlock.Style>
                        </TextBlock>
                    </Grid>
                </TabItem>
                <TabItem Header="Programs">
                    <ListView x:Name="ProgramsListView" ItemsSource="{Binding ProgramRules}" FontSize="14" SelectionMode="Extended" ItemContainerStyle="{StaticResource StatusRowStyle}" Background="{DynamicResource App.Window.Background}" BorderThickness="0" ContextMenuOpening="ListView_ContextMenuOpening">
                        <ListView.View>
                            <GridView>
                                <GridViewColumn Header="Name" Width="250" HeaderContainerStyle="{StaticResource SortableHeaderStyle}" DisplayMemberBinding="{Binding Name}"/>
                                <GridViewColumn Header="Status" DisplayMemberBinding="{Binding Status}" Width="120" HeaderContainerStyle="{StaticResource SortableHeaderStyle}"/>
                                <GridViewColumn Header="Application" DisplayMemberBinding="{Binding ApplicationName}" Width="580" HeaderContainerStyle="{StaticResource SortableHeaderStyle}"/>
                            </GridView>
                        </ListView.View>
                        <ListView.ContextMenu>
                            <ContextMenu>
                                <MenuItem Header="Edit Rule(s)" Click="EditProgramRules_Click"/>
                                <MenuItem Header="Delete Rule(s)" Click="DeleteAppRules_Click"/>
                                <Separator/>
                                <MenuItem Header="Open File Location" Click="OpenFileLocation_Click"/>
                            </ContextMenu>
                        </ListView.ContextMenu>
                    </ListView>
                </TabItem>
                <TabItem Header="Services">
                    <ListView x:Name="ServicesListView" ItemsSource="{Binding Services}" FontSize="14" SelectionMode="Extended" ItemContainerStyle="{StaticResource StatusRowStyle}" Background="{DynamicResource App.Window.Background}" BorderThickness="0" ContextMenuOpening="ListView_ContextMenuOpening">
                        <ListView.View>
                            <GridView>
                                <GridViewColumn Header="Display Name" Width="300" HeaderContainerStyle="{StaticResource SortableHeaderStyle}" DisplayMemberBinding="{Binding Name}"/>
                                <GridViewColumn Header="Status" DisplayMemberBinding="{Binding Status}" Width="120" HeaderContainerStyle="{StaticResource SortableHeaderStyle}"/>
                                <GridViewColumn Header="Service Path" DisplayMemberBinding="{Binding ApplicationName}" Width="530" HeaderContainerStyle="{StaticResource SortableHeaderStyle}"/>
                            </GridView>
                        </ListView.View>
                        <ListView.ContextMenu>
                            <ContextMenu>
                                <MenuItem Header="Edit Rule(s)" Click="EditServiceRules_Click"/>
                                <MenuItem Header="Delete Rule(s)" Click="DeleteAppRules_Click"/>
                                <Separator/>
                                <MenuItem Header="Open File Location" Click="OpenFileLocation_Click"/>
                            </ContextMenu>
                        </ListView.ContextMenu>
                    </ListView>
                </TabItem>
                <TabItem Header="UWP Apps">
                    <ListView x:Name="UwpAppsListView" ItemsSource="{Binding UwpApps}" FontSize="14" SelectionMode="Extended" ItemContainerStyle="{StaticResource StatusRowStyle}" Background="{DynamicResource App.Window.Background}" BorderThickness="0" ContextMenuOpening="ListView_ContextMenuOpening">
                        <ListView.View>
                            <GridView>
                                <GridViewColumn Header="Name" Width="300" HeaderContainerStyle="{StaticResource SortableHeaderStyle}" DisplayMemberBinding="{Binding Name}"/>
                                <GridViewColumn Header="Status" DisplayMemberBinding="{Binding Status}" Width="120" HeaderContainerStyle="{StaticResource SortableHeaderStyle}"/>
                                <GridViewColumn Header="Package Family Name" DisplayMemberBinding="{Binding PackageFamilyName}" Width="530" HeaderContainerStyle="{StaticResource SortableHeaderStyle}"/>
                            </GridView>
                        </ListView.View>
                        <ListView.ContextMenu>
                            <ContextMenu>
                                <MenuItem Header="Edit Rule(s)" Click="EditUwpRules_Click"/>
                                <MenuItem Header="Delete Rule(s)" Click="DeleteUwpRules_Click"/>
                            </ContextMenu>
                        </ListView.ContextMenu>
                    </ListView>
                </TabItem>
                <TabItem Header="Wildcard Rules">
                    <DockPanel>
                        <StackPanel DockPanel.Dock="Top" Orientation="Horizontal" Margin="5">
                            <Button Content="Create Wildcard Rule..." Command="{Binding CreateWildcardFromTabCommand}"/>
                        </StackPanel>
                        <ListView x:Name="WildcardRulesListView" ItemsSource="{Binding WildcardRules}" FontSize="14" SelectionMode="Single" ItemContainerStyle="{StaticResource UndefinedRowStyle}" Background="{DynamicResource App.Window.Background}" BorderThickness="0" ContextMenuOpening="ListView_ContextMenuOpening">
                            <ListView.View>
                                <GridView>
                                    <GridViewColumn Header="Action" DisplayMemberBinding="{Binding Action}" Width="150" HeaderContainerStyle="{StaticResource SortableHeaderStyle}"/>
                                    <GridViewColumn Header="Executable Name" DisplayMemberBinding="{Binding ExeName}" Width="150" HeaderContainerStyle="{StaticResource SortableHeaderStyle}"/>
                                    <GridViewColumn Header="Folder Path" DisplayMemberBinding="{Binding FolderPath}" Width="620" HeaderContainerStyle="{StaticResource SortableHeaderStyle}"/>
                                </GridView>
                            </ListView.View>
                            <ListView.ContextMenu>
                                <ContextMenu>
                                    <MenuItem Header="Delete Wildcard Rule" Command="{Binding RemoveWildcardRuleCommand}" CommandParameter="{Binding RelativeSource={RelativeSource AncestorType=ContextMenu}, Path=PlacementTarget.SelectedItem}"/>
                                </ContextMenu>
                            </ListView.ContextMenu>
                        </ListView>
                    </DockPanel>
                </TabItem>
                <TabItem Header="Advanced Rules">
                    <DockPanel>
                        <StackPanel DockPanel.Dock="Top" Orientation="Horizontal" Margin="5">
                            <Button Content="Create Advanced Rule..." Click="CreateAdvancedRule_Click" Margin="0,0,5,0"/>
                            <Button Content="Open Windows Firewall..." Click="OpenFirewallConsole_Click"/>
                        </StackPanel>
                        <ListView x:Name="AdvancedRulesListView" ItemsSource="{Binding AdvancedRules}" FontSize="12" SelectionMode="Extended" ItemContainerStyle="{StaticResource UndefinedRowStyle}" Background="{DynamicResource App.Window.Background}" BorderThickness="0" ContextMenuOpening="ListView_ContextMenuOpening">
                            <ListView.View>
                                <GridView>
                                    <GridViewColumn Header="Name" DisplayMemberBinding="{Binding Name}" Width="150" HeaderContainerStyle="{StaticResource SortableHeaderStyle}"/>
                                    <GridViewColumn Header="Status" DisplayMemberBinding="{Binding Status}" Width="60" HeaderContainerStyle="{StaticResource SortableHeaderStyle}"/>
                                    <GridViewColumn Header="Enabled" DisplayMemberBinding="{Binding IsEnabled}" Width="60" HeaderContainerStyle="{StaticResource SortableHeaderStyle}"/>
                                    <GridViewColumn Header="Direction" DisplayMemberBinding="{Binding Direction}" Width="70" HeaderContainerStyle="{StaticResource SortableHeaderStyle}"/>
                                    <GridViewColumn Header="Port(s)" DisplayMemberBinding="{Binding Ports}" Width="100" HeaderContainerStyle="{StaticResource SortableHeaderStyle}"/>
                                    <GridViewColumn Header="Protocol" DisplayMemberBinding="{Binding Protocol}" Width="60" HeaderContainerStyle="{StaticResource SortableHeaderStyle}"/>
                                    <GridViewColumn Header="Service" DisplayMemberBinding="{Binding ServiceName}" Width="100" HeaderContainerStyle="{StaticResource SortableHeaderStyle}"/>
                                    <GridViewColumn Header="Remote IPs" DisplayMemberBinding="{Binding RemoteAddresses}" Width="120" HeaderContainerStyle="{StaticResource SortableHeaderStyle}"/>
                                    <GridViewColumn Header="Profiles" DisplayMemberBinding="{Binding Profiles}" Width="80" HeaderContainerStyle="{StaticResource SortableHeaderStyle}"/>
                                    <GridViewColumn Header="Description" DisplayMemberBinding="{Binding Description}" Width="150" HeaderContainerStyle="{StaticResource SortableHeaderStyle}"/>
                                </GridView>
                            </ListView.View>
                            <ListView.ContextMenu>
                                <ContextMenu>
                                    <MenuItem Header="Delete Rule(s)" Click="DeleteAdvancedRules_Click"/>
                                </ContextMenu>
                            </ListView.ContextMenu>
                        </ListView>
                    </DockPanel>
                </TabItem>
                <TabItem Header="Foreign Rules">
                    <Grid>
                        <Grid.RowDefinitions>
                            <RowDefinition Height="Auto"/>
                            <RowDefinition Height="*"/>
                        </Grid.RowDefinitions>

                        <StackPanel Grid.Row="0" Orientation="Vertical" Margin="5">
                            <TextBlock TextWrapping="Wrap" Foreground="{DynamicResource App.Text.Default}">
                                This tab shows newly detected firewall rules that were NOT created by Minimal Firewall. Review them to ensure they are not malicious or unwanted.
                            </TextBlock>
                            <StackPanel Orientation="Horizontal" Margin="0,10,0,0">
                                <Button Content="Acknowledge All Rules" Command="{Binding AcknowledgeForeignRulesCommand}"/>
                                <Button Content="Rescan" Margin="5,0,0,0" Click="RescanForeignRules_Click"/>
                            </StackPanel>
                        </StackPanel>

                        <ListView Grid.Row="1" x:Name="ForeignRulesListView" ItemsSource="{Binding ForeignRules}" FontSize="12" SelectionMode="Extended" ItemContainerStyle="{StaticResource UndefinedRowStyle}" Background="{DynamicResource App.Window.Background}" BorderThickness="0" ContextMenuOpening="ListView_ContextMenuOpening">
                            <ListView.View>
                                <GridView>
                                    <GridViewColumn Header="Name" DisplayMemberBinding="{Binding Name}" Width="150" HeaderContainerStyle="{StaticResource SortableHeaderStyle}"/>
                                    <GridViewColumn Header="Status" DisplayMemberBinding="{Binding Status}" Width="60" HeaderContainerStyle="{StaticResource SortableHeaderStyle}"/>
                                    <GridViewColumn Header="Enabled" DisplayMemberBinding="{Binding IsEnabled}" Width="60" HeaderContainerStyle="{StaticResource SortableHeaderStyle}"/>
                                    <GridViewColumn Header="Direction" DisplayMemberBinding="{Binding Direction}" Width="70" HeaderContainerStyle="{StaticResource SortableHeaderStyle}"/>
                                    <GridViewColumn Header="Port(s)" DisplayMemberBinding="{Binding Ports}" Width="100" HeaderContainerStyle="{StaticResource SortableHeaderStyle}"/>
                                    <GridViewColumn Header="Protocol" DisplayMemberBinding="{Binding Protocol}" Width="60" HeaderContainerStyle="{StaticResource SortableHeaderStyle}"/>
                                    <GridViewColumn Header="Service" DisplayMemberBinding="{Binding ServiceName}" Width="100" HeaderContainerStyle="{StaticResource SortableHeaderStyle}"/>
                                    <GridViewColumn Header="Remote IPs" DisplayMemberBinding="{Binding RemoteAddresses}" Width="120" HeaderContainerStyle="{StaticResource SortableHeaderStyle}"/>
                                    <GridViewColumn Header="Profiles" DisplayMemberBinding="{Binding Profiles}" Width="80" HeaderContainerStyle="{StaticResource SortableHeaderStyle}"/>
                                    <GridViewColumn Header="Description" DisplayMemberBinding="{Binding Description}" Width="150" HeaderContainerStyle="{StaticResource SortableHeaderStyle}"/>
                                </GridView>
                            </ListView.View>
                            <ListView.ContextMenu>
                                <ContextMenu>
                                    <MenuItem Header="Delete Rule(s)" Click="DeleteAdvancedRules_Click"/>
                                </ContextMenu>
                            </ListView.ContextMenu>
                        </ListView>
                    </Grid>
                </TabItem>
                <TabItem Header="Undefined Programs">
                    <DockPanel>
                        <StackPanel DockPanel.Dock="Top" Orientation="Vertical" Margin="5">
                            <TextBlock TextWrapping="Wrap" Margin="0,0,0,10" Foreground="{DynamicResource App.Text.Default}">This list shows programs found by the directory scanner that do not have any existing firewall rules.</TextBlock>
                            <StackPanel Orientation="Horizontal">
                                <Button Content="Scan Directory..." Command="{Binding ScanDirectoryCommand}" Margin="0,0,5,0"/>
                                <Button Content="Clear List" Command="{Binding ClearUndefinedProgramsCommand}"/>
                            </StackPanel>
                        </StackPanel>
                        <ListView x:Name="UndefinedProgramsListView" ItemsSource="{Binding UndefinedPrograms}" FontSize="14" SelectionMode="Extended" ItemContainerStyle="{StaticResource UndefinedRowStyle}" Background="{DynamicResource App.Window.Background}" BorderThickness="0" ContextMenuOpening="ListView_ContextMenuOpening">
                            <ListView.Style>
                                <Style TargetType="ListView">
                                    <Setter Property="Visibility" Value="Visible"/>
                                    <Style.Triggers>
                                        <DataTrigger Binding="{Binding UndefinedPrograms.Count}" Value="0">
                                            <Setter Property="Visibility" Value="Collapsed"/>
                                        </DataTrigger>
                                    </Style.Triggers>
                                </Style>
                            </ListView.Style>
                            <ListView.View>
                                <GridView>
                                    <GridViewColumn Header="Name" Width="300" HeaderContainerStyle="{StaticResource SortableHeaderStyle}" DisplayMemberBinding="{Binding Name}"/>
                                    <GridViewColumn Header="Path" DisplayMemberBinding="{Binding ExePath}" Width="650" HeaderContainerStyle="{StaticResource SortableHeaderStyle}"/>
                                </GridView>
                            </ListView.View>
                            <ListView.ContextMenu>
                                <ContextMenu>
                                    <MenuItem Header="Create Rule(s)" Click="CreateProgramRules_Click"/>
                                    <Separator/>
                                    <MenuItem Header="Open File Location" Click="OpenFileLocation_Click"/>
                                </ContextMenu>
                            </ListView.ContextMenu>
                        </ListView>
                        <TextBlock Text="Click 'Scan Directory...' to find programs without existing rules."
                                   HorizontalAlignment="Center" VerticalAlignment="Center" FontSize="16" Foreground="Gray">
                            <TextBlock.Style>
                                <Style TargetType="TextBlock">
                                    <Setter Property="Visibility" Value="Collapsed"/>
                                    <Style.Triggers>
                                        <DataTrigger Binding="{Binding UndefinedPrograms.Count}" Value="0">
                                            <Setter Property="Visibility" Value="Visible"/>
                                        </DataTrigger>
                                    </Style.Triggers>
                                </Style>
                            </TextBlock.Style>
                        </TextBlock>
                    </DockPanel>
                </TabItem>
            </TabControl>
        </DockPanel>
    </Border>
</Window>

--------------------------------------------------------------------------------
// File: FirewallActionsService.cs
--------------------------------------------------------------------------------
ï»¿using NetFwTypeLib;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Threading;
using System.Windows;

namespace MinimalFirewall
{
    public class FirewallActionsService
    {
        private readonly FirewallRuleService _firewallService;
        private readonly FirewallDataService _dataService;
        private readonly UserActivityLogger _activityLogger;
        private readonly Dictionary<string, Timer> _activeTempRuleTimers = new Dictionary<string, Timer>();
        public event Action<string> ApplicationRuleSetExpired;

        public FirewallActionsService(FirewallRuleService firewallService, FirewallDataService dataService, UserActivityLogger activityLogger)
        {
            _firewallService = firewallService;
            _dataService = dataService;
            _activityLogger = activityLogger;
        }

        public void ApplyApplicationRuleChange(List<string> appPaths, string action, string wildcardSourcePath = null)
        {
            foreach (var appPath in appPaths)
            {
                if (string.IsNullOrEmpty(wildcardSourcePath))
                {
                    if (action.Contains("Inbound") || action.Contains("(All)"))
                    {
                        _firewallService.DeleteRuleByPathAndDirection(appPath, NET_FW_RULE_DIRECTION_.NET_FW_RULE_DIR_IN);
                    }
                    if (action.Contains("Outbound") || action.Contains("(All)"))
                    {
                        _firewallService.DeleteRuleByPathAndDirection(appPath, NET_FW_RULE_DIRECTION_.NET_FW_RULE_DIR_OUT);
                    }
                }

                string appName = Path.GetFileNameWithoutExtension(appPath);
                void createRule(string name, NET_FW_RULE_DIRECTION_ dir, NET_FW_ACTION_ act)
                {
                    string description = string.IsNullOrEmpty(wildcardSourcePath) ? "" : $"{MFWConstants.WildcardDescriptionPrefix}{wildcardSourcePath}]";
                    CreateApplicationRule(name, appPath, dir, act, description);
                }
                ApplyRuleAction(appName, action, createRule);
                _activityLogger.Log("Rule Changed", action + " for " + appPath);
                _dataService.AddOrUpdateAppRule(appPath);
            }
        }

        public void ApplyServiceRuleChange(string serviceName, string action)
        {
            if (string.IsNullOrEmpty(serviceName)) return;

            _firewallService.DeleteRulesByServiceName(serviceName);

            void createRule(string name, NET_FW_RULE_DIRECTION_ dir, NET_FW_ACTION_ act)
            {
                var firewallRule = (INetFwRule2)Activator.CreateInstance(Type.GetTypeFromProgID("HNetCfg.FWRule"));
                firewallRule.Name = name;
                firewallRule.serviceName = serviceName;
                firewallRule.Direction = dir;
                firewallRule.Action = act;
                firewallRule.Enabled = true;
                firewallRule.Protocol = (int)NET_FW_IP_PROTOCOL_.NET_FW_IP_PROTOCOL_ANY;
                firewallRule.Grouping = MFWConstants.MainRuleGroup;
                _firewallService.CreateRule(firewallRule);
            }

            ApplyRuleAction(serviceName, action, createRule);
            _activityLogger.Log("Service Rule Changed", action + " for " + serviceName);
            _dataService.LoadInitialData();
        }

        public void ApplyUwpRuleChange(List<UwpApp> uwpApps, string action)
        {
            var packageFamilyNames = uwpApps.Select(app => app.PackageFamilyName).ToList();
            _firewallService.DeleteUwpRules(packageFamilyNames);
            foreach (var app in uwpApps)
            {
                void createRule(string name, NET_FW_RULE_DIRECTION_ dir, NET_FW_ACTION_ act) => CreateUwpRule(name, app.PackageFamilyName, dir, act);
                ApplyRuleAction(app.Name, action, createRule);
                _activityLogger.Log("UWP Rule Changed", action + " for " + app.Name);
            }
            _dataService.LoadInitialData();
        }

        public void DeleteApplicationRules(List<string> appPaths)
        {
            if (appPaths.Count == 0) return;
            var result = MessageBox.Show("Are you sure you want to delete all rules for " + appPaths.Count + " application(s)?", "Confirm Deletion", MessageBoxButton.YesNo, MessageBoxImage.Warning, MessageBoxResult.No);
            if (result == MessageBoxResult.No) return;

            _firewallService.DeleteRulesByPath(appPaths);
            _dataService.RemoveRulesByPath(appPaths);
            foreach (var path in appPaths) _activityLogger.Log("Rule Deleted", path);
        }

        public void DeleteRulesForWildcard(WildcardRule wildcard)
        {
            if (wildcard == null) return;
            string descriptionTag = $"{MFWConstants.WildcardDescriptionPrefix}{wildcard.FolderPath}]";
            _firewallService.DeleteRulesByDescription(descriptionTag);
            _activityLogger.Log("Wildcard Rules Deleted", $"Deleted rules for folder {wildcard.FolderPath}");
        }

        public void DeleteUwpRules(List<string> packageFamilyNames)
        {
            if (packageFamilyNames.Count == 0) return;
            var result = MessageBox.Show("Are you sure you want to delete all rules for " + packageFamilyNames.Count + " UWP app(s)?", "Confirm Deletion", MessageBoxButton.YesNo, MessageBoxImage.Warning, MessageBoxResult.No);
            if (result == MessageBoxResult.No) return;
            _firewallService.DeleteUwpRules(packageFamilyNames);
            foreach (var pfn in packageFamilyNames) _activityLogger.Log("UWP Rule Deleted", pfn);
            _dataService.LoadInitialData();
        }

        public void DeleteAdvancedRules(List<string> ruleNames)
        {
            if (ruleNames.Count == 0) return;
            var result = MessageBox.Show("Are you sure you want to delete " + ruleNames.Count + " rule(s)?", "Confirm Deletion", MessageBoxButton.YesNo, MessageBoxImage.Warning, MessageBoxResult.No);
            if (result == MessageBoxResult.No) return;

            _firewallService.DeleteRulesByName(ruleNames);
            _dataService.RemoveAdvancedRulesByName(ruleNames);
            foreach (var name in ruleNames) _activityLogger.Log("Advanced Rule Deleted", name);
        }

        public void CreatePowerShellRule(string command)
        {
            if (string.IsNullOrWhiteSpace(command)) return;
            AdminTaskService.ExecutePowerShellRuleCommand(command);
            _activityLogger.Log("Advanced Rule Created", command);
            _dataService.LoadInitialData();
        }

        public void ToggleLockdown()
        {
            var isCurrentlyLocked = _firewallService.GetDefaultOutboundAction() == NET_FW_ACTION_.NET_FW_ACTION_BLOCK;
            bool newLockdownState = !isCurrentlyLocked;
            AdminTaskService.SetAuditPolicy(newLockdownState);
            _firewallService.SetDefaultOutboundAction(newLockdownState ? NET_FW_ACTION_.NET_FW_ACTION_BLOCK : NET_FW_ACTION_.NET_FW_ACTION_ALLOW);
            _activityLogger.Log("Lockdown Mode", newLockdownState ? "Enabled" : "Disabled");
        }

        public void AllowPendingConnectionTemporarily(PendingConnectionViewModel pending, int minutes)
        {
            string appName = Path.GetFileNameWithoutExtension(pending.AppPath);
            string guid = Guid.NewGuid().ToString("N").Substring(0, 8);

            NET_FW_RULE_DIRECTION_ directionEnum = pending.Direction == "Outbound" ? NET_FW_RULE_DIRECTION_.NET_FW_RULE_DIR_OUT : NET_FW_RULE_DIRECTION_.NET_FW_RULE_DIR_IN;
            string directionString = pending.Direction == "Outbound" ? "Out" : "In";

            string tempRuleName = $"Temp Allow {directionString} - {appName} ({guid})";
            var tempRule = CreateRuleObject(tempRuleName, pending.AppPath, directionEnum, NET_FW_ACTION_.NET_FW_ACTION_ALLOW);
            _firewallService.CreateRule(tempRule);

            _dataService.AddOrUpdateAppRule(pending.AppPath);
            _activityLogger.Log("Temporary Rule Created", $"{minutes} min for {pending.AppPath} ({directionString})");

            var timer = new Timer(_ => DeleteTemporaryRule(tempRuleName, pending.AppPath), null, TimeSpan.FromMinutes(minutes), Timeout.InfiniteTimeSpan);
            _activeTempRuleTimers[tempRuleName] = timer;
        }

        private void DeleteTemporaryRule(string ruleName, string appPath)
        {
            _firewallService.DeleteRulesByName(new List<string> { ruleName });
            if (_activeTempRuleTimers.ContainsKey(ruleName))
            {
                _activeTempRuleTimers[ruleName].Dispose();
                _activeTempRuleTimers.Remove(ruleName);
            }

            _activityLogger.Log("Temporary Rule Expired", ruleName);
            ApplicationRuleSetExpired?.Invoke(appPath);
        }

        private static void ApplyRuleAction(string appName, string action, Action<string, NET_FW_RULE_DIRECTION_, NET_FW_ACTION_> createRule)
        {
            switch (action)
            {
                case "Allow (All)":
                    createRule(appName + " - In (MFW)", NET_FW_RULE_DIRECTION_.NET_FW_RULE_DIR_IN, NET_FW_ACTION_.NET_FW_ACTION_ALLOW);
                    createRule(appName + " - Out (MFW)", NET_FW_RULE_DIRECTION_.NET_FW_RULE_DIR_OUT, NET_FW_ACTION_.NET_FW_ACTION_ALLOW); break;
                case "Allow (Outbound)": createRule(appName + " - Out (MFW)", NET_FW_RULE_DIRECTION_.NET_FW_RULE_DIR_OUT, NET_FW_ACTION_.NET_FW_ACTION_ALLOW); break;
                case "Allow (Inbound)": createRule(appName + " - In (MFW)", NET_FW_RULE_DIRECTION_.NET_FW_RULE_DIR_IN, NET_FW_ACTION_.NET_FW_ACTION_ALLOW); break;
                case "Block (All)":
                    createRule(appName + " - Block In (MFW)", NET_FW_RULE_DIRECTION_.NET_FW_RULE_DIR_IN, NET_FW_ACTION_.NET_FW_ACTION_BLOCK);
                    createRule(appName + " - Block Out (MFW)", NET_FW_RULE_DIRECTION_.NET_FW_RULE_DIR_OUT, NET_FW_ACTION_.NET_FW_ACTION_BLOCK); break;
                case "Block (Outbound)": createRule(appName + " - Block Out (MFW)", NET_FW_RULE_DIRECTION_.NET_FW_RULE_DIR_OUT, NET_FW_ACTION_.NET_FW_ACTION_BLOCK); break;
                case "Block (Inbound)": createRule(appName + " - Block In (MFW)", NET_FW_RULE_DIRECTION_.NET_FW_RULE_DIR_IN, NET_FW_ACTION_.NET_FW_ACTION_BLOCK); break;
            }
        }

        private static INetFwRule2 CreateRuleObject(string name, string appPath, NET_FW_RULE_DIRECTION_ direction, NET_FW_ACTION_ action, string description = "")
        {
            var firewallRule = (INetFwRule2)Activator.CreateInstance(Type.GetTypeFromProgID("HNetCfg.FWRule"));
            firewallRule.Name = name;
            firewallRule.ApplicationName = appPath;
            firewallRule.Direction = direction;
            firewallRule.Action = action;
            firewallRule.Enabled = true;
            firewallRule.Protocol = 256;

            if (!string.IsNullOrEmpty(description) && description.StartsWith(MFWConstants.WildcardDescriptionPrefix))
            {
                firewallRule.Grouping = MFWConstants.WildcardRuleGroup;
                firewallRule.Description = description;
            }
            else
            {
                firewallRule.Grouping = MFWConstants.MainRuleGroup;
            }
            return firewallRule;
        }

        private void CreateApplicationRule(string name, string appPath, NET_FW_RULE_DIRECTION_ direction, NET_FW_ACTION_ action, string description)
        {
            var rule = CreateRuleObject(name, appPath, direction, action, description);
            _firewallService.CreateRule(rule);
        }

        private void CreateUwpRule(string name, string packageFamilyName, NET_FW_RULE_DIRECTION_ direction, NET_FW_ACTION_ action)
        {
            var firewallRule = (INetFwRule2)Activator.CreateInstance(Type.GetTypeFromProgID("HNetCfg.FWRule"));
            firewallRule.Name = name;
            firewallRule.Description = MFWConstants.UwpDescriptionPrefix + packageFamilyName;
            firewallRule.Direction = direction;
            firewallRule.Action = action;
            firewallRule.Enabled = true;
            firewallRule.Protocol = 256;
            firewallRule.Grouping = MFWConstants.MainRuleGroup;
            _firewallService.CreateRule(firewallRule);
        }
    }
}

--------------------------------------------------------------------------------
// File: FirewallRuleService.cs
--------------------------------------------------------------------------------
ï»¿using NetFwTypeLib;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Windows;

namespace MinimalFirewall
{
    public class FirewallRuleService
    {
        private readonly INetFwPolicy2 _firewallPolicy;
        public FirewallRuleService()
        {
            try
            {
                Type firewallPolicyType = Type.GetTypeFromProgID("HNetCfg.FwPolicy2");
                if (firewallPolicyType != null)
                {
                    _firewallPolicy = (INetFwPolicy2)Activator.CreateInstance(firewallPolicyType);
                }
            }
            catch (Exception ex)
            {
                MessageBox.Show("Could not initialize firewall policy: \n\n" + ex.Message, "Fatal Error", MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }

        public List<INetFwRule2> GetAllRules()
        {
            if (_firewallPolicy == null) return new List<INetFwRule2>();
            return new List<INetFwRule2>(_firewallPolicy.Rules.Cast<INetFwRule2>());
        }

        public void SetDefaultOutboundAction(NET_FW_ACTION_ action)
        {
            if (_firewallPolicy == null) return;
            var profiles = new[] { NET_FW_PROFILE_TYPE2_.NET_FW_PROFILE2_DOMAIN, NET_FW_PROFILE_TYPE2_.NET_FW_PROFILE2_PRIVATE, NET_FW_PROFILE_TYPE2_.NET_FW_PROFILE2_PUBLIC };
            foreach (var profile in profiles)
            {
                _firewallPolicy.DefaultOutboundAction[profile] = action;
            }
        }

        public NET_FW_ACTION_ GetDefaultOutboundAction()
        {
            if (_firewallPolicy == null) return NET_FW_ACTION_.NET_FW_ACTION_ALLOW;

            try
            {
                var currentProfileTypes = (NET_FW_PROFILE_TYPE2_)_firewallPolicy.CurrentProfileTypes;

                if ((currentProfileTypes & NET_FW_PROFILE_TYPE2_.NET_FW_PROFILE2_PUBLIC) != 0)
                {
                    return _firewallPolicy.DefaultOutboundAction[NET_FW_PROFILE_TYPE2_.NET_FW_PROFILE2_PUBLIC];
                }
                if ((currentProfileTypes & NET_FW_PROFILE_TYPE2_.NET_FW_PROFILE2_PRIVATE) != 0)
                {
                    return _firewallPolicy.DefaultOutboundAction[NET_FW_PROFILE_TYPE2_.NET_FW_PROFILE2_PRIVATE];
                }
                if ((currentProfileTypes & NET_FW_PROFILE_TYPE2_.NET_FW_PROFILE2_DOMAIN) != 0)
                {
                    return _firewallPolicy.DefaultOutboundAction[NET_FW_PROFILE_TYPE2_.NET_FW_PROFILE2_DOMAIN];
                }
            }
            catch (Exception ex)
            {
                try
                {
                    string logPath = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "crash_log.txt");
                    string logContent = $"--- Minimal Firewall Crash Log ---\r\n" +
                                        $"Timestamp: {DateTime.Now:yyyy-MM-dd HH:mm:ss}\r\n" +
                                        $"Source: FirewallRuleService.GetDefaultOutboundAction\r\n" +
                                        $"--- Exception Details ---\r\n" +
                                        $"{ex}\r\n\r\n";
                    File.AppendAllText(logPath, logContent);
                }
                catch
                {
                }
            }

            return NET_FW_ACTION_.NET_FW_ACTION_ALLOW;
        }

        public void DeleteRulesByPath(List<string> appPaths)
        {
            if (_firewallPolicy == null || appPaths.Count == 0) return;
            var pathSet = new HashSet<string>(appPaths, StringComparer.OrdinalIgnoreCase);
            var rulesToRemove = _firewallPolicy.Rules.Cast<INetFwRule>()
                .Where(r => r != null && !string.IsNullOrEmpty(r.ApplicationName) && pathSet.Contains(r.ApplicationName))
                .Select(r => r.Name)
                .ToList();
            foreach (var ruleName in rulesToRemove)
            {
                try { _firewallPolicy.Rules.Remove(ruleName); } catch { /* Ignore errors */ }
            }
        }

        public void DeleteRuleByPathAndDirection(string appPath, NET_FW_RULE_DIRECTION_ direction)
        {
            if (_firewallPolicy == null || string.IsNullOrEmpty(appPath)) return;
            var rulesToRemove = _firewallPolicy.Rules.Cast<INetFwRule>()
                .Where(r => r != null &&
                            appPath.Equals(r.ApplicationName, StringComparison.OrdinalIgnoreCase) &&
                            r.Direction == direction)
                .Select(r => r.Name)
                .ToList();

            foreach (var ruleName in rulesToRemove)
            {
                try { _firewallPolicy.Rules.Remove(ruleName); } catch { /* Ignore errors */ }
            }
        }

        public void DeleteRulesByServiceName(string serviceName)
        {
            if (_firewallPolicy == null || string.IsNullOrEmpty(serviceName)) return;
            var rulesToRemove = _firewallPolicy.Rules.Cast<INetFwRule2>()
                .Where(r => r != null && serviceName.Equals(r.serviceName, StringComparison.OrdinalIgnoreCase))
                .Select(r => r.Name)
                .ToList();
            foreach (var ruleName in rulesToRemove)
            {
                try { _firewallPolicy.Rules.Remove(ruleName); } catch { /* Ignore errors */ }
            }
        }

        public void DeleteUwpRules(List<string> packageFamilyNames)
        {
            if (_firewallPolicy == null || packageFamilyNames.Count == 0) return;
            var pfnSet = new HashSet<string>(packageFamilyNames, StringComparer.OrdinalIgnoreCase);
            var rulesToRemove = new List<string>();
            foreach (INetFwRule2 rule in _firewallPolicy.Rules)
            {
                if (rule != null && !string.IsNullOrEmpty(rule.Description) && rule.Description.StartsWith("UWP App; PFN="))
                {
                    string pfnInRule = rule.Description.Substring("UWP App; PFN=".Length);
                    if (pfnSet.Contains(pfnInRule))
                    {
                        rulesToRemove.Add(rule.Name);
                    }
                }
            }

            foreach (var ruleName in rulesToRemove)
            {
                try { _firewallPolicy.Rules.Remove(ruleName); } catch { /* Ignore errors */ }
            }
        }

        public void DeleteRulesByName(List<string> ruleNames)
        {
            if (_firewallPolicy == null || ruleNames.Count == 0) return;
            foreach (var name in ruleNames)
            {
                try { _firewallPolicy.Rules.Remove(name); } catch { /* Ignore errors */ }
            }
        }

        public void CreateRule(INetFwRule2 rule)
        {
            try
            {
                _firewallPolicy?.Rules.Add(rule);
            }
            catch (Exception ex)
            {
                MessageBox.Show("Failed to create rule. The firewall API rejected the input.\n\nError: " + ex.Message, "Rule Creation Failed", MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }

        public void DeleteRulesByDescription(string description)
        {
            if (_firewallPolicy == null || string.IsNullOrEmpty(description)) return;
            var rulesToRemove = _firewallPolicy.Rules.Cast<INetFwRule>()
                .Where(r => r != null && !string.IsNullOrEmpty(r.Description) && r.Description.Equals(description, StringComparison.OrdinalIgnoreCase))
                .Select(r => r.Name)
                .ToList();

            foreach (var ruleName in rulesToRemove)
            {
                try { _firewallPolicy.Rules.Remove(ruleName); } catch { /* Ignore errors */ }
            }
        }
    }
}

--------------------------------------------------------------------------------
// File: MainWindow.xaml.cs
--------------------------------------------------------------------------------
ï»¿using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Controls.Primitives;
using System.Windows.Data;
using System.Windows.Forms;
using System.Drawing;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Shell;

namespace MinimalFirewall
{
    public partial class MainWindow : Window
    {
        private GridViewColumnHeader _lastHeaderClicked;
        private ListSortDirection _lastDirection;
        private NotifyIcon _notifyIcon;

        public MainWindow()
        {
            InitializeComponent();
            var vm = new MainViewModel();
            DataContext = vm;
            this.Loaded += MainWindow_Loaded;

            InitializeTrayIcon();
            this.Closing += MainWindow_Closing;
        }

        private void InitializeTrayIcon()
        {
            _notifyIcon = new NotifyIcon
            {
                Icon = GetAppIcon(),
                Visible = true,
                Text = "Minimal Firewall"
            };

            _notifyIcon.MouseDoubleClick += ShowWindow;
            var contextMenu = new System.Windows.Forms.ContextMenu();
            contextMenu.MenuItems.Add("Show", ShowWindow);
            contextMenu.MenuItems.Add("Exit", ExitApplication);
            _notifyIcon.ContextMenu = contextMenu;
        }

        private void MainWindow_Closing(object sender, CancelEventArgs e)
        {
            if (DataContext is MainViewModel vm && vm.IsCloseToTrayEnabled)
            {
                e.Cancel = true;
                this.Hide();
                vm.ClearCachesForTray();
            }
            else
            {
                _notifyIcon?.Dispose();
            }
        }

        private void ShowWindow(object sender, EventArgs e)
        {
            this.Show();
            this.WindowState = WindowState.Normal;
            this.Activate();

            if (DataContext is MainViewModel vm && vm.IsCacheCleared)
            {
                vm.SlowRefresh();
            }
        }

        private void ExitApplication(object sender, EventArgs e)
        {
            if (_notifyIcon != null)
            {
                _notifyIcon.Dispose();
                _notifyIcon = null;
            }
            System.Windows.Application.Current.Shutdown();
        }

        private Icon GetAppIcon()
        {
            try
            {
                var exePath = System.Reflection.Assembly.GetExecutingAssembly().Location;
                return System.Drawing.Icon.ExtractAssociatedIcon(exePath);
            }
            catch
            {
                return SystemIcons.Shield;
            }
        }

        private async void MainWindow_Loaded(object sender, RoutedEventArgs e)
        {
            if (DataContext is MainViewModel vm)
            {
                await vm.InitializeAsync();
            }
        }

        private void CreateWildcardFromPending_Click(object sender, RoutedEventArgs e)
        {
            if (PendingConnectionsListView.SelectedItem is PendingConnectionViewModel pending && DataContext is MainViewModel vm)
            {
                vm.HandleWildcardCreationRequest(Path.GetDirectoryName(pending.AppPath), pending);
            }
        }

        private void EditProgramRules_Click(object sender, RoutedEventArgs e)
        {
            HandleRuleEdit(ProgramsListView.SelectedItems.Cast<FirewallRuleViewModel>().Select(vm => vm.ApplicationName));
        }

        private void EditUwpRules_Click(object sender, RoutedEventArgs e)
        {
            HandleUwpRuleEdit(UwpAppsListView.SelectedItems.Cast<UwpApp>().ToList());
        }

        private void DeleteAppRules_Click(object sender, RoutedEventArgs e)
        {
            if (DataContext is MainViewModel mainViewModel)
            {
                var programPaths = ProgramsListView.SelectedItems.Cast<FirewallRuleViewModel>().Select(vm => vm.ApplicationName).ToList();
                var servicePaths = ServicesListView.SelectedItems.Cast<FirewallRuleViewModel>().Select(vm => vm.ApplicationName).ToList();

                var combinedPaths = new List<string>();
                combinedPaths.AddRange(programPaths);
                combinedPaths.AddRange(servicePaths);
                mainViewModel.DeleteApplicationRules(combinedPaths);
            }
        }

        private void DeleteUwpRules_Click(object sender, RoutedEventArgs e)
        {
            if (DataContext is MainViewModel vm)
            {
                var packageFamilyNames = UwpAppsListView.SelectedItems.Cast<UwpApp>().Select(app => app.PackageFamilyName).ToList();
                vm.DeleteUwpRules(packageFamilyNames);
            }
        }

        private void EditServiceRules_Click(object sender, RoutedEventArgs e)
        {
            HandleRuleEdit(ServicesListView.SelectedItems.Cast<FirewallRuleViewModel>().Select(vm => vm.ApplicationName));
        }

        private void CreateProgramRules_Click(object sender, RoutedEventArgs e)
        {
            HandleRuleEdit(UndefinedProgramsListView.SelectedItems.Cast<ProgramViewModel>().Select(vm => vm.ExePath));
        }

        private void CreateAdvancedRule_Click(object sender, RoutedEventArgs e)
        {
            var dialog = new AdvancedRuleCreator();
            if (dialog.ShowDialog() == true && DataContext is MainViewModel vm)
            {
                vm.CreatePowerShellRule(dialog.RuleCommand);
            }
        }

        private void OpenFirewallConsole_Click(object sender, RoutedEventArgs e)
        {
            try
            {
                Process.Start("wf.msc");
            }
            catch (Exception ex)
            {
                System.Windows.MessageBox.Show("Could not open Windows Firewall console.\n\nError: " + ex.Message, "Error", MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }

        private void DeleteAdvancedRules_Click(object sender, RoutedEventArgs e)
        {
            if (!(DataContext is MainViewModel vm)) return;
            if (!(sender is System.Windows.Controls.MenuItem menuItem)) return;
            if (!(menuItem.Parent is System.Windows.Controls.ContextMenu contextMenu)) return;

            IEnumerable<string> ruleNamesToDelete = null;

            if (contextMenu.PlacementTarget == AdvancedRulesListView)
            {
                ruleNamesToDelete = AdvancedRulesListView.SelectedItems.Cast<AdvancedRuleViewModel>().Select(r => r.Name);
            }
            else if (contextMenu.PlacementTarget == ForeignRulesListView)
            {
                ruleNamesToDelete = ForeignRulesListView.SelectedItems.Cast<AdvancedRuleViewModel>().Select(r => r.Name);
            }

            if (ruleNamesToDelete != null && ruleNamesToDelete.Any())
            {
                vm.DeleteAdvancedRules(ruleNamesToDelete.ToList());
            }
        }

        private void OpenFileLocation_Click(object sender, RoutedEventArgs e)
        {
            if (!(sender is System.Windows.Controls.MenuItem menuItem) || !(menuItem.Parent is System.Windows.Controls.ContextMenu contextMenu)) return;
            if (!(contextMenu.PlacementTarget is System.Windows.Controls.ListView listView)) return;

            var selectedItem = listView.SelectedItem;
            if (selectedItem == null) return;

            string exePath = null;
            if (selectedItem is FirewallRuleViewModel fwRuleVm) exePath = fwRuleVm.ApplicationName;
            else if (selectedItem is PendingConnectionViewModel pendingVm) exePath = pendingVm.AppPath;
            else if (selectedItem is ProgramViewModel programVm) exePath = programVm.ExePath;

            if (!string.IsNullOrEmpty(exePath) && File.Exists(exePath))
            {
                try
                {
                    Process.Start("explorer.exe", $"/select, \"{exePath}\"");
                }
                catch (Exception ex)
                {
                    System.Windows.MessageBox.Show(this, "Could not open file location.\n\nError: " + ex.Message, "Error", MessageBoxButton.OK, MessageBoxImage.Error);
                }
            }
            else if (!string.IsNullOrEmpty(exePath))
            {
                System.Windows.MessageBox.Show(this, "The file path could not be found:\n\n" + exePath, "File Not Found", MessageBoxButton.OK, MessageBoxImage.Warning);
            }
        }

        private void HandleRuleEdit(IEnumerable<string> appPaths)
        {
            var distinctPaths = appPaths.Where(p => !string.IsNullOrEmpty(p)).Distinct().ToList();
            if (distinctPaths.Count == 0)
            {
                System.Windows.MessageBox.Show("Please select one or more items to edit/create.", "No Selection", MessageBoxButton.OK, MessageBoxImage.Information);
                return;
            }

            var dialog = new EditRuleWindow(distinctPaths);
            if (dialog.ShowDialog() == true)
            {
                if (DataContext is MainViewModel mainViewModel)
                {
                    mainViewModel.ApplyApplicationRuleChange(distinctPaths, dialog.SelectedAction);
                }
            }
        }

        private void HandleUwpRuleEdit(List<UwpApp> uwpApps)
        {
            if (uwpApps.Count == 0)
            {
                System.Windows.MessageBox.Show("Please select one or more UWP apps to edit/create.", "No Selection", MessageBoxButton.OK, MessageBoxImage.Information);
                return;
            }

            var appNames = uwpApps.Select(app => app.Name).ToList();
            var dialog = new EditRuleWindow(appNames);
            if (dialog.ShowDialog() == true)
            {
                if (DataContext is MainViewModel vm)
                {
                    vm.ApplyUwpRuleChange(uwpApps, dialog.SelectedAction);
                }
            }
        }

        private void AllowTempButton_Click(object sender, RoutedEventArgs e)
        {
            if (sender is System.Windows.Controls.Button btn && btn.ContextMenu != null)
            {
                btn.ContextMenu.DataContext = btn.DataContext;
                btn.ContextMenu.IsOpen = true;
            }
        }

        private void AllowTempMenuItem_Click(object sender, RoutedEventArgs e)
        {
            if (sender is System.Windows.Controls.MenuItem menuItem &&
                menuItem.DataContext is PendingConnectionViewModel pending &&
                DataContext is MainViewModel vm &&
                int.TryParse(menuItem.Tag.ToString(), out var minutes))
            {
                vm.AllowPendingConnectionTemporarily(pending, minutes);
            }
        }

        private void SortableColumnHeader_Click(object sender, RoutedEventArgs e)
        {
            if (e.OriginalSource is GridViewColumnHeader headerClicked && headerClicked.Column != null && DataContext is MainViewModel vm)
            {
                if (FindParent<System.Windows.Controls.ListView>(headerClicked) is System.Windows.Controls.ListView listView)
                {
                    var direction = headerClicked == _lastHeaderClicked && _lastDirection == ListSortDirection.Ascending
                        ? ListSortDirection.Descending
                        : ListSortDirection.Ascending;
                    if (headerClicked.Column.DisplayMemberBinding is System.Windows.Data.Binding binding)
                    {
                        vm.SortCollection(listView.Name, binding.Path.Path, direction);
                    }

                    _lastHeaderClicked = headerClicked;
                    _lastDirection = direction;
                }
            }
        }

        public static T FindParent<T>(DependencyObject child) where T : DependencyObject
        {
            DependencyObject parentObject = VisualTreeHelper.GetParent(child);
            if (parentObject == null) return null;
            return parentObject as T ?? FindParent<T>(parentObject);
        }

        private void FileMenuButton_Click(object sender, RoutedEventArgs e)
        {
            if (sender is System.Windows.Controls.Button btn && btn.ContextMenu != null)
            {
                btn.ContextMenu.PlacementTarget = btn;
                btn.ContextMenu.Placement = PlacementMode.Bottom;
                btn.ContextMenu.IsOpen = true;
            }
        }

        private async void MainTabControl_SelectionChanged(object sender, SelectionChangedEventArgs e)
        {
            if (e.Source is System.Windows.Controls.TabControl tabControl && tabControl.SelectedItem is TabItem selectedTab)
            {
                if (DataContext is MainViewModel vm)
                {
                    string header = selectedTab.Header?.ToString();
                    if (header == "UWP Apps")
                    {
                        await vm.LoadUwpAppsOnDemandAsync();
                    }
                    else if (header == "Foreign Rules")
                    {
                        await vm.LoadForeignRulesOnDemandAsync();
                    }
                    else if (header == "Wildcard Rules")
                    {
                        vm.SyncWildcardRules(true);
                    }
                }
            }
        }

        private async void RescanForeignRules_Click(object sender, RoutedEventArgs e)
        {
            if (DataContext is MainViewModel vm)
            {
                await vm.RescanForeignRulesAsync();
            }
        }

        private void ListView_ContextMenuOpening(object sender, ContextMenuEventArgs e)
        {
            if (e.OriginalSource is DependencyObject source)
            {
                var item = FindParent<System.Windows.Controls.ListViewItem>(source);
                if (item == null)
                {
                    e.Handled = true;
                }
            }
        }

        private void TitleBar_MouseLeftButtonDown(object sender, System.Windows.Input.MouseButtonEventArgs e)
        {
            if (e.ClickCount == 2)
            {
                MaximizeButton_Click(sender, e);
            }
            else
            {
                DragMove();
            }
        }

        private void MinimizeButton_Click(object sender, RoutedEventArgs e)
        {
            this.WindowState = WindowState.Minimized;
        }

        private void MaximizeButton_Click(object sender, RoutedEventArgs e)
        {
            this.WindowState = (this.WindowState == WindowState.Maximized) ? WindowState.Normal : WindowState.Maximized;
        }

        private void CloseButton_Click(object sender, RoutedEventArgs e)
        {
            this.Close();
        }

        private void SupportButton_Click(object sender, RoutedEventArgs e)
        {
            try
            {
                Process.Start("https://coff.ee/deminimis");
            }
            catch (Exception ex)
            {
                System.Windows.MessageBox.Show("Could not open the link.\n\nError: " + ex.Message, "Error", MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }
    }
}

--------------------------------------------------------------------------------
// File: MainViewModel.cs
--------------------------------------------------------------------------------
ï»¿using NetFwTypeLib;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;

namespace MinimalFirewall
{
    public class MainViewModel : INotifyPropertyChanged, IDisposable
    {
        public ObservableCollection<FirewallRuleViewModel> ProgramRules { get; private set; }
        public ObservableCollection<FirewallRuleViewModel> Services { get; private set; }
        public ObservableCollection<UwpApp> UwpApps { get; private set; }
        public ObservableCollection<ProgramViewModel> UndefinedPrograms { get; private set; }
        public ObservableCollection<AdvancedRuleViewModel> AdvancedRules { get; private set; }
        public ObservableCollection<PendingConnectionViewModel> PendingConnections { get; private set; }
        public ObservableCollection<WildcardRule> WildcardRules { get; private set; }
        public ObservableCollection<AdvancedRuleViewModel> ForeignRules { get; private set; }

        private readonly FirewallDataService _dataService;
        private readonly FirewallActionsService _actionsService;
        private readonly FirewallEventListenerService _eventListenerService;
        private readonly FirewallRuleService _firewallService;
        private readonly UserActivityLogger _activityLogger;
        private readonly WildcardRuleService _wildcardRuleService;
        private readonly StartupService _startupService;
        private readonly AppSettings _appSettings;
        private readonly ForeignRuleTracker _foreignRuleTracker;
        private int _lastTemporaryMinutes = 5;
        private bool _uwpScanPerformed = false;
        private bool _foreignRulesLoaded = false;

        public bool IsCacheCleared { get; private set; } = false;

        public string VersionInfo { get; }

        public static IEnumerable<SearchMode> SearchModes => Enum.GetValues(typeof(SearchMode)).Cast<SearchMode>();
        private string _searchText = string.Empty;
        public string SearchText
        {
            get => _searchText;
            set { _searchText = value; OnPropertyChanged("SearchText"); FilterAllCollections(); }
        }

        private SearchMode _currentSearchMode = SearchMode.Name;
        public SearchMode CurrentSearchMode
        {
            get => _currentSearchMode;
            set { _currentSearchMode = value; OnPropertyChanged("CurrentSearchMode"); FilterAllCollections(); }
        }

        private bool _isLockedDown;
        public bool IsLockedDown
        {
            get => _isLockedDown;
            set { _isLockedDown = value; OnPropertyChanged("IsLockedDown"); OnPropertyChanged("FirewallStatus"); }
        }

        public string FirewallStatus => IsLockedDown ? "Status: Locked Down" : "Status: Unlocked";

        public bool ShowSystemRules
        {
            get => _appSettings.ShowSystemRules;
            set
            {
                if (_appSettings.ShowSystemRules == value) return;
                _appSettings.ShowSystemRules = value;
                _dataService.ShowSystemRules = value;
                OnPropertyChanged("ShowSystemRules");
                _appSettings.Save();
                FastRefresh();
            }
        }

        public bool IsPopupsEnabled
        {
            get => _appSettings.IsPopupsEnabled;
            set
            {
                if (_appSettings.IsPopupsEnabled == value) return;
                _appSettings.IsPopupsEnabled = value;
                OnPropertyChanged("IsPopupsEnabled");
                _appSettings.Save();
            }
        }

        public bool IsLoggingEnabled
        {
            get => _appSettings.IsLoggingEnabled;
            set
            {
                if (_appSettings.IsLoggingEnabled == value) return;
                _appSettings.IsLoggingEnabled = value;
                _activityLogger.IsEnabled = value;
                OnPropertyChanged("IsLoggingEnabled");
                _appSettings.Save();
                if (value) _activityLogger.Log("Event Logging", "Enabled");
            }
        }

        public bool IsDarkModeEnabled
        {
            get => _appSettings.Theme == "Dark";
            set
            {
                string newTheme = value ? "Dark" : "Light";
                if (_appSettings.Theme == newTheme) return;

                _appSettings.Theme = newTheme;
                OnPropertyChanged("IsDarkModeEnabled");
                _appSettings.Save();
                (Application.Current as App)?.ApplyTheme(newTheme);
            }
        }

        public bool IsStartupEnabled
        {
            get => _appSettings.StartOnSystemStartup;
            set
            {
                if (_appSettings.StartOnSystemStartup == value) return;
                _appSettings.StartOnSystemStartup = value;
                _startupService.SetStartup(value);
                OnPropertyChanged("IsStartupEnabled");
                _appSettings.Save();
            }
        }

        public bool IsCloseToTrayEnabled
        {
            get => _appSettings.CloseToTray;
            set
            {
                if (_appSettings.CloseToTray == value) return;
                _appSettings.CloseToTray = value;
                OnPropertyChanged("IsCloseToTrayEnabled");
                _appSettings.Save();
            }
        }

        public ICommand ToggleLockdownCommand { get; private set; }
        public ICommand AllowPendingCommand { get; private set; }
        public ICommand BlockPendingCommand { get; private set; }
        public ICommand IgnorePendingCommand { get; private set; }
        public ICommand RemoveWildcardRuleCommand { get; private set; }
        public ICommand AcknowledgeForeignRulesCommand { get; private set; }
        public ICommand CreateWildcardFromTabCommand { get; private set; }
        public ICommand CheckForUpdatesCommand { get; private set; }
        public ICommand ScanDirectoryCommand { get; private set; }
        public ICommand ClearUndefinedProgramsCommand { get; private set; }
        public ICommand RefreshCommand { get; private set; }

        public MainViewModel()
        {
            _appSettings = AppSettings.Load();
            if (Application.Current is App app)
            {
                app.ApplyTheme(_appSettings.Theme);
            }

            VersionInfo = "Version " + Assembly.GetExecutingAssembly().GetName().Version.ToString(3);

            ProgramRules = new ObservableCollection<FirewallRuleViewModel>();
            Services = new ObservableCollection<FirewallRuleViewModel>();
            UwpApps = new ObservableCollection<UwpApp>();
            UndefinedPrograms = new ObservableCollection<ProgramViewModel>();
            AdvancedRules = new ObservableCollection<AdvancedRuleViewModel>();
            PendingConnections = new ObservableCollection<PendingConnectionViewModel>();
            WildcardRules = new ObservableCollection<WildcardRule>();
            ForeignRules = new ObservableCollection<AdvancedRuleViewModel>();

            _firewallService = new FirewallRuleService();
            _activityLogger = new UserActivityLogger { IsEnabled = _appSettings.IsLoggingEnabled };
            var uwpService = new UwpService();
            _wildcardRuleService = new WildcardRuleService();
            _startupService = new StartupService();
            _foreignRuleTracker = new ForeignRuleTracker();
            _dataService = new FirewallDataService(_firewallService, uwpService, _activityLogger) { ShowSystemRules = _appSettings.ShowSystemRules };
            _actionsService = new FirewallActionsService(_firewallService, _dataService, _activityLogger);
            _eventListenerService = new FirewallEventListenerService(_dataService, _wildcardRuleService, _actionsService, () => IsLockedDown);

            ToggleLockdownCommand = new RelayCommand(new Action(ToggleLockdown));
            AllowPendingCommand = new RelayCommand<PendingConnectionViewModel>(AllowPendingConnection);
            BlockPendingCommand = new RelayCommand<PendingConnectionViewModel>(BlockPendingConnection);
            AcknowledgeForeignRulesCommand = new RelayCommand(AcknowledgeForeignRules);
            IgnorePendingCommand = new RelayCommand<PendingConnectionViewModel>(IgnorePendingConnection);
            RemoveWildcardRuleCommand = new RelayCommand<WildcardRule>(RemoveWildcardRule);
            CreateWildcardFromTabCommand = new RelayCommand(() => HandleWildcardCreationRequest(null));
            CheckForUpdatesCommand = new RelayCommand(CheckForUpdates);
            ScanDirectoryCommand = new RelayCommand(() => _ = ScanDirectoryForUndefined());
            ClearUndefinedProgramsCommand = new RelayCommand(ClearUndefinedPrograms);
            RefreshCommand = new RelayCommand(SlowRefresh);

            _eventListenerService.PendingConnectionDetected += OnPendingConnectionDetected;
            _actionsService.ApplicationRuleSetExpired += OnApplicationRuleSetExpired;
        }

        private void ClearUndefinedPrograms()
        {
            _dataService.ClearUndefinedPrograms();
            UndefinedPrograms.Clear();
        }

        private void CheckForUpdates()
        {
            try
            {
                Process.Start("https://github.com/deminimis/minimalfirewall/releases");
            }
            catch (Exception ex)
            {
                MessageBox.Show("Could not open the link.\n\nError: " + ex.Message, "Error", MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }

        public async Task InitializeAsync()
        {
            var statusWindow = new StatusWindow("Loading Firewall Rules...");
            Application.Current.Dispatcher.Invoke(new Action(statusWindow.Show));

            await Task.Run(() =>
            {
                _dataService.LoadUwpAppsFromCache();
                _dataService.LoadInitialData();
            });

            await Task.Run(() => SyncWildcardRules(false));

            Application.Current.Dispatcher.Invoke(() =>
            {
                UpdateCollectionsFromSource();
                WildcardRules = new ObservableCollection<WildcardRule>(_wildcardRuleService.GetRules());
                OnPropertyChanged("WildcardRules");
                FilterAllCollections();
            });

            CheckFirewallStatus();
            _eventListenerService.Start();
            _activityLogger.Log("Application Started", "Version " + System.Reflection.Assembly.GetExecutingAssembly().GetName().Version);

            IsCacheCleared = false;
            Application.Current.Dispatcher.Invoke(new Action(statusWindow.Close));
        }

        public void SyncWildcardRules(bool shouldRefreshUI)
        {
            var allWildcards = _wildcardRuleService.GetRules();
            if (!allWildcards.Any()) return;

            var allSystemRules = _firewallService.GetAllRules();

            foreach (var wildcard in allWildcards)
            {
                var executablesInFolder = SystemDiscoveryService.GetExecutablesInFolder(wildcard.FolderPath, wildcard.ExeName);
                if (!executablesInFolder.Any()) continue;

                string descriptionTag = $"{MFWConstants.WildcardDescriptionPrefix}{wildcard.FolderPath}]";
                var existingRulePaths = allSystemRules
                    .Where(r => r.Description != null && r.Description == descriptionTag)
                    .Select(r => r.ApplicationName)
                    .ToHashSet(StringComparer.OrdinalIgnoreCase);

                var missingExePaths = executablesInFolder.Where(exe => !existingRulePaths.Contains(exe)).ToList();

                if (missingExePaths.Any())
                {
                    _actionsService.ApplyApplicationRuleChange(missingExePaths, wildcard.Action, wildcard.FolderPath);
                }
            }
            if (shouldRefreshUI)
            {
                FastRefresh();
            }
        }

        private void UpdateCollectionsFromSource()
        {
            PopulateCollectionFromSource(ProgramRules, _dataService.AllProgramRules);
            PopulateCollectionFromSource(Services, _dataService.AllServiceRules);
            PopulateCollectionFromSource(UwpApps, _dataService.AllUwpApps);
            PopulateCollectionFromSource(UndefinedPrograms, _dataService.AllUndefinedPrograms);
            PopulateCollectionFromSource(AdvancedRules, _dataService.AllAdvancedRules);
            PopulateCollectionFromSource(ForeignRules, _dataService.AllForeignRules);
        }

        private void FastRefresh()
        {
            Application.Current.Dispatcher.Invoke(() =>
            {
                _dataService.ApplyFilters();
                UpdateCollectionsFromSource();
                FilterAllCollections();
            });
        }

        public async void SlowRefresh()
        {
            var statusWindow = new StatusWindow("Reloading Rules...");
            Application.Current.Dispatcher.Invoke(new Action(statusWindow.Show));
            await Task.Run(() => {
                _dataService.LoadInitialData();
                SyncWildcardRules(false);
            });

            Application.Current.Dispatcher.Invoke(() =>
            {
                UpdateCollectionsFromSource();
                FilterAllCollections();
                IsCacheCleared = false;
            });

            Application.Current.Dispatcher.Invoke(new Action(statusWindow.Close));
        }

        private void OnPendingConnectionDetected(PendingConnectionViewModel pending)
        {
            Application.Current.Dispatcher.Invoke(new Action(() =>
            {
                if (PendingConnections.Any(p => p.AppPath.Equals(pending.AppPath, StringComparison.OrdinalIgnoreCase) && p.Direction == pending.Direction && p.ServiceName == pending.ServiceName)) return;
                PendingConnections.Add(pending);
                _activityLogger.Log("Pending Connection", pending.Direction + " for " + pending.AppPath);
                if (IsPopupsEnabled) { ShowConnectionNotifier(pending); }
            }));
        }

        private void OnApplicationRuleSetExpired(string appPath)
        {
            Application.Current.Dispatcher.Invoke(() =>
            {
                _dataService.AddOrUpdateAppRule(appPath);
                FastRefresh();
            });
        }

        public async Task LoadUwpAppsOnDemandAsync()
        {
            if (_uwpScanPerformed) return;
            var statusWindow = new StatusWindow("Scanning for UWP Apps");
            Application.Current.Dispatcher.Invoke(new Action(statusWindow.Show));
            var count = await _dataService.ScanForUwpAppsAsync();
            UpdateCollectionsFromSource();
            FilterAllCollections();
            _uwpScanPerformed = true;
            Application.Current.Dispatcher.Invoke(new Action(() => statusWindow.Complete("Found " + count + " UWP apps.")));
        }

        public async Task LoadForeignRulesOnDemandAsync()
        {
            if (_foreignRulesLoaded)
            {
                return;
            }
            _foreignRulesLoaded = true;
            await RescanForeignRulesAsync();
        }

        public async Task RescanForeignRulesAsync()
        {
            var statusWindow = new StatusWindow("Scanning for new third-party rules...");
            Application.Current.Dispatcher.Invoke(() => statusWindow.Show());

            await Task.Run(() => _dataService.ScanForForeignRules(_foreignRuleTracker));

            UpdateCollectionsFromSource();
            FilterAllCollections();

            Application.Current.Dispatcher.Invoke(() => statusWindow.Close());
        }

        private void AcknowledgeForeignRules()
        {
            var ruleNamesToAcknowledge = ForeignRules.Select(r => r.Name).ToList();
            if (ruleNamesToAcknowledge.Count == 0)
            {
                MessageBox.Show("There are no new foreign rules to acknowledge.", "No New Rules", MessageBoxButton.OK, MessageBoxImage.Information);
                return;
            }

            var result = MessageBox.Show($"Are you sure you want to acknowledge {ruleNamesToAcknowledge.Count} new rule(s)?\n\nThey will be hidden from this list unless they are modified.", "Confirm Acknowledgment", MessageBoxButton.YesNo, MessageBoxImage.Question);

            if (result == MessageBoxResult.Yes)
            {
                _foreignRuleTracker.AcknowledgeRules(ruleNamesToAcknowledge);
                ForeignRules.Clear();
                _activityLogger.Log("Foreign Rules", $"Acknowledged {ruleNamesToAcknowledge.Count} rule(s).");
            }
        }

        public async Task ScanDirectoryForUndefined()
        {
            if (FolderPicker.TryPickFolder(out var folderPath) && folderPath != null)
            {
                var statusWindow = new StatusWindow("Scanning Directory");
                Application.Current.Dispatcher.Invoke(new Action(statusWindow.Show));
                var count = await _dataService.ScanDirectoryForUndefined(folderPath);
                UpdateCollectionsFromSource();
                FilterAllCollections();
                Application.Current.Dispatcher.Invoke(new Action(() => statusWindow.Complete("Found " + count + " new executable(s).")));
            }
        }

        public void ClearCachesForTray()
        {
            _dataService.ClearDataCaches();

            ProgramRules.Clear();
            Services.Clear();
            UwpApps.Clear();
            UndefinedPrograms.Clear();
            AdvancedRules.Clear();
            ForeignRules.Clear();

            _uwpScanPerformed = false;
            _foreignRulesLoaded = false;
            IsCacheCleared = true;
        }

        public void CreateWildcardRule(string folderPath, string exeName, string action)
        {
            var executables = SystemDiscoveryService.GetExecutablesInFolder(folderPath, exeName);
            if (!executables.Any())
            {
                if (!exeName.Equals("svchost.exe", StringComparison.OrdinalIgnoreCase))
                {
                    MessageBox.Show("No executable files matching the criteria were found in the selected folder.", "No Files Found", MessageBoxButton.OK, MessageBoxImage.Information);
                }
                return;
            }

            var newRule = new WildcardRule { FolderPath = folderPath, ExeName = exeName, Action = action };
            _wildcardRuleService.AddRule(newRule);
            if (!WildcardRules.Any(r => r.FolderPath == newRule.FolderPath && r.ExeName == newRule.ExeName))
            {
                WildcardRules.Add(newRule);
            }
            _activityLogger.Log("Wildcard Rule Created", $"{action} for {exeName ?? "*.exe"} in folder {folderPath}");

            _actionsService.ApplyApplicationRuleChange(executables, action, folderPath);
            FastRefresh();
        }

        public void HandleWildcardCreationRequest(string initialPath, PendingConnectionViewModel pendingToRemove = null)
        {
            var dialog = new WildcardCreatorWindow();
            if (!string.IsNullOrEmpty(initialPath))
            {
                dialog.FolderPathTextBox.Text = initialPath;
            }

            if (dialog.ShowDialog() == true)
            {
                CreateWildcardRule(dialog.FolderPath, dialog.ExeName, dialog.SelectedAction);
                if (pendingToRemove != null)
                {
                    PendingConnections.Remove(pendingToRemove);
                }
            }
        }

        public void ApplyApplicationRuleChange(List<string> appPaths, string action) { _actionsService.ApplyApplicationRuleChange(appPaths, action); FastRefresh(); }
        public void ApplyUwpRuleChange(List<UwpApp> uwpApps, string action) { _actionsService.ApplyUwpRuleChange(uwpApps, action); SlowRefresh(); }

        public void DeleteApplicationRules(List<string> appPaths)
        {
            _actionsService.DeleteApplicationRules(appPaths);
            _eventListenerService.ClearAllSnoozes();
            FastRefresh();
        }

        public void DeleteUwpRules(List<string> packageFamilyNames) { _actionsService.DeleteUwpRules(packageFamilyNames); SlowRefresh(); }
        public void DeleteAdvancedRules(List<string> ruleNames) { _actionsService.DeleteAdvancedRules(ruleNames); FastRefresh(); }
        public void CreatePowerShellRule(string command) { _actionsService.CreatePowerShellRule(command); SlowRefresh(); }
        private void ToggleLockdown() { _actionsService.ToggleLockdown(); CheckFirewallStatus(); }

        private void RemoveWildcardRule(WildcardRule rule)
        {
            if (rule == null) return;
            var result = MessageBox.Show($"This will delete the wildcard rule and all firewall rules created by it for the folder:\n\n{rule.FolderPath}\n\nAre you sure you want to continue?", "Confirm Wildcard Deletion", MessageBoxButton.YesNo, MessageBoxImage.Warning);
            if (result == MessageBoxResult.No) return;

            _actionsService.DeleteRulesForWildcard(rule);
            _wildcardRuleService.RemoveRule(rule);
            WildcardRules.Remove(rule);
            _eventListenerService.ClearAllSnoozes();
            _activityLogger.Log("Wildcard Rule Removed", rule.FolderPath);
            FastRefresh();
        }

        private void AllowPendingConnection(PendingConnectionViewModel pending)
        {
            if (pending == null) return;

            string action = "Allow (" + pending.Direction + ")";
            if (!string.IsNullOrEmpty(pending.ServiceName))
            {
                var services = pending.ServiceName.Split(new[] { ',', ' ' }, StringSplitOptions.RemoveEmptyEntries);
                foreach (var service in services)
                {
                    _actionsService.ApplyServiceRuleChange(service, action);
                }
            }
            else
            {
                _actionsService.ApplyApplicationRuleChange(new List<string> { pending.AppPath }, action);
            }
            PendingConnections.Remove(pending);
        }

        private void BlockPendingConnection(PendingConnectionViewModel pending)
        {
            if (pending == null) return;

            string action = "Block (" + pending.Direction + ")";
            if (!string.IsNullOrEmpty(pending.ServiceName))
            {
                var services = pending.ServiceName.Split(new[] { ',', ' ' }, StringSplitOptions.RemoveEmptyEntries);
                foreach (var service in services)
                {
                    _actionsService.ApplyServiceRuleChange(service, action);
                }
            }
            else
            {
                _actionsService.ApplyApplicationRuleChange(new List<string> { pending.AppPath }, action);
            }
            PendingConnections.Remove(pending);
        }

        private void IgnorePendingConnection(PendingConnectionViewModel pending)
        {
            if (pending == null) return;
            _eventListenerService.SnoozeNotificationsForApp(pending.AppPath, 2);
            PendingConnections.Remove(pending);
            _activityLogger.Log("Ignored Connection", pending.Direction + " for " + pending.AppPath);
        }

        public void AllowPendingConnectionTemporarily(PendingConnectionViewModel pending, int minutes)
        {
            if (pending == null) return;
            _actionsService.AllowPendingConnectionTemporarily(pending, minutes);
            PendingConnections.Remove(pending);
            FastRefresh();
        }

        private void ShowConnectionNotifier(PendingConnectionViewModel pendingVm)
        {
            var dialog = new ConnectionNotifierWindow(pendingVm, _lastTemporaryMinutes);
            if (dialog.ShowDialog() != true)
            {
                IgnorePendingConnection(pendingVm);
                return;
            }

            _lastTemporaryMinutes = dialog.Minutes;

            switch (dialog.Result)
            {
                case ConnectionNotifierWindow.NotifierResult.Allow:
                    AllowPendingConnection(pendingVm);
                    break;
                case ConnectionNotifierWindow.NotifierResult.Block:
                    BlockPendingConnection(pendingVm);
                    break;
                case ConnectionNotifierWindow.NotifierResult.AllowTemporary:
                    AllowPendingConnectionTemporarily(pendingVm, dialog.Minutes);
                    break;
                case ConnectionNotifierWindow.NotifierResult.CreateWildcard:
                    HandleWildcardCreationRequest(Path.GetDirectoryName(pendingVm.AppPath), pendingVm);
                    break;
            }
        }

        private void CheckFirewallStatus() => IsLockedDown = _firewallService.GetDefaultOutboundAction() == NET_FW_ACTION_.NET_FW_ACTION_BLOCK;

        private void FilterAllCollections()
        {
            bool namePredicate(string text) { return text != null && text.IndexOf(_searchText, StringComparison.OrdinalIgnoreCase) >= 0; }
            bool pathPredicate(string text) { return text != null && text.IndexOf(_searchText, StringComparison.OrdinalIgnoreCase) >= 0; }

            PopulateCollectionFromSource(ProgramRules, _dataService.AllProgramRules, r => CurrentSearchMode == SearchMode.Name ? namePredicate(r.Name) : pathPredicate(r.ApplicationName));
            PopulateCollectionFromSource(Services, _dataService.AllServiceRules, r => CurrentSearchMode == SearchMode.Name ? namePredicate(r.Name) : pathPredicate(r.ApplicationName));
            PopulateCollectionFromSource(UwpApps, _dataService.AllUwpApps, u => CurrentSearchMode == SearchMode.Name ? namePredicate(u.Name) : pathPredicate(u.PackageFamilyName));
            PopulateCollectionFromSource(UndefinedPrograms, _dataService.AllUndefinedPrograms, p => CurrentSearchMode == SearchMode.Name ? namePredicate(p.Name) : pathPredicate(p.ExePath));
            PopulateCollectionFromSource(AdvancedRules, _dataService.AllAdvancedRules, r => namePredicate(r.Name) || namePredicate(r.Description));
            PopulateCollectionFromSource(ForeignRules, _dataService.AllForeignRules, r => namePredicate(r.Name) || namePredicate(r.Description));
        }

        private void PopulateCollectionFromSource<T>(ObservableCollection<T> target, IReadOnlyList<T> source, Func<T, bool> filter = null)
        {
            if (target == null || source == null) return;
            target.Clear();
            var results = (filter == null || string.IsNullOrEmpty(_searchText)) ? source : source.Where(filter);
            foreach (var item in results)
            {
                target.Add(item);
            }
        }

        public void SortCollection(string listViewName, string propertyName, ListSortDirection direction)
        {
            IList collection;
            switch (listViewName)
            {
                case "ProgramsListView": collection = ProgramRules; break;
                case "ServicesListView": collection = Services; break;
                case "AdvancedRulesListView": collection = AdvancedRules; break;
                case "UndefinedProgramsListView": collection = UndefinedPrograms; break;
                case "PendingConnectionsListView": collection = PendingConnections; break;
                case "UwpAppsListView": collection = UwpApps; break;
                case "WildcardRulesListView": collection = WildcardRules; break;
                case "ForeignRulesListView": collection = ForeignRules; break;
                default: return;
            }

            if (collection == null || collection.Count == 0) return;
            var propertyInfo = collection.GetType().GetGenericArguments()[0].GetProperty(propertyName);
            if (propertyInfo == null) return;

            var sortedList = new List<object>();
            if (direction == ListSortDirection.Ascending)
            {
                sortedList.AddRange(collection.Cast<object>().OrderBy(item => propertyInfo.GetValue(item, null)));
            }
            else
            {
                sortedList.AddRange(collection.Cast<object>().OrderByDescending(item => propertyInfo.GetValue(item, null)));
            }

            collection.Clear();
            foreach (var item in sortedList)
            {
                collection.Add(item);
            }
        }

        public void Dispose()
        {
            _eventListenerService?.Dispose();
            GC.SuppressFinalize(this);
        }

        public event PropertyChangedEventHandler PropertyChanged;
        protected void OnPropertyChanged(string propertyName)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }
    }
}

--------------------------------------------------------------------------------
// File: FirewallDataService.cs
--------------------------------------------------------------------------------
ï»¿using NetFwTypeLib;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Threading.Tasks;

namespace MinimalFirewall
{
    public class FirewallDataService
    {
        private readonly FirewallRuleService _firewallService;
        private readonly UwpService _uwpService;
        private readonly UserActivityLogger _activityLogger;

        private readonly List<FirewallRuleViewModel> _masterProgramRules = new List<FirewallRuleViewModel>();
        private readonly List<FirewallRuleViewModel> _masterServiceRules = new List<FirewallRuleViewModel>();
        private readonly List<AdvancedRuleViewModel> _masterAdvancedRules = new List<AdvancedRuleViewModel>();
        private readonly List<AdvancedRuleViewModel> _masterForeignRules = new List<AdvancedRuleViewModel>();
        private readonly List<FirewallRuleViewModel> _filteredProgramRules = new List<FirewallRuleViewModel>();
        private readonly List<FirewallRuleViewModel> _filteredServiceRules = new List<FirewallRuleViewModel>();
        private readonly List<ProgramViewModel> _allUndefinedPrograms = new List<ProgramViewModel>();
        private readonly List<AdvancedRuleViewModel> _filteredAdvancedRules = new List<AdvancedRuleViewModel>();
        private readonly List<UwpApp> _allUwpApps = new List<UwpApp>();

        private readonly object _uwpLock = new object();

        public IReadOnlyList<FirewallRuleViewModel> AllProgramRules => _filteredProgramRules;
        public IReadOnlyList<FirewallRuleViewModel> AllServiceRules => _filteredServiceRules;
        public IReadOnlyList<ProgramViewModel> AllUndefinedPrograms => _allUndefinedPrograms;
        public IReadOnlyList<AdvancedRuleViewModel> AllAdvancedRules => _filteredAdvancedRules;
        public IReadOnlyList<AdvancedRuleViewModel> AllForeignRules => _masterForeignRules;
        public IReadOnlyList<UwpApp> AllUwpApps => _allUwpApps;
        public bool ShowSystemRules { get; set; }

        public FirewallDataService(FirewallRuleService firewallService, UwpService uwpService, UserActivityLogger activityLogger)
        {
            _firewallService = firewallService;
            _uwpService = uwpService;
            _activityLogger = activityLogger;
            ShowSystemRules = true;
        }

        public void ScanForForeignRules(ForeignRuleTracker tracker)
        {
            _masterForeignRules.Clear();
            var allRules = _firewallService.GetAllRules();

            var foreignRules = allRules.Where(r => r != null && (string.IsNullOrEmpty(r.Grouping) || !r.Grouping.StartsWith(MFWConstants.MainRuleGroup, StringComparison.OrdinalIgnoreCase)));

            foreach (var rule in foreignRules)
            {
                if (!tracker.IsAcknowledged(rule.Name))
                {
                    _masterForeignRules.Add(CreateAdvancedRuleViewModel(rule));
                }
            }
        }

        public void LoadInitialData()
        {
            _masterProgramRules.Clear();
            _masterServiceRules.Clear();
            _masterAdvancedRules.Clear();

            var allServices = SystemDiscoveryService.GetServicesWithExePaths();
            var allRules = _firewallService.GetAllRules();

            var rulesByAppPath = allRules
                .Where(r => !string.IsNullOrEmpty(r.ApplicationName))
                .GroupBy(r => r.ApplicationName, StringComparer.OrdinalIgnoreCase)
                .ToDictionary(g => g.Key, g => g.ToList());

            var rulesByServiceName = allRules
                .Where(r => !string.IsNullOrEmpty(r.serviceName))
                .GroupBy(r => r.serviceName, StringComparer.OrdinalIgnoreCase)
                .ToDictionary(g => g.Key, g => g.ToList());

            var allServicePaths = new HashSet<string>(allServices.Select(s => s.ExePath), StringComparer.OrdinalIgnoreCase);

            foreach (var service in allServices)
            {
                var relevantRules = new List<INetFwRule2>();

                if (rulesByServiceName.TryGetValue(service.ServiceName, out var serviceRules))
                {
                    relevantRules.AddRange(serviceRules);
                }

                if (rulesByAppPath.TryGetValue(service.ExePath, out var appRules))
                {
                    relevantRules.AddRange(appRules);
                }

                var status = relevantRules.Any() ? GetRuleStatusForGroup(relevantRules.Distinct()) : "Undefined";
                var displayName = string.IsNullOrEmpty(service.DisplayName) ? service.ServiceName : service.DisplayName;

                _masterServiceRules.Add(new FirewallRuleViewModel
                {
                    Name = displayName,
                    ApplicationName = service.ExePath,
                    Status = status
                });
            }

            foreach (var appGroup in rulesByAppPath)
            {
                if (!allServicePaths.Contains(appGroup.Key))
                {
                    if (appGroup.Value.All(r => r.Grouping != MFWConstants.WildcardRuleGroup))
                    {
                        _masterProgramRules.Add(new FirewallRuleViewModel
                        {
                            Name = Path.GetFileNameWithoutExtension(appGroup.Key),
                            ApplicationName = appGroup.Key,
                            Status = GetRuleStatusForGroup(appGroup.Value)
                        });
                    }
                }
            }

            var nonAppRules = allRules.Where(r => string.IsNullOrEmpty(r.ApplicationName) && string.IsNullOrEmpty(r.serviceName));
            foreach (var rule in nonAppRules)
            {
                if (!string.IsNullOrEmpty(rule.Description) && rule.Description.StartsWith(MFWConstants.UwpDescriptionPrefix, StringComparison.Ordinal))
                    continue;

                _masterAdvancedRules.Add(CreateAdvancedRuleViewModel(rule));
            }

            UpdateUwpAppStatuses(allRules);
            ApplyFilters();
        }

        public void ApplyFilters()
        {
            string windowsFolderPath = Environment.GetFolderPath(Environment.SpecialFolder.Windows);
            bool shouldFilter(string path) => !ShowSystemRules && !string.IsNullOrEmpty(path) && path.StartsWith(windowsFolderPath, StringComparison.OrdinalIgnoreCase);

            _filteredProgramRules.Clear();
            _filteredProgramRules.AddRange(_masterProgramRules.Where(r => !shouldFilter(r.ApplicationName)));

            _filteredServiceRules.Clear();
            _filteredServiceRules.AddRange(_masterServiceRules.Where(r => !shouldFilter(r.ApplicationName)));

            _filteredAdvancedRules.Clear();
            _filteredAdvancedRules.AddRange(_masterAdvancedRules.Where(r => ShowSystemRules || (r.Grouping != null && r.Grouping.StartsWith(MFWConstants.MainRuleGroup))));
        }

        public void AddOrUpdateAppRule(string _appPath)
        {
            LoadInitialData();
        }

        public void ClearUndefinedPrograms()
        {
            _allUndefinedPrograms.Clear();
        }

        public void RemoveRulesByPath(List<string> appPaths)
        {
            var pathSet = new HashSet<string>(appPaths, StringComparer.OrdinalIgnoreCase);
            _masterProgramRules.RemoveAll(r => pathSet.Contains(r.ApplicationName));
            _masterServiceRules.RemoveAll(r => pathSet.Contains(r.ApplicationName));
        }

        public void RemoveAdvancedRulesByName(List<string> ruleNames)
        {
            var nameSet = new HashSet<string>(ruleNames, StringComparer.OrdinalIgnoreCase);
            _masterAdvancedRules.RemoveAll(r => nameSet.Contains(r.Name));
            ApplyFilters();
        }

        public bool DoesServiceRuleExist(string serviceName, string direction)
        {
            var allServices = SystemDiscoveryService.GetServicesWithExePaths();
            var targetService = allServices.FirstOrDefault(s => s.ServiceName.Equals(serviceName, StringComparison.OrdinalIgnoreCase));
            if (targetService == null) return false;

            var displayName = string.IsNullOrEmpty(targetService.DisplayName) ? targetService.ServiceName : targetService.DisplayName;
            var rule = _masterServiceRules.FirstOrDefault(r => r.Name.Equals(displayName, StringComparison.OrdinalIgnoreCase));
            return DoesRuleMatchDirection(rule, direction);
        }

        public bool DoesRuleExist(string appPath, string direction, string serviceName)
        {
            if (!string.IsNullOrEmpty(serviceName))
            {
                var services = serviceName.Split(new[] { ',', ' ' }, StringSplitOptions.RemoveEmptyEntries);
                foreach (var service in services)
                {
                    if (DoesServiceRuleExist(service, direction))
                    {
                        return true;
                    }
                }
            }

            var rule = _masterProgramRules.FirstOrDefault(r => r.ApplicationName.Equals(appPath, StringComparison.OrdinalIgnoreCase)) ??
                       _masterServiceRules.FirstOrDefault(r => r.ApplicationName.Equals(appPath, StringComparison.OrdinalIgnoreCase));

            return DoesRuleMatchDirection(rule, direction);
        }

        private bool DoesRuleMatchDirection(FirewallRuleViewModel rule, string direction)
        {
            if (rule == null || rule.Status == "Undefined")
            {
                return false;
            }

            if (direction == "Outbound")
            {
                return rule.Status.Contains("Out") ||
                       rule.Status.Contains("(All)");
            }

            if (direction == "Inbound")
            {
                return rule.Status.Contains("In") ||
                       rule.Status.Contains("(All)");
            }

            return false;
        }

        public void LoadUwpAppsFromCache()
        {
            lock (_uwpLock)
            {
                _allUwpApps.Clear();
                _allUwpApps.AddRange(_uwpService.LoadUwpAppsFromCache());
            }
        }

        public async Task<int> ScanForUwpAppsAsync()
        {
            var apps = await _uwpService.ScanForUwpApps();
            lock (_uwpLock)
            {
                _allUwpApps.Clear();
                _allUwpApps.AddRange(apps);
                UpdateUwpAppStatuses(_firewallService.GetAllRules());
            }
            return apps.Count;
        }

        private void UpdateUwpAppStatuses(List<INetFwRule2> allRules)
        {
            var uwpRuleGroups = allRules.Where(r => r != null && !string.IsNullOrEmpty(r.Description) && r.Description.StartsWith(MFWConstants.UwpDescriptionPrefix, StringComparison.Ordinal))
                                        .GroupBy(r => r.Description.Substring(MFWConstants.UwpDescriptionPrefix.Length), StringComparer.OrdinalIgnoreCase);
            lock (_uwpLock)
            {
                foreach (var app in _allUwpApps)
                {
                    var group = uwpRuleGroups.FirstOrDefault(g => string.Equals(g.Key, app.PackageFamilyName, StringComparison.OrdinalIgnoreCase));
                    app.Status = group != null ? GetRuleStatusForGroup(group) : "Undefined";
                }
            }
        }

        public async Task<int> ScanDirectoryForUndefined(string directoryPath)
        {
            var newPrograms = await Task.Run(() =>
            {
                var existingPaths = _masterProgramRules.Select(r => r.ApplicationName)
                                   .Concat(_masterServiceRules.Select(r => r.ApplicationName))
                    .Concat(_allUndefinedPrograms.Select(p => p.ExePath))
                    .ToHashSet(StringComparer.OrdinalIgnoreCase);
                return SystemDiscoveryService.ScanDirectoryForExecutables(directoryPath, existingPaths);
            });
            foreach (var program in newPrograms)
            {
                _allUndefinedPrograms.Add(program);
            }
            _activityLogger.Log("Directory Scanned", directoryPath);
            return newPrograms.Count;
        }

        public static string GetRuleStatusForGroup(IEnumerable<INetFwRule2> group)
        {
            bool hasInAllow = group.Any(r => r.Enabled && r.Action == NET_FW_ACTION_.NET_FW_ACTION_ALLOW && r.Direction == NET_FW_RULE_DIRECTION_.NET_FW_RULE_DIR_IN);
            bool hasOutAllow = group.Any(r => r.Enabled && r.Action == NET_FW_ACTION_.NET_FW_ACTION_ALLOW && r.Direction == NET_FW_RULE_DIRECTION_.NET_FW_RULE_DIR_OUT);
            bool hasInBlock = group.Any(r => r.Enabled && r.Action == NET_FW_ACTION_.NET_FW_ACTION_BLOCK && r.Direction == NET_FW_RULE_DIRECTION_.NET_FW_RULE_DIR_IN);
            bool hasOutBlock = group.Any(r => r.Enabled && r.Action == NET_FW_ACTION_.NET_FW_ACTION_BLOCK && r.Direction == NET_FW_RULE_DIRECTION_.NET_FW_RULE_DIR_OUT);

            if (hasInBlock && hasOutBlock) return "Block (All)";
            if (hasInAllow && hasOutAllow && !hasInBlock && !hasOutBlock) return "Allow (All)";

            var outStatus = hasOutBlock ? "Block Out" : (hasOutAllow ? "Allow Out" : "");
            var inStatus = hasInBlock ? "Block In" : (hasInAllow ? "Allow In" : "");

            var parts = new[] { outStatus, inStatus }.Where(s => !string.IsNullOrEmpty(s));
            var finalStatus = string.Join(", ", parts);

            return string.IsNullOrEmpty(finalStatus) ? "Undefined" : finalStatus;
        }

        public static AdvancedRuleViewModel CreateAdvancedRuleViewModel(INetFwRule2 rule)
        {
            return new AdvancedRuleViewModel
            {
                Name = rule.Name ?? "Unnamed Rule",
                Description = rule.Description ?? "N/A",
                IsEnabled = rule.Enabled,
                Status = rule.Action == NET_FW_ACTION_.NET_FW_ACTION_ALLOW ? "Allow" : "Block",
                Direction = rule.Direction == NET_FW_RULE_DIRECTION_.NET_FW_RULE_DIR_IN ? "Inbound" : "Outbound",
                Ports = string.IsNullOrEmpty(rule.LocalPorts) || rule.LocalPorts == "*" ? "Any" : rule.LocalPorts,
                Protocol = GetProtocolString(rule.Protocol),
                ServiceName = string.IsNullOrEmpty(rule.serviceName) || rule.serviceName == "*" ? "Any" : rule.serviceName,
                RemoteAddresses = string.IsNullOrEmpty(rule.RemoteAddresses) || rule.RemoteAddresses == "*" ? "Any" : rule.RemoteAddresses,
                Profiles = GetProfileString(rule.Profiles),
                Grouping = rule.Grouping
            };
        }

        private static string GetProtocolString(int protocol)
        {
            switch (protocol)
            {
                case 1: return "ICMPv4";
                case 6: return "TCP";
                case 17: return "UDP";
                case 58: return "ICMPv6";
                case 256: return "Any";
                default: return protocol.ToString();
            }
        }

        private static string GetProfileString(int profiles)
        {
            if (profiles == (int)NET_FW_PROFILE_TYPE2_.NET_FW_PROFILE2_ALL) return "All";
            var profileNames = new List<string>();
            if ((profiles & (int)NET_FW_PROFILE_TYPE2_.NET_FW_PROFILE2_DOMAIN) != 0) profileNames.Add("Domain");
            if ((profiles & (int)NET_FW_PROFILE_TYPE2_.NET_FW_PROFILE2_PRIVATE) != 0) profileNames.Add("Private");
            if ((profiles & (int)NET_FW_PROFILE_TYPE2_.NET_FW_PROFILE2_PUBLIC) != 0) profileNames.Add("Public");
            return string.Join(", ", profileNames);
        }

        public void ClearDataCaches()
        {
            _masterProgramRules.Clear();
            _masterServiceRules.Clear();
            _masterAdvancedRules.Clear();
            _allUndefinedPrograms.Clear();
            _allUwpApps.Clear();

            _filteredProgramRules.Clear();
            _filteredServiceRules.Clear();
            _filteredAdvancedRules.Clear();
        }
    }
}

--------------------------------------------------------------------------------
// File: SystemDiscoveryService.cs
--------------------------------------------------------------------------------
ï»¿using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Management;
using System.Windows;

namespace MinimalFirewall
{
    public static class SystemDiscoveryService
    {
        private static List<ServiceViewModel> _serviceCache;
        private static bool _wmiQueryFailedMessageShown = false;

        public static List<ServiceViewModel> GetServicesWithExePaths()
        {
            if (_serviceCache != null)
            {
                return _serviceCache;
            }

            var services = new List<ServiceViewModel>();
            try
            {
                var wmiQuery = new ObjectQuery("SELECT Name, DisplayName, PathName FROM Win32_Service WHERE PathName IS NOT NULL");
                using (var searcher = new ManagementObjectSearcher(wmiQuery))
                {
                    foreach (ManagementObject service in searcher.Get().Cast<ManagementObject>())
                    {
                        string rawPath = service["PathName"]?.ToString() ?? string.Empty;
                        if (string.IsNullOrEmpty(rawPath))
                        {
                            continue;
                        }

                        string pathName = rawPath;
                        int exeIndex = rawPath.IndexOf(".exe", StringComparison.OrdinalIgnoreCase);

                        if (exeIndex > 0)
                        {
                            pathName = rawPath.Substring(0, exeIndex + 4);
                        }
                        else
                        {
                            if (rawPath.StartsWith("\""))
                            {
                                int closingQuoteIndex = rawPath.IndexOf('"', 1);
                                if (closingQuoteIndex > 0)
                                {
                                    pathName = rawPath.Substring(0, closingQuoteIndex + 1);
                                }
                            }
                            else
                            {
                                int firstSpaceIndex = rawPath.IndexOf(' ');
                                if (firstSpaceIndex > 0)
                                {
                                    pathName = rawPath.Substring(0, firstSpaceIndex);
                                }
                            }
                        }

                        pathName = pathName.Trim('"');

                        if (!string.IsNullOrEmpty(pathName))
                        {
                            services.Add(new ServiceViewModel
                            {
                                ExePath = pathName,
                                DisplayName = service["DisplayName"]?.ToString() ?? "",
                                ServiceName = service["Name"]?.ToString() ?? ""
                            });
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine("WMI Query failed: " + ex.Message);
                if (!_wmiQueryFailedMessageShown)
                {
                    MessageBox.Show(
                        "Could not query Windows Services (WMI). This may be due to security restrictions in your environment.\n\nThe 'Services' tab will be empty.",
                        "Feature Unavailable",
                        MessageBoxButton.OK,
                        MessageBoxImage.Warning);
                    _wmiQueryFailedMessageShown = true;
                }
            }

            _serviceCache = services;
            return services;
        }

        public static string GetServicesByPID(string processId)
        {
            if (string.IsNullOrEmpty(processId) || processId == "0") return string.Empty;

            try
            {
                var query = new ObjectQuery($"SELECT Name FROM Win32_Service WHERE ProcessId = {processId}");
                using (var searcher = new ManagementObjectSearcher(query))
                {
                    var serviceNames = searcher.Get().Cast<ManagementObject>()
                                               .Select(s => s["Name"]?.ToString())
                                               .Where(n => !string.IsNullOrEmpty(n));
                    return string.Join(", ", serviceNames);
                }
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"WMI Query for PID failed: {ex.Message}");
                return string.Empty;
            }
        }

        public static List<ProgramViewModel> ScanDirectoryForExecutables(string directoryPath, ICollection<string> existingRulePaths)
        {
            var programs = new List<ProgramViewModel>();
            if (!Directory.Exists(directoryPath)) return programs;

            var existingRuleSet = new HashSet<string>(existingRulePaths, StringComparer.OrdinalIgnoreCase);
            try
            {
                var exeFiles = GetExecutablesInFolder(directoryPath, "*.exe");
                foreach (var exe in exeFiles)
                {
                    if (!existingRuleSet.Contains(exe))
                    {
                        programs.Add(new ProgramViewModel { Name = Path.GetFileName(exe), ExePath = exe });
                        existingRuleSet.Add(exe);
                    }
                }
            }
            catch (Exception ex)
            {
                MessageBox.Show("An error occurred while scanning: " + ex.Message, "Scanning Error", MessageBoxButton.OK, MessageBoxImage.Error);
            }

            return programs;
        }

        public static List<string> GetExecutablesInFolder(string directoryPath, string exeName = null)
        {
            var files = new List<string>();
            string searchPattern = string.IsNullOrWhiteSpace(exeName) ? "*.exe" : exeName;
            GetExecutablesInFolderRecursive(directoryPath, searchPattern, files);
            return files;
        }

        private static void GetExecutablesInFolderRecursive(string directoryPath, string searchPattern, List<string> files)
        {
            try
            {
                files.AddRange(Directory.GetFiles(directoryPath, searchPattern));

                foreach (var directory in Directory.GetDirectories(directoryPath))
                {
                    GetExecutablesInFolderRecursive(directory, searchPattern, files);
                }
            }
            catch (UnauthorizedAccessException)
            {
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"Error scanning folder {directoryPath}: {ex.Message}");
            }
        }
    }
}

--------------------------------------------------------------------------------
// File: ConnectionNotifierWindow.xaml.cs
--------------------------------------------------------------------------------
ï»¿using System.IO;
using System.Windows;

namespace MinimalFirewall
{
    public partial class ConnectionNotifierWindow : Window
    {
        public enum NotifierResult { Ignore, Allow, Block, AllowTemporary, CreateWildcard }
        public NotifierResult Result { get; private set; }
        public int Minutes { get; set; } = 5;

        public PendingConnectionViewModel PendingConnection { get; }

        public string AppPath => PendingConnection.AppPath;
        public string Direction => PendingConnection.Direction;
        public string AppNameWithServices
        {
            get
            {
                if (!string.IsNullOrEmpty(PendingConnection.ServiceName))
                {
                    return $"{PendingConnection.FileName}; {PendingConnection.ServiceName}";
                }
                return PendingConnection.FileName;
            }
        }
        public string AllowButtonText => "Allow " + Direction;
        public string BlockButtonText => "Block " + Direction;

        public ConnectionNotifierWindow(PendingConnectionViewModel pendingVm, int defaultMinutes)
        {
            InitializeComponent();
            Owner = Application.Current.MainWindow;
            Result = NotifierResult.Ignore;
            PendingConnection = pendingVm;
            Minutes = defaultMinutes;
            DataContext = this;
        }

        private void AllowButton_Click(object sender, RoutedEventArgs e)
        {
            Result = NotifierResult.Allow;
            DialogResult = true;
        }

        private void BlockButton_Click(object sender, RoutedEventArgs e)
        {
            Result = NotifierResult.Block;
            DialogResult = true;
        }

        private void CreateWildcardButton_Click(object sender, RoutedEventArgs e)
        {
            Result = NotifierResult.CreateWildcard;
            DialogResult = true;
        }

        private void AllowTempButton_Click(object sender, RoutedEventArgs e)
        {
            if (!int.TryParse(MinutesTextBox.Text, out var minutes) || minutes <= 0)
            {
                MessageBox.Show("Please enter a valid, positive number of minutes.", "Invalid Input", MessageBoxButton.OK, MessageBoxImage.Error);
                return;
            }
            Minutes = minutes;
            Result = NotifierResult.AllowTemporary;
            DialogResult = true;
        }
    }
}

--------------------------------------------------------------------------------
// File: ConnectionNotifierWindow.xaml
--------------------------------------------------------------------------------
ï»¿<Window x:Class="MinimalFirewall.ConnectionNotifierWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
        xmlns:shell="clr-namespace:System.Windows.Shell;assembly=PresentationFramework"
        mc:Ignorable="d"
        Title="Connection Blocked" SizeToContent="WidthAndHeight" WindowStartupLocation="CenterScreen"
        ResizeMode="NoResize" ShowInTaskbar="True"
        WindowStyle="None" AllowsTransparency="True" Background="Transparent">

    <shell:WindowChrome.WindowChrome>
        <shell:WindowChrome CornerRadius="0" UseAeroCaptionButtons="False" GlassFrameThickness="0" CaptionHeight="0"/>
    </shell:WindowChrome.WindowChrome>

    <Border BorderBrush="{DynamicResource App.Border.Default}" BorderThickness="1" Background="{DynamicResource App.Window.Background}">
        <Grid Margin="20">
            <Grid.RowDefinitions>
                <RowDefinition Height="Auto"/>
                <RowDefinition Height="Auto"/>
                <RowDefinition Height="Auto"/>
                <RowDefinition Height="Auto"/>
                <RowDefinition Height="Auto"/>
                <RowDefinition Height="Auto"/>
            </Grid.RowDefinitions>

            <TextBlock Grid.Row="0" TextWrapping="Wrap" FontWeight="Bold" FontSize="14" Foreground="{DynamicResource App.Text.Default}">
                <Run Text="Minimal Firewall has blocked an "/>
                <Run Text="{Binding Direction, Mode=OneWay}" FontWeight="Bold"/>
                <Run Text=" connection."/>
            </TextBlock>

            <TextBlock Grid.Row="1" Text="{Binding AppNameWithServices, Mode=OneWay}" TextWrapping="Wrap" Margin="0,15,0,0" FontSize="16" FontWeight="Bold" Foreground="{DynamicResource App.Text.Default}" />
            <TextBlock Grid.Row="2" TextWrapping="Wrap" Margin="0,5,0,0" MaxWidth="500">
                <TextBlock.Resources>
                    <Style TargetType="Run">
                        <Setter Property="Foreground" Value="{DynamicResource App.Text.Grayed}"/>
                    </Style>
                </TextBlock.Resources>
                <Run Text="Path: "/>
                <Run Text="{Binding AppPath, Mode=OneWay}"/>
            </TextBlock>

            <StackPanel Grid.Row="3" Orientation="Horizontal" HorizontalAlignment="Center" Margin="0,20,0,0">
                <Button Content="{Binding AllowButtonText}" x:Name="AllowButton" Click="AllowButton_Click" Width="180" Height="30" Margin="5" Style="{StaticResource GreenPendingButton}"/>
                <Button Content="{Binding BlockButtonText}" x:Name="BlockButton" Click="BlockButton_Click" Width="180" Height="30" Margin="5" Style="{StaticResource RedPendingButton}"/>
            </StackPanel>

            <GroupBox Grid.Row="4" Header="Temporary Rule" Margin="0,15,0,0" Padding="10">
                <StackPanel Orientation="Horizontal">
                    <Label Content="Allow for:"/>
                    <TextBox x:Name="MinutesTextBox" Text="{Binding Minutes, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}" Width="50" VerticalAlignment="Center"/>
                    <Label Content="minutes"/>
                    <Button Content="Allow Temporarily" x:Name="AllowTempButton" Click="AllowTempButton_Click" Width="130" Margin="15,0,0,0" Style="{StaticResource YellowPendingButton}"/>
                </StackPanel>
            </GroupBox>

            <Grid Grid.Row="5" Margin="0,20,0,0">
                <Button Content="Create Wildcard Rule..." HorizontalAlignment="Left" Width="160" Height="28" Click="CreateWildcardButton_Click"/>
                <Button Content="Ignore" IsCancel="True" HorizontalAlignment="Right" Width="80" Height="28"/>
            </Grid>
        </Grid>
    </Border>
</Window>

--------------------------------------------------------------------------------
// File: FirewallEventListenerService.cs
--------------------------------------------------------------------------------
ï»¿using NetFwTypeLib;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Diagnostics.Eventing.Reader;
using System.Linq;
using System.Threading;
using System.Windows;
using System.Xml.Linq;

namespace MinimalFirewall
{
    public class FirewallEventListenerService : IDisposable
    {
        private readonly FirewallDataService _dataService;
        private readonly Func<bool> _isLockdownEnabled;
        private EventLogWatcher _eventWatcher;

        private readonly WildcardRuleService _wildcardRuleService;
        private readonly FirewallActionsService _actionsService;
        private readonly HashSet<string> _snoozedApps = new HashSet<string>();
        private readonly Dictionary<string, Timer> _snoozeTimers = new Dictionary<string, Timer>();

        public event Action<PendingConnectionViewModel> PendingConnectionDetected;
        public FirewallEventListenerService(FirewallDataService dataService, WildcardRuleService wildcardRuleService, FirewallActionsService actionsService, Func<bool> isLockdownEnabled)
        {
            _dataService = dataService;
            _wildcardRuleService = wildcardRuleService;
            _actionsService = actionsService;
            _isLockdownEnabled = isLockdownEnabled;
        }

        public void Start()
        {
            try
            {
                var query = new EventLogQuery("Security", PathType.LogName, "*[System[EventID=5157]]");
                _eventWatcher = new EventLogWatcher(query);
                _eventWatcher.EventRecordWritten += OnFirewallBlockEvent;
                _eventWatcher.Enabled = true;
            }
            catch (Exception ex)
            {
                MessageBox.Show("Could not start event listener. Make sure auditing is enabled and the app is run as Admin.\n\n" + ex.Message, "Listener Error", MessageBoxButton.OK, MessageBoxImage.Warning);
            }
        }

        private void OnFirewallBlockEvent(object sender, EventRecordWrittenEventArgs e)
        {
            try
            {
                if (e.EventRecord == null) return;
                string xmlContent = e.EventRecord.ToXml();

                string rawAppPath = GetValueFromXml(xmlContent, "Application");
                string appPath = PathResolver.ConvertDevicePathToDrivePath(rawAppPath);
                if (!ShouldProcessEvent(appPath)) return;

                var eventDirection = ParseDirection(GetValueFromXml(xmlContent, "Direction"));

                string serviceName = GetValueFromXml(xmlContent, "ServiceName");
                if (appPath.EndsWith("svchost.exe", StringComparison.OrdinalIgnoreCase))
                {
                    string pid = GetValueFromXml(xmlContent, "ProcessID");
                    string servicesInProcess = SystemDiscoveryService.GetServicesByPID(pid);
                    if (!string.IsNullOrEmpty(servicesInProcess))
                    {
                        serviceName = servicesInProcess;
                    }
                }

                if (_dataService.DoesRuleExist(appPath, eventDirection, serviceName))
                {
                    return;
                }

                var matchingRule = _wildcardRuleService.Match(appPath);
                if (matchingRule != null)
                {
                    if (matchingRule.Action.StartsWith("Allow", StringComparison.OrdinalIgnoreCase))
                    {
                        _actionsService.ApplyApplicationRuleChange(new List<string> { appPath }, matchingRule.Action, matchingRule.FolderPath);
                    }
                    return;
                }

                var pendingVm = new PendingConnectionViewModel
                {
                    AppPath = appPath,
                    Direction = eventDirection,
                    ServiceName = serviceName
                };
                PendingConnectionDetected?.Invoke(pendingVm);
            }
            catch (Exception ex) { Debug.WriteLine("[FATAL ERROR IN EVENT HANDLER] " + ex); }
        }

        public void SnoozeNotificationsForApp(string appPath, int minutes)
        {
            _snoozedApps.Add(appPath);
            if (_snoozeTimers.TryGetValue(appPath, out var oldTimer))
            {
                oldTimer.Dispose();
            }
            var timer = new Timer(_ => Application.Current.Dispatcher.Invoke(new Action(() => _snoozedApps.Remove(appPath))), null, TimeSpan.FromMinutes(minutes), Timeout.InfiniteTimeSpan);
            _snoozeTimers[appPath] = timer;
        }

        public void ClearAllSnoozes()
        {
            _snoozedApps.Clear();
            foreach (var timer in _snoozeTimers.Values)
            {
                timer.Dispose();
            }
            _snoozeTimers.Clear();
        }

        private bool ShouldProcessEvent(string appPath)
        {
            if (string.IsNullOrEmpty(appPath) || appPath.Equals("System", StringComparison.OrdinalIgnoreCase))
            {
                return false;
            }
            return _isLockdownEnabled() && !_snoozedApps.Contains(appPath);
        }

        private static string ParseDirection(string rawDirection)
        {
            switch (rawDirection)
            {
                case "%%14592": return "Inbound";
                case "%%14593": return "Outbound";
                default: return rawDirection;
            }
        }

        private static string GetValueFromXml(string xml, string elementName)
        {
            try
            {
                var xdoc = XDocument.Parse(xml);
                var ns = xdoc.Root.GetDefaultNamespace();
                var dataElement = xdoc.Descendants(ns + "Data").FirstOrDefault(d => d.Attribute("Name")?.Value == elementName);
                return dataElement?.Value ?? string.Empty;
            }
            catch
            {
                return string.Empty;
            }
        }

        public void Dispose()
        {
            _eventWatcher?.Dispose();
            foreach (var timer in _snoozeTimers.Values)
            {
                timer.Dispose();
            }
            GC.SuppressFinalize(this);
        }
    }
}

--------------------------------------------------------------------------------
// File: DataModels.cs
--------------------------------------------------------------------------------
ï»¿using System.IO;

namespace MinimalFirewall
{
    public enum SearchMode
    {
        Name,
        Path
    }

    public class WildcardRule
    {
        public string FolderPath { get; set; }
        public string ExeName { get; set; }
        public string Action { get; set; }
    }

    public class AdvancedRuleViewModel
    {
        public string Name { get; set; }
        public string Status { get; set; }
        public bool IsEnabled { get; set; }
        public string Direction { get; set; }
        public string Ports { get; set; }
        public string Protocol { get; set; }
        public string ServiceName { get; set; }
        public string RemoteAddresses { get; set; }
        public string Profiles { get; set; }
        public string Description { get; set; }
        public string Grouping { get; set; }
    }

    public class FirewallRuleViewModel
    {
        public string Name { get; set; }
        public string ApplicationName { get; set; }
        public string Status { get; set; }
    }

    public class PendingConnectionViewModel
    {
        public string AppPath { get; set; }
        public string FileName { get { return Path.GetFileName(AppPath); } }
        public string Direction { get; set; }
        public string ServiceName { get; set; }
    }

    public class ProgramViewModel
    {
        public string Name { get; set; }
        public string ExePath { get; set; }
    }

    public class ServiceViewModel
    {
        public string ServiceName { get; set; }
        public string DisplayName { get; set; }
        public string ExePath { get; set; }
    }

    public class UwpApp
    {
        public string Name { get; set; }
        public string PackageFamilyName { get; set; }
        public string Status { get; set; } = "Undefined";
    }
}

--------------------------------------------------------------------------------
// File: WildcardCreatorWindow.xaml.cs
--------------------------------------------------------------------------------
ï»¿using System.IO;
using System.Windows;

namespace MinimalFirewall
{
    public partial class WildcardCreatorWindow : Window
    {
        public string FolderPath { get; private set; }
        public string ExeName { get; private set; }
        public string SelectedAction { get; private set; }

        public WildcardCreatorWindow()
        {
            InitializeComponent();
            Owner = Application.Current.MainWindow;
        }

        private void BrowseButton_Click(object sender, RoutedEventArgs e)
        {
            if (FolderPicker.TryPickFolder(out var folderPath))
            {
                FolderPathTextBox.Text = folderPath;
            }
        }

        private void OkButton_Click(object sender, RoutedEventArgs e)
        {
            if (string.IsNullOrWhiteSpace(FolderPathTextBox.Text) || !Directory.Exists(FolderPathTextBox.Text))
            {
                MessageBox.Show("Please select a valid folder path.", "Invalid Path", MessageBoxButton.OK, MessageBoxImage.Error);
                return;
            }

            FolderPath = FolderPathTextBox.Text;
            ExeName = ExeNameTextBox.Text;

            if (AllowOutboundRadio.IsChecked == true) SelectedAction = "Allow (Outbound)";
            else if (AllowInboundRadio.IsChecked == true) SelectedAction = "Allow (Inbound)";
            else if (BlockOutboundRadio.IsChecked == true) SelectedAction = "Block (Outbound)";
            else if (BlockInboundRadio.IsChecked == true) SelectedAction = "Block (Inbound)";

            DialogResult = true;
        }
    }
}

--------------------------------------------------------------------------------
// File: WildcardCreatorWindow.xaml
--------------------------------------------------------------------------------
ï»¿<Window x:Class="MinimalFirewall.WildcardCreatorWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
        mc:Ignorable="d"
        Title="Create Wildcard Rule" Height="340" Width="500"
        WindowStartupLocation="CenterOwner" ResizeMode="NoResize"
        WindowStyle="None" AllowsTransparency="True" Background="Transparent">

    <Border BorderBrush="{DynamicResource App.Border.Default}" BorderThickness="1" Background="{DynamicResource App.Window.Background}">
        <Grid Margin="15">
            <Grid.RowDefinitions>
                <RowDefinition Height="Auto"/>
                <RowDefinition Height="Auto"/>
                <RowDefinition Height="Auto"/>
                <RowDefinition Height="Auto"/>
                <RowDefinition Height="*"/>
                <RowDefinition Height="Auto"/>
            </Grid.RowDefinitions>

            <Label Grid.Row="0" Content="Folder Path:" FontWeight="Bold"/>
            <Grid Grid.Row="1" Margin="0,5,0,0">
                <Grid.ColumnDefinitions>
                    <ColumnDefinition Width="*"/>
                    <ColumnDefinition Width="Auto"/>
                </Grid.ColumnDefinitions>
                <TextBox Grid.Column="0" x:Name="FolderPathTextBox" VerticalAlignment="Center"/>
                <Button Grid.Column="1" Content="Browse..." Click="BrowseButton_Click" Margin="5,0,0,0"/>
            </Grid>

            <Label Grid.Row="2" Content="Optional .exe Name:" FontWeight="Bold" Margin="0,10,0,0"/>
            <TextBox Grid.Row="3" x:Name="ExeNameTextBox" VerticalAlignment="Center" Margin="0,5,0,0" ToolTip="e.g., svchost.exe (leave blank to apply to all executables in the folder)"/>

            <GroupBox Grid.Row="4" Header="Action" Margin="0,15,0,0">
                <StackPanel VerticalAlignment="Center">
                    <RadioButton x:Name="AllowOutboundRadio" Content="Allow (Outbound)" IsChecked="True" Margin="5"/>
                    <RadioButton x:Name="AllowInboundRadio" Content="Allow (Inbound)" Margin="5"/>
                    <RadioButton x:Name="BlockOutboundRadio" Content="Block (Outbound)" Margin="5"/>
                    <RadioButton x:Name="BlockInboundRadio" Content="Block (Inbound)" Margin="5"/>
                </StackPanel>
            </GroupBox>

            <StackPanel Grid.Row="5" Orientation="Horizontal" HorizontalAlignment="Right" Margin="0,15,0,0">
                <Button Content="OK" Width="80" IsDefault="True" Click="OkButton_Click" Margin="5"/>
                <Button Content="Cancel" Width="80" IsCancel="True" Margin="5"/>
            </StackPanel>
        </Grid>
    </Border>
</Window>

--------------------------------------------------------------------------------
// File: AdvancedRuleCreator.xaml
--------------------------------------------------------------------------------
ï»¿<Window x:Class="MinimalFirewall.AdvancedRuleCreator"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
        mc:Ignorable="d"
        Title="Create Advanced Rule" Height="350" Width="550"
        WindowStartupLocation="CenterOwner" ResizeMode="NoResize"
        WindowStyle="None" AllowsTransparency="True" Background="Transparent">

    <Window.Resources>
        <Style x:Key="CaptionButtonStyle" TargetType="Button">
            <Setter Property="Width" Value="46"/>
            <Setter Property="Height" Value="32"/>
            <Setter Property="Background" Value="Transparent"/>
            <Setter Property="Foreground" Value="{DynamicResource App.Text.Default}"/>
            <Setter Property="BorderThickness" Value="0"/>
            <Setter Property="VerticalAlignment" Value="Top"/>
            <Setter Property="Template">
                <Setter.Value>
                    <ControlTemplate TargetType="{x:Type Button}">
                        <Border Background="{TemplateBinding Background}" Name="border">
                            <ContentPresenter HorizontalAlignment="Center" VerticalAlignment="Center"/>
                        </Border>
                    </ControlTemplate>
                </Setter.Value>
            </Setter>
            <Style.Triggers>
                <Trigger Property="IsMouseOver" Value="True">
                    <Setter Property="Background" Value="{DynamicResource CaptionButton.Background.MouseOver}" />
                </Trigger>
            </Style.Triggers>
        </Style>
        <Style x:Key="CloseButtonStyle" BasedOn="{StaticResource CaptionButtonStyle}" TargetType="Button">
            <Style.Triggers>
                <Trigger Property="IsMouseOver" Value="True">
                    <Setter Property="Background" Value="#E81123" />
                    <Setter Property="Foreground" Value="White" />
                </Trigger>
            </Style.Triggers>
        </Style>
    </Window.Resources>

    <Border BorderBrush="{DynamicResource App.Border.Default}" BorderThickness="1" Background="{DynamicResource App.Window.Background}">
        <DockPanel>
            <Border DockPanel.Dock="Top" Background="{DynamicResource TitleBar.Background.Default}" BorderBrush="{DynamicResource App.Border.Default}" BorderThickness="0,0,0,1" Height="30" MouseLeftButtonDown="TitleBar_MouseLeftButtonDown">
                <Grid>
                    <TextBlock Text="{Binding Title, RelativeSource={RelativeSource AncestorType=Window}}" VerticalAlignment="Center" HorizontalAlignment="Left" Margin="10,0,0,0" Foreground="{DynamicResource App.Text.Default}"/>
                    <Button Content="âœ•" Style="{StaticResource CloseButtonStyle}" Height="30" HorizontalAlignment="Right" Click="CloseButton_Click" />
                </Grid>
            </Border>

            <Grid Margin="15">
                <Grid.RowDefinitions>
                    <RowDefinition Height="Auto"/>
                    <RowDefinition Height="*"/>
                    <RowDefinition Height="Auto"/>
                </Grid.RowDefinitions>

                <Label Grid.Row="0" Content="Rule Type:" FontWeight="Bold"/>

                <TabControl Grid.Row="1" Margin="0,5,0,0" x:Name="tabControl">
                    <TabItem Header="TCP Port">
                        <Grid Margin="10">
                            <Grid.RowDefinitions>
                                <RowDefinition Height="Auto"/>
                                <RowDefinition Height="Auto"/>
                                <RowDefinition Height="Auto"/>
                            </Grid.RowDefinitions>
                            <Grid.ColumnDefinitions>
                                <ColumnDefinition Width="Auto"/>
                                <ColumnDefinition Width="*"/>
                            </Grid.ColumnDefinitions>
                            <Label Grid.Row="0" Grid.Column="0" Content="Port(s):" VerticalAlignment="Center"/>
                            <TextBox Grid.Row="0" Grid.Column="1" x:Name="TcpPortsTextBox" Margin="5" ToolTip="e.g., 80, 443, 5000-5010"/>
                            <Label Grid.Row="1" Grid.Column="0" Content="Action:" VerticalAlignment="Center"/>
                            <ComboBox Grid.Row="1" Grid.Column="1" x:Name="TcpActionComboBox" Margin="5" SelectedIndex="0">
                                <ComboBoxItem>Allow</ComboBoxItem>
                                <ComboBoxItem>Block</ComboBoxItem>
                            </ComboBox>
                            <Label Grid.Row="2" Grid.Column="0" Content="Direction:" VerticalAlignment="Center"/>
                            <ComboBox Grid.Row="2" Grid.Column="1" x:Name="TcpDirectionComboBox" Margin="5" SelectedIndex="0">
                                <ComboBoxItem>Inbound</ComboBoxItem>
                                <ComboBoxItem>Outbound</ComboBoxItem>
                            </ComboBox>
                        </Grid>
                    </TabItem>
                    <TabItem Header="UDP Port">
                        <Grid Margin="10">
                            <Grid.RowDefinitions>
                                <RowDefinition Height="Auto"/>
                                <RowDefinition Height="Auto"/>
                                <RowDefinition Height="Auto"/>
                            </Grid.RowDefinitions>
                            <Grid.ColumnDefinitions>
                                <ColumnDefinition Width="Auto"/>
                                <ColumnDefinition Width="*"/>
                            </Grid.ColumnDefinitions>
                            <Label Grid.Row="0" Grid.Column="0" Content="Port(s):" VerticalAlignment="Center"/>
                            <TextBox Grid.Row="0" Grid.Column="1" x:Name="UdpPortsTextBox" Margin="5" ToolTip="e.g., 53, 5060"/>
                            <Label Grid.Row="1" Grid.Column="0" Content="Action:" VerticalAlignment="Center"/>
                            <ComboBox Grid.Row="1" Grid.Column="1" x:Name="UdpActionComboBox" Margin="5" SelectedIndex="0">
                                <ComboBoxItem>Allow</ComboBoxItem>
                                <ComboBoxItem>Block</ComboBoxItem>
                            </ComboBox>
                            <Label Grid.Row="2" Grid.Column="0" Content="Direction:" VerticalAlignment="Center"/>
                            <ComboBox Grid.Row="2" Grid.Column="1" x:Name="UdpDirectionComboBox" Margin="5" SelectedIndex="0">
                                <ComboBoxItem>Inbound</ComboBoxItem>
                                <ComboBoxItem>Outbound</ComboBoxItem>
                            </ComboBox>
                        </Grid>
                    </TabItem>
                    <TabItem Header="IP Address">
                        <Grid Margin="10">
                            <Grid.RowDefinitions>
                                <RowDefinition Height="Auto"/>
                                <RowDefinition Height="Auto"/>
                                <RowDefinition Height="Auto"/>
                            </Grid.RowDefinitions>
                            <Grid.ColumnDefinitions>
                                <ColumnDefinition Width="Auto"/>
                                <ColumnDefinition Width="*"/>
                            </Grid.ColumnDefinitions>
                            <Label Grid.Row="0" Grid.Column="0" Content="Remote Address:" VerticalAlignment="Center"/>
                            <TextBox Grid.Row="0" Grid.Column="1" x:Name="RemoteIpTextBox" Margin="5" ToolTip="e.g., 8.8.8.8, 10.0.0.0/24"/>
                            <Label Grid.Row="1" Grid.Column="0" Content="Action:" VerticalAlignment="Center"/>
                            <ComboBox Grid.Row="1" Grid.Column="1" x:Name="IpActionComboBox" Margin="5" SelectedIndex="0">
                                <ComboBoxItem>Allow</ComboBoxItem>
                                <ComboBoxItem>Block</ComboBoxItem>
                            </ComboBox>
                            <Label Grid.Row="2" Grid.Column="0" Content="Direction:" VerticalAlignment="Center"/>
                            <ComboBox Grid.Row="2" Grid.Column="1" x:Name="IpDirectionComboBox" Margin="5" SelectedIndex="0">
                                <ComboBoxItem>Inbound</ComboBoxItem>
                                <ComboBoxItem>Outbound</ComboBoxItem>
                            </ComboBox>
                        </Grid>
                    </TabItem>
                    <TabItem Header="Block Service">
                        <Grid Margin="10">
                            <Grid.RowDefinitions>
                                <RowDefinition Height="Auto"/>
                            </Grid.RowDefinitions>
                            <Grid.ColumnDefinitions>
                                <ColumnDefinition Width="Auto"/>
                                <ColumnDefinition Width="*"/>
                            </Grid.ColumnDefinitions>
                            <Label Grid.Row="0" Grid.Column="0" Content="Service Name:" VerticalAlignment="Center"/>
                            <TextBox Grid.Row="0" Grid.Column="1" x:Name="ServiceNameTextBox" Margin="5" ToolTip="e.g., wuauserv (for Windows Update)"/>
                        </Grid>
                    </TabItem>
                    <TabItem Header="Program + Remote IP">
                        <Grid Margin="10">
                            <Grid.RowDefinitions>
                                <RowDefinition Height="Auto"/>
                                <RowDefinition Height="Auto"/>
                                <RowDefinition Height="Auto"/>
                                <RowDefinition Height="Auto"/>
                            </Grid.RowDefinitions>
                            <Grid.ColumnDefinitions>
                                <ColumnDefinition Width="Auto"/>
                                <ColumnDefinition Width="*"/>
                                <ColumnDefinition Width="Auto"/>
                            </Grid.ColumnDefinitions>
                            <Label Grid.Row="0" Grid.Column="0" Content="Program Path:" VerticalAlignment="Center"/>
                            <TextBox Grid.Row="0" Grid.Column="1" x:Name="ProgIpProgramPathTextBox" Margin="5"/>
                            <Button Grid.Row="0" Grid.Column="2" Content="..." Width="30" Click="BrowseButton_Click" ToolTip="Browse for Program..."/>

                            <Label Grid.Row="1" Grid.Column="0" Content="Remote Address:" VerticalAlignment="Center"/>
                            <TextBox Grid.Row="1" Grid.Column="1" x:Name="ProgIpRemoteIpTextBox" Margin="5" ToolTip="e.g., 8.8.8.8, 10.0.0.0/24"/>

                            <Label Grid.Row="2" Grid.Column="0" Content="Action:" VerticalAlignment="Center"/>
                            <ComboBox Grid.Row="2" Grid.Column="1" x:Name="ProgIpActionComboBox" Margin="5" SelectedIndex="0">
                                <ComboBoxItem>Allow</ComboBoxItem>
                                <ComboBoxItem>Block</ComboBoxItem>
                            </ComboBox>

                            <Label Grid.Row="3" Grid.Column="0" Content="Direction:" VerticalAlignment="Center"/>
                            <ComboBox Grid.Row="3" Grid.Column="1" x:Name="ProgIpDirectionComboBox" Margin="5" SelectedIndex="0">
                                <ComboBoxItem>Outbound</ComboBoxItem>
                                <ComboBoxItem>Inbound</ComboBoxItem>
                            </ComboBox>
                        </Grid>
                    </TabItem>
                    <TabItem Header="Program + Port">
                        <Grid Margin="10">
                            <Grid.RowDefinitions>
                                <RowDefinition Height="Auto"/>
                                <RowDefinition Height="Auto"/>
                                <RowDefinition Height="Auto"/>
                                <RowDefinition Height="Auto"/>
                            </Grid.RowDefinitions>
                            <Grid.ColumnDefinitions>
                                <ColumnDefinition Width="Auto"/>
                                <ColumnDefinition Width="*"/>
                                <ColumnDefinition Width="Auto"/>
                            </Grid.ColumnDefinitions>
                            <Label Grid.Row="0" Grid.Column="0" Content="Program Path:" VerticalAlignment="Center"/>
                            <TextBox Grid.Row="0" Grid.Column="1" x:Name="ProgPortProgramPathTextBox" Margin="5"/>
                            <Button Grid.Row="0" Grid.Column="2" Content="..." Width="30" Click="BrowseButton_Click" ToolTip="Browse for Program..."/>

                            <Label Grid.Row="1" Grid.Column="0" Content="Remote Port(s):" VerticalAlignment="Center"/>
                            <TextBox Grid.Row="1" Grid.Column="1" x:Name="ProgPortRemotePortTextBox" Margin="5" ToolTip="e.g., 80, 443, 5000-5010"/>

                            <Label Grid.Row="2" Grid.Column="0" Content="Protocol:" VerticalAlignment="Center"/>
                            <ComboBox Grid.Row="2" Grid.Column="1" x:Name="ProgPortProtocolComboBox" Margin="5" SelectedIndex="0">
                                <ComboBoxItem>TCP</ComboBoxItem>
                                <ComboBoxItem>UDP</ComboBoxItem>
                            </ComboBox>

                            <Label Grid.Row="3" Grid.Column="0" Content="Direction:" VerticalAlignment="Center"/>
                            <ComboBox Grid.Row="3" Grid.Column="1" x:Name="ProgPortDirectionComboBox" Margin="5" SelectedIndex="0">
                                <ComboBoxItem>Outbound</ComboBoxItem>
                                <ComboBoxItem>Inbound</ComboBoxItem>
                            </ComboBox>
                        </Grid>
                    </TabItem>
                    <TabItem Header="Allow LAN Only">
                        <Grid Margin="10">
                            <Grid.ColumnDefinitions>
                                <ColumnDefinition Width="Auto"/>
                                <ColumnDefinition Width="*"/>
                                <ColumnDefinition Width="Auto"/>
                            </Grid.ColumnDefinitions>
                            <Label Grid.Column="0" Content="Program Path:" VerticalAlignment="Center"/>
                            <TextBox Grid.Column="1" x:Name="LanOnlyProgramPathTextBox" Margin="5"/>
                            <Button Grid.Column="2" Content="..." Width="30" Click="BrowseButton_Click" ToolTip="Browse for Program..."/>
                        </Grid>
                    </TabItem>
                    <TabItem Header="Uninstall Rules">
                        <Grid Margin="10">
                            <StackPanel VerticalAlignment="Center" HorizontalAlignment="Center">
                                <TextBlock TextWrapping="Wrap" TextAlignment="center" MaxWidth="400">
                                    This will permanently remove all firewall rules created by Minimal Firewall.
                                    <LineBreak/><LineBreak/>
                                    This action cannot be undone.
                                </TextBlock>
                                <Button Content="Uninstall All MFW Rules" Width="200" Margin="0,20,0,0" Padding="5" Click="UninstallButton_Click"/>
                            </StackPanel>
                        </Grid>
                    </TabItem>
                </TabControl>

                <StackPanel Grid.Row="2" Orientation="Horizontal" HorizontalAlignment="Right" Margin="0,10,0,0">
                    <Button Content="Create Rule" Width="100" Margin="5" Click="OkButton_Click" IsDefault="True"/>
                    <Button Content="Cancel" Width="80" Margin="5" IsCancel="True"/>
                </StackPanel>
            </Grid>
        </DockPanel>
    </Border>
</Window>

--------------------------------------------------------------------------------
// File: AdvancedRuleCreator.xaml.cs
--------------------------------------------------------------------------------
ï»¿using Microsoft.Win32;
using System.IO;
using System.Text;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Input;

namespace MinimalFirewall
{
    public partial class AdvancedRuleCreator : Window
    {
        public string RuleCommand { get; private set; }

        public AdvancedRuleCreator()
        {
            InitializeComponent();
            Owner = Application.Current.MainWindow;
            RuleCommand = string.Empty;
        }

        private void OkButton_Click(object sender, RoutedEventArgs e)
        {
            if (!(tabControl.SelectedItem is TabItem selectedTab)) return;
            var commandBuilder = new StringBuilder("New-NetFirewallRule");
            string displayName;
            const string validationError = "cannot be empty.";
            switch (selectedTab.Header.ToString())
            {
                case "TCP Port":
                    if (string.IsNullOrWhiteSpace(TcpPortsTextBox.Text)) { ShowError("TCP Port " + validationError); return; }
                    displayName = $"'MFW TCP Port {TcpPortsTextBox.Text}'";
                    commandBuilder.Append($" -DisplayName {displayName} -Protocol TCP -LocalPort {TcpPortsTextBox.Text}");
                    AppendSharedParameters(commandBuilder, TcpActionComboBox, TcpDirectionComboBox);
                    break;
                case "UDP Port":
                    if (string.IsNullOrWhiteSpace(UdpPortsTextBox.Text)) { ShowError("UDP Port " + validationError); return; }
                    displayName = $"'MFW UDP Port {UdpPortsTextBox.Text}'";
                    commandBuilder.Append($" -DisplayName {displayName} -Protocol UDP -LocalPort {UdpPortsTextBox.Text}");
                    AppendSharedParameters(commandBuilder, UdpActionComboBox, UdpDirectionComboBox);
                    break;
                case "IP Address":
                    if (string.IsNullOrWhiteSpace(RemoteIpTextBox.Text)) { ShowError("Remote IP Address " + validationError); return; }
                    displayName = $"'MFW IP {RemoteIpTextBox.Text}'";
                    commandBuilder.Append($" -DisplayName {displayName} -RemoteAddress {RemoteIpTextBox.Text}");
                    AppendSharedParameters(commandBuilder, IpActionComboBox, IpDirectionComboBox);
                    break;
                case "Block Service":
                    if (string.IsNullOrWhiteSpace(ServiceNameTextBox.Text)) { ShowError("Service Name " + validationError); return; }
                    string serviceName = ServiceNameTextBox.Text;
                    displayName = $"'MFW Block Service {serviceName}'";
                    commandBuilder.Append($" -DisplayName {displayName} -Service {serviceName} -Action Block -Direction Outbound");
                    break;
                case "Program + Remote IP":
                    if (string.IsNullOrWhiteSpace(ProgIpProgramPathTextBox.Text)) { ShowError("Program Path " + validationError); return; }
                    if (string.IsNullOrWhiteSpace(ProgIpRemoteIpTextBox.Text)) { ShowError("Remote IP Address " + validationError); return; }
                    string progIpPath = ProgIpProgramPathTextBox.Text;
                    string progIpName = Path.GetFileNameWithoutExtension(progIpPath);
                    displayName = $"'MFW {progIpName} to {ProgIpRemoteIpTextBox.Text}'";
                    commandBuilder.Append($" -DisplayName {displayName} -Program \"{progIpPath}\" -RemoteAddress {ProgIpRemoteIpTextBox.Text}");
                    AppendSharedParameters(commandBuilder, ProgIpActionComboBox, ProgIpDirectionComboBox);
                    break;
                case "Program + Port":
                    if (string.IsNullOrWhiteSpace(ProgPortProgramPathTextBox.Text)) { ShowError("Program Path " + validationError); return; }
                    if (string.IsNullOrWhiteSpace(ProgPortRemotePortTextBox.Text)) { ShowError("Remote Port(s) " + validationError); return; }
                    string progPortPath = ProgPortProgramPathTextBox.Text;
                    string progPortName = Path.GetFileNameWithoutExtension(progPortPath);
                    string remotePorts = ProgPortRemotePortTextBox.Text;
                    string protocol = (ProgPortProtocolComboBox.SelectedItem as ComboBoxItem)?.Content.ToString();
                    displayName = $"'MFW Block {progPortName} on {protocol} {remotePorts}'";
                    commandBuilder.Append($" -DisplayName {displayName} -Program \"{progPortPath}\" -RemotePort {remotePorts} -Protocol {protocol} -Action Block");
                    AppendSharedParameters(commandBuilder, null, ProgPortDirectionComboBox);
                    break;
                case "Allow LAN Only":
                    if (string.IsNullOrWhiteSpace(LanOnlyProgramPathTextBox.Text)) { ShowError("Program Path " + validationError); return; }
                    string lanOnlyPath = LanOnlyProgramPathTextBox.Text;
                    string lanOnlyName = Path.GetFileNameWithoutExtension(lanOnlyPath);
                    displayName = $"'MFW {lanOnlyName} (LAN Only)'";
                    commandBuilder.Append($" -DisplayName {displayName} -Program \"{lanOnlyPath}\" -RemoteAddress LocalSubnet -Action Allow");
                    break;
                case "Uninstall Rules":
                    return;
                default:
                    return;
            }

            commandBuilder.Append($" -Group '{MFWConstants.MainRuleGroup}'");
            RuleCommand = commandBuilder.ToString();
            DialogResult = true;
        }

        private void UninstallButton_Click(object sender, RoutedEventArgs e)
        {
            var result = MessageBox.Show(
                "Are you sure you want to delete ALL rules created by Minimal Firewall (including wildcard rules)?\n\nThis action cannot be undone.",
                "Confirm Uninstall",
                MessageBoxButton.YesNo,
                MessageBoxImage.Warning);
            if (result == MessageBoxResult.Yes)
            {
                RuleCommand = $"Get-NetFirewallRule -Group '{MFWConstants.MainRuleGroup}', '{MFWConstants.WildcardRuleGroup}' -ErrorAction SilentlyContinue | Remove-NetFirewallRule";
                DialogResult = true;
            }
        }

        private void BrowseButton_Click(object sender, RoutedEventArgs e)
        {
            var openFileDialog = new OpenFileDialog
            {
                Filter = "Executable files (*.exe)|*.exe|All files (*.*)|*.*",
                Title = "Select a Program"
            };
            if (openFileDialog.ShowDialog() == true)
            {
                if (tabControl.SelectedItem is TabItem selectedTab)
                {
                    string header = selectedTab.Header.ToString();
                    if (header == "Program + Remote IP")
                    {
                        ProgIpProgramPathTextBox.Text = openFileDialog.FileName;
                    }
                    else if (header == "Program + Port")
                    {
                        ProgPortProgramPathTextBox.Text = openFileDialog.FileName;
                    }
                    else if (header == "Allow LAN Only")
                    {
                        LanOnlyProgramPathTextBox.Text = openFileDialog.FileName;
                    }
                }
            }
        }

        private static void AppendSharedParameters(StringBuilder builder, ComboBox actionBox, ComboBox directionBox)
        {
            if (actionBox != null && actionBox.SelectedItem is ComboBoxItem actionItem)
            {
                builder.Append($" -Action {actionItem.Content}");
            }
            if (directionBox != null && directionBox.SelectedItem is ComboBoxItem directionItem)
            {
                builder.Append($" -Direction {directionItem.Content}");
            }
        }

        private static void ShowError(string message)
        {
            MessageBox.Show(message, "Validation Error", MessageBoxButton.OK, MessageBoxImage.Error);
        }

        private void CloseButton_Click(object sender, RoutedEventArgs e)
        {
            this.Close();
        }

        private void TitleBar_MouseLeftButtonDown(object sender, MouseButtonEventArgs e)
        {
            DragMove();
        }
    }
}

--------------------------------------------------------------------------------
// File: MinimalFirewall.csproj
--------------------------------------------------------------------------------
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
	<Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props" Condition="Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props')" />
	<PropertyGroup>
		<Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
		<Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
		<ProjectGuid>{9E4B486F-2ABD-4064-BD79-6736C3E73C16}</ProjectGuid>
		<OutputType>WinExe</OutputType>
		<RootNamespace>MinimalFirewall</RootNamespace>
		<AssemblyName>MinimalFirewall</AssemblyName>
		<TargetFrameworkVersion>v4.8</TargetFrameworkVersion>
		<FileAlignment>512</FileAlignment>
		<ProjectTypeGuids>{60dc8134-eba5-43b8-bcc9-bb4bc16c2548};{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}</ProjectTypeGuids>
		<WarningLevel>4</WarningLevel>
		<AutoGenerateBindingRedirects>true</AutoGenerateBindingRedirects>
		<Deterministic>true</Deterministic>
	</PropertyGroup>
	<PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
		<PlatformTarget>AnyCPU</PlatformTarget>
		<DebugSymbols>true</DebugSymbols>
		<DebugType>full</DebugType>
		<Optimize>false</Optimize>
		<OutputPath>bin\Debug\</OutputPath>
		<DefineConstants>DEBUG;TRACE</DefineConstants>
		<ErrorReport>prompt</ErrorReport>
		<WarningLevel>4</WarningLevel>
	</PropertyGroup>
	<PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
		<PlatformTarget>AnyCPU</PlatformTarget>
		<DebugType>pdbonly</DebugType>
		<Optimize>true</Optimize>
		<OutputPath>bin\Release\</OutputPath>
		<DefineConstants>TRACE</DefineConstants>
		<ErrorReport>prompt</ErrorReport>
		<WarningLevel>4</WarningLevel>
	</PropertyGroup>
	<PropertyGroup>
		<ApplicationManifest>app.manifest</ApplicationManifest>
	</PropertyGroup>
	<PropertyGroup>
		<ApplicationIcon>logo.ico</ApplicationIcon>
	</PropertyGroup>
	<PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'x64|AnyCPU'">
		<OutputPath>bin\x64\</OutputPath>
		<DefineConstants>TRACE</DefineConstants>
		<Optimize>true</Optimize>
		<DebugType>pdbonly</DebugType>
		<PlatformTarget>AnyCPU</PlatformTarget>
		<LangVersion>7.3</LangVersion>
		<ErrorReport>prompt</ErrorReport>
		<Prefer32Bit>true</Prefer32Bit>
	</PropertyGroup>
	<PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Debug|x64'">
		<DebugSymbols>true</DebugSymbols>
		<OutputPath>bin\x64\Debug\</OutputPath>
		<DefineConstants>DEBUG;TRACE</DefineConstants>
		<DebugType>full</DebugType>
		<PlatformTarget>x64</PlatformTarget>
		<LangVersion>7.3</LangVersion>
		<ErrorReport>prompt</ErrorReport>
		<Prefer32Bit>true</Prefer32Bit>
	</PropertyGroup>
	<PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Release|x64'">
		<OutputPath>bin\x64\Release\</OutputPath>
		<DefineConstants>TRACE</DefineConstants>
		<Optimize>true</Optimize>
		<DebugType>pdbonly</DebugType>
		<PlatformTarget>x64</PlatformTarget>
		<LangVersion>7.3</LangVersion>
		<ErrorReport>prompt</ErrorReport>
		<Prefer32Bit>true</Prefer32Bit>
	</PropertyGroup>
	<PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'x64|x64'">
		<OutputPath>bin\x64\x64\</OutputPath>
		<DefineConstants>TRACE</DefineConstants>
		<Optimize>true</Optimize>
		<DebugType>pdbonly</DebugType>
		<PlatformTarget>x64</PlatformTarget>
		<LangVersion>7.3</LangVersion>
		<ErrorReport>prompt</ErrorReport>
		<Prefer32Bit>true</Prefer32Bit>
	</PropertyGroup>
	<ItemGroup>
		<Reference Include="Microsoft.Bcl.AsyncInterfaces, Version=1.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51, processorArchitecture=MSIL">
			<HintPath>..\packages\Microsoft.Bcl.AsyncInterfaces.1.1.1\lib\net461\Microsoft.Bcl.AsyncInterfaces.dll</HintPath>
		</Reference>
		<Reference Include="Microsoft.CSharp" />
		<Reference Include="PresentationCore" />
		<Reference Include="PresentationFramework" />
		<Reference Include="System" />
		<Reference Include="System.Buffers, Version=4.0.3.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51, processorArchitecture=MSIL">
			<HintPath>..\packages\System.Buffers.4.5.1\lib\net461\System.Buffers.dll</HintPath>
		</Reference>
		<Reference Include="System.Core" />
		<Reference Include="System.Data" />
		<Reference Include="System.Data.DataSetExtensions" />
		<Reference Include="System.Drawing" />
		<Reference Include="System.Management" />
		<Reference Include="System.Memory, Version=4.0.1.1, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51, processorArchitecture=MSIL">
			<HintPath>..\packages\System.Memory.4.5.4\lib\net461\System.Memory.dll</HintPath>
		</Reference>
		<Reference Include="System.Net.Http" />
		<Reference Include="System.Numerics" />
		<Reference Include="System.Numerics.Vectors, Version=4.1.4.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
			<HintPath>..\packages\System.Numerics.Vectors.4.5.0\lib\net46\System.Numerics.Vectors.dll</HintPath>
		</Reference>
		<Reference Include="System.Runtime.CompilerServices.Unsafe, Version=4.0.6.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
			<HintPath>..\packages\System.Runtime.CompilerServices.Unsafe.4.7.1\lib\net461\System.Runtime.CompilerServices.Unsafe.dll</HintPath>
		</Reference>
		<Reference Include="System.Runtime.WindowsRuntime">
			<HintPath>C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETCore\v4.5\System.Runtime.WindowsRuntime.dll</HintPath>
			<Private>False</Private>
		</Reference>
		<Reference Include="System.Text.Encodings.Web, Version=4.0.5.1, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51, processorArchitecture=MSIL">
			<HintPath>..\packages\System.Text.Encodings.Web.4.7.2\lib\net461\System.Text.Encodings.Web.dll</HintPath>
		</Reference>
		<Reference Include="System.Text.Json, Version=4.0.1.2, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51, processorArchitecture=MSIL">
			<HintPath>..\packages\System.Text.Json.4.7.2\lib\net461\System.Text.Json.dll</HintPath>
		</Reference>
		<Reference Include="System.Threading.Tasks.Extensions, Version=4.2.0.1, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51, processorArchitecture=MSIL">
			<HintPath>..\packages\System.Threading.Tasks.Extensions.4.5.4\lib\net461\System.Threading.Tasks.Extensions.dll</HintPath>
		</Reference>
		<Reference Include="System.ValueTuple, Version=4.0.3.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51, processorArchitecture=MSIL">
			<HintPath>..\packages\System.ValueTuple.4.5.0\lib\net47\System.ValueTuple.dll</HintPath>
		</Reference>
		<Reference Include="System.Windows.Forms" />
		<Reference Include="System.Xaml">
			<RequiredTargetFramework>4.0</RequiredTargetFramework>
		</Reference>
		<Reference Include="System.Xml" />
		<Reference Include="System.Xml.Linq" />
		<Reference Include="Windows">
			<HintPath>C:\Program Files (x86)\Windows Kits\10\UnionMetadata\10.0.19041.0\Windows.winmd</HintPath>
		</Reference>
		<Reference Include="WindowsBase" />
	</ItemGroup>
	<ItemGroup>
		<ApplicationDefinition Include="App.xaml">
			<Generator>MSBuild:Compile</Generator>
			<SubType>Designer</SubType>
		</ApplicationDefinition>
		<Compile Include="AdminTaskService.cs" />
		<Compile Include="AdvancedRuleCreator.xaml.cs">
			<DependentUpon>AdvancedRuleCreator.xaml</DependentUpon>
		</Compile>
		<Compile Include="App.xaml.cs">
			<DependentUpon>App.xaml</DependentUpon>
			<SubType>Code</SubType>
		</Compile>
		<Compile Include="AppSettings.cs" />
		<Compile Include="ConnectionNotifierWindow.xaml.cs">
			<DependentUpon>ConnectionNotifierWindow.xaml</DependentUpon>
		</Compile>
		<Compile Include="DataModels.cs" />
		<Compile Include="EditRuleWindow.xaml.cs">
			<DependentUpon>EditRuleWindow.xaml</DependentUpon>
		</Compile>
		<Compile Include="FirewallActionsService.cs" />
		<Compile Include="FirewallDataService.cs" />
		<Compile Include="FirewallEventListenerService.cs" />
		<Compile Include="FirewallRuleService.cs" />
		<Compile Include="FolderPicker.cs" />
		<Compile Include="ForeignRuleTracker.cs" />
		<Compile Include="MainViewModel.cs" />
		<Compile Include="MainWindow.xaml.cs">
			<DependentUpon>MainWindow.xaml</DependentUpon>
			<SubType>Code</SubType>
		</Compile>
		<Compile Include="MFWConstants.cs" />
		<Compile Include="PathResolver.cs" />
		<Compile Include="Properties\AssemblyInfo.cs">
			<SubType>Code</SubType>
		</Compile>
		<Compile Include="Properties\Resources.Designer.cs">
			<AutoGen>True</AutoGen>
			<DesignTime>True</DesignTime>
			<DependentUpon>Resources.resx</DependentUpon>
		</Compile>
		<Compile Include="Properties\Settings.Designer.cs">
			<AutoGen>True</AutoGen>
			<DependentUpon>Settings.settings</DependentUpon>
			<DesignTimeSharedInput>True</DesignTimeSharedInput>
		</Compile>
		<Compile Include="RelayCommand.cs" />
		<Compile Include="StartupService.cs" />
		<Compile Include="StatusWindow.xaml.cs">
			<DependentUpon>StatusWindow.xaml</DependentUpon>
		</Compile>
		<Compile Include="SystemDiscoveryService.cs" />
		<Compile Include="UserActivityLogger.cs" />
		<Compile Include="UwpService.cs" />
		<Compile Include="WildcardCreatorWindow.xaml.cs">
			<DependentUpon>WildcardCreatorWindow.xaml</DependentUpon>
		</Compile>
		<Compile Include="WildcardRuleService.cs" />
		<Page Include="AdvancedRuleCreator.xaml">
			<Generator>MSBuild:Compile</Generator>
			<SubType>Designer</SubType>
		</Page>
		<Page Include="ConnectionNotifierWindow.xaml">
			<Generator>MSBuild:Compile</Generator>
			<SubType>Designer</SubType>
		</Page>
		<Page Include="EditRuleWindow.xaml">
			<Generator>MSBuild:Compile</Generator>
			<SubType>Designer</SubType>
		</Page>
		<Page Include="MainWindow.xaml">
			<Generator>MSBuild:Compile</Generator>
			<SubType>Designer</SubType>
		</Page>
		<Page Include="StatusWindow.xaml">
			<Generator>MSBuild:Compile</Generator>
			<SubType>Designer</SubType>
		</Page>
		<Page Include="Themes\DarkTheme.xaml">
			<Generator>XamlIntelliSenseFileGenerator</Generator>
			<SubType>Designer</SubType>
		</Page>
		<Page Include="Themes\Generic.xaml">
			<Generator>XamlIntelliSenseFileGenerator</Generator>
			<SubType>Designer</SubType>
		</Page>
		<Page Include="Themes\LightTheme.xaml">
			<Generator>XamlIntelliSenseFileGenerator</Generator>
			<SubType>Designer</SubType>
		</Page>
		<Page Include="WildcardCreatorWindow.xaml">
			<SubType>Designer</SubType>
			<Generator>MSBuild:Compile</Generator>
		</Page>
	</ItemGroup>
	<ItemGroup>
		<None Include="App.config" />
		<None Include="app.manifest" />
		<None Include="packages.config" />
		<None Include="Properties\Settings.settings">
			<Generator>SettingsSingleFileGenerator</Generator>
			<LastGenOutput>Settings.Designer.cs</LastGenOutput>
		</None>
	</ItemGroup>
	<ItemGroup>
		<COMReference Include="NetFwTypeLib">
			<Guid>{58FBCF7C-E7A9-467C-80B3-FC65E8FCCA08}</Guid>
			<VersionMajor>1</VersionMajor>
			<VersionMinor>0</VersionMinor>
			<Lcid>0</Lcid>
			<WrapperTool>tlbimp</WrapperTool>
			<Isolated>False</Isolated>
			<EmbedInteropTypes>True</EmbedInteropTypes>
		</COMReference>
	</ItemGroup>
	<ItemGroup>
		<EmbeddedResource Include="Properties\Resources.resx">
			<Generator>ResXFileCodeGenerator</Generator>
			<LastGenOutput>Resources.Designer.cs</LastGenOutput>
		</EmbeddedResource>
	</ItemGroup>
	<ItemGroup>
		<Resource Include="logo.ico" />
	</ItemGroup>
	<ItemGroup>
		<Resource Include="logo.png" />
	</ItemGroup>
	<Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
</Project>

--------------------------------------------------------------------------------
// File: MFWConstants.cs
--------------------------------------------------------------------------------
ï»¿namespace MinimalFirewall
{
    public static class MFWConstants
    {
        public const string MainRuleGroup = "Minimal Firewall";
        public const string WildcardRuleGroup = "Minimal Firewall (Wildcard)";
        public const string WildcardDescriptionPrefix = "MFW_Wildcard_Path:[";
        public const string UwpDescriptionPrefix = "UWP App; PFN=";
    }
}

--------------------------------------------------------------------------------
// File: StatusWindow.xaml
--------------------------------------------------------------------------------
ï»¿<Window x:Class="MinimalFirewall.StatusWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
        xmlns:shell="clr-namespace:System.Windows.Shell;assembly=PresentationFramework"
        mc:Ignorable="d"
        Title="Scanning..." Height="150" Width="400"
        WindowStartupLocation="CenterOwner" ResizeMode="NoResize" ShowInTaskbar="False"
        WindowStyle="None" AllowsTransparency="True" Background="Transparent">

    <shell:WindowChrome.WindowChrome>
        <shell:WindowChrome CornerRadius="0" UseAeroCaptionButtons="False" GlassFrameThickness="0" CaptionHeight="0"/>
    </shell:WindowChrome.WindowChrome>

    <Border BorderBrush="{DynamicResource App.Border.Default}" BorderThickness="1" Background="{DynamicResource App.Window.Background}">
        <Grid Margin="15">
            <Grid.RowDefinitions>
                <RowDefinition Height="Auto"/>
                <RowDefinition Height="*"/>
                <RowDefinition Height="Auto"/>
            </Grid.RowDefinitions>

            <TextBlock x:Name="StatusTextBlock" Grid.Row="0" Text="Scanning, please wait..." FontSize="14" HorizontalAlignment="Center" Foreground="{DynamicResource App.Text.Default}"/>

            <ProgressBar x:Name="ProgressBar" Grid.Row="1" IsIndeterminate="True" Height="20" Margin="0,15,0,15"/>

            <Button x:Name="OkButton" Grid.Row="2" Content="OK" Width="80" HorizontalAlignment="Center" Visibility="Collapsed" Click="OkButton_Click" IsDefault="True"/>
        </Grid>
    </Border>
</Window>

--------------------------------------------------------------------------------
// File: WildcardRuleService.cs
--------------------------------------------------------------------------------
ï»¿using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Text.Json;
using System.Text.Json.Serialization;

namespace MinimalFirewall
{
    public class WildcardRuleService
    {
        private readonly string _configPath;
        private List<WildcardRule> _rules;
        private static readonly JsonSerializerOptions _jsonOptions = new JsonSerializerOptions
        {
            WriteIndented = true,
            Converters = { new JsonStringEnumConverter() }
        };

        public WildcardRuleService()
        {
            string baseDirectory = AppDomain.CurrentDomain.BaseDirectory;
            _configPath = Path.Combine(baseDirectory, "wildcard_rules.json");
            LoadRules();
        }

        public List<WildcardRule> GetRules()
        {
            return _rules;
        }

        public void AddRule(WildcardRule rule)
        {
            if (!_rules.Any(r => r.FolderPath.Equals(rule.FolderPath, StringComparison.OrdinalIgnoreCase)))
            {
                _rules.Add(rule);
                SaveRules();
            }
        }

        public void RemoveRule(WildcardRule rule)
        {
            var ruleToRemove = _rules.FirstOrDefault(r => r.FolderPath.Equals(rule.FolderPath, StringComparison.OrdinalIgnoreCase));
            if (ruleToRemove != null)
            {
                _rules.Remove(ruleToRemove);
                SaveRules();
            }
        }

        private void LoadRules()
        {
            try
            {
                if (File.Exists(_configPath))
                {
                    string json = File.ReadAllText(_configPath);
                    _rules = JsonSerializer.Deserialize<List<WildcardRule>>(json, _jsonOptions) ?? new List<WildcardRule>();
                }
                else
                {
                    _rules = new List<WildcardRule>();
                }
            }
            catch (Exception ex)
            {
                Debug.WriteLine("[ERROR] Failed to load wildcard rules: " + ex.Message);
                _rules = new List<WildcardRule>();
            }
        }

        private void SaveRules()
        {
            try
            {
                string json = JsonSerializer.Serialize(_rules, _jsonOptions);
                File.WriteAllText(_configPath, json);
            }
            catch (Exception ex)
            {
                Debug.WriteLine("[ERROR] Failed to save wildcard rules: " + ex.Message);
            }
        }

        public WildcardRule Match(string path)
        {
            if (string.IsNullOrEmpty(path))
            {
                return null;
            }

            foreach (var rule in _rules)
            {
                if (path.StartsWith(rule.FolderPath, StringComparison.OrdinalIgnoreCase))
                {
                    return rule;
                }
            }
            return null;
        }
    }
}

--------------------------------------------------------------------------------
// File: ForeignRuleTracker.cs
--------------------------------------------------------------------------------
ï»¿using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text.Json;

namespace MinimalFirewall
{
    public class ForeignRuleTracker
    {
        private readonly string _baselinePath;
        private HashSet<string> _acknowledgedRuleNames;

        public ForeignRuleTracker()
        {
            string baseDirectory = AppDomain.CurrentDomain.BaseDirectory;
            _baselinePath = Path.Combine(baseDirectory, "foreign_rules_baseline.json");
            LoadAcknowledgedRules();
        }

        private void LoadAcknowledgedRules()
        {
            try
            {
                if (File.Exists(_baselinePath))
                {
                    string json = File.ReadAllText(_baselinePath);
                    _acknowledgedRuleNames = JsonSerializer.Deserialize<HashSet<string>>(json) ?? new HashSet<string>(StringComparer.OrdinalIgnoreCase);
                }
                else
                {
                    _acknowledgedRuleNames = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
                }
            }
            catch
            {
                _acknowledgedRuleNames = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
            }
        }

        private void Save()
        {
            try
            {
                var options = new JsonSerializerOptions { WriteIndented = true };
                string json = JsonSerializer.Serialize(_acknowledgedRuleNames, options);
                File.WriteAllText(_baselinePath, json);
            }
            catch (Exception)
            {
                // A failure to save the baseline should not crash the app
            }
        }

        public bool IsAcknowledged(string ruleName)
        {
            return _acknowledgedRuleNames.Contains(ruleName);
        }

        public void AcknowledgeRules(IEnumerable<string> ruleNames)
        {
            foreach (var name in ruleNames)
            {
                _acknowledgedRuleNames.Add(name);
            }
            Save();
        }
    }
}

--------------------------------------------------------------------------------
// File: UwpService.cs
--------------------------------------------------------------------------------
ï»¿using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.Json;
using System.Threading.Tasks;

namespace MinimalFirewall
{
    public class UwpService
    {
        private readonly string _cachePath;
        private static readonly JsonSerializerOptions _jsonOptions = new JsonSerializerOptions { WriteIndented = true, PropertyNameCaseInsensitive = true };
        public UwpService()
        {
            string baseDirectory = AppDomain.CurrentDomain.BaseDirectory;
            _cachePath = Path.Combine(baseDirectory, "uwp_apps.json");
        }

        public async Task<List<UwpApp>> ScanForUwpApps()
        {
            return await Task.Run(() =>
            {
                var psi = new ProcessStartInfo
                {
                    FileName = "powershell",
                    Arguments = "-NoProfile -ExecutionPolicy Bypass -Command \"Get-AppxPackage | Where-Object { !$_.IsFramework -and !$_.IsResourcePackage } | Select-Object Name, PackageFamilyName | ConvertTo-Json\"",
                    RedirectStandardOutput = true,
                    UseShellExecute = false,
                    CreateNoWindow = true,
                    StandardOutputEncoding = Encoding.UTF8
                };

                try
                {
                    using (var process = Process.Start(psi))
                    {
                        var output = process.StandardOutput.ReadToEnd();
                        process.WaitForExit();

                        if (string.IsNullOrWhiteSpace(output))
                        {
                            return new List<UwpApp>();
                        }

                        var apps = JsonSerializer.Deserialize<List<UwpApp>>(output, _jsonOptions);
                        var sortedApps = (apps ?? new List<UwpApp>()).OrderBy(app => app.Name).ToList();

                        SaveUwpAppsToCache(sortedApps);
                        return sortedApps;
                    }
                }
                catch (Exception ex)
                {
                    Debug.WriteLine("[ERROR] Failed to scan for UWP apps via PowerShell: " + ex.Message);
                    return new List<UwpApp>();
                }
            });
        }

        public List<UwpApp> LoadUwpAppsFromCache()
        {
            try
            {
                if (File.Exists(_cachePath))
                {
                    string json = File.ReadAllText(_cachePath);
                    var apps = JsonSerializer.Deserialize<List<UwpApp>>(json);
                    return apps ?? new List<UwpApp>();
                }
            }
            catch (Exception ex)
            {
                Debug.WriteLine("[ERROR] Failed to load UWP cache: " + ex.Message);
            }
            return new List<UwpApp>();
        }

        private void SaveUwpAppsToCache(List<UwpApp> apps)
        {
            try
            {
                string json = JsonSerializer.Serialize(apps, _jsonOptions);
                File.WriteAllText(_cachePath, json);
            }
            catch (Exception ex)
            {
                Debug.WriteLine("[ERROR] Failed to save UWP cache: " + ex.Message);
            }
        }
    }
}

--------------------------------------------------------------------------------
// File: AppSettings.cs
--------------------------------------------------------------------------------
ï»¿using System;
using System.IO;
using System.Text.Json;

namespace MinimalFirewall
{
    public class AppSettings
    {
        private static readonly string _configPath = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "settings.json");
        public bool ShowSystemRules { get; set; } = true;
        public bool IsPopupsEnabled { get; set; } = false;
        public bool IsLoggingEnabled { get; set; } = false;
        public string Theme { get; set; } = "Light";
        public bool StartOnSystemStartup { get; set; } = false;
        public bool CloseToTray { get; set; } = true;
        public bool ShowIcons { get; set; } = true;

        public void Save()
        {
            try
            {
                var options = new JsonSerializerOptions { WriteIndented = true };
                string json = JsonSerializer.Serialize(this, options);
                File.WriteAllText(_configPath, json);
            }
            catch (Exception)
            {
                // A failure to save settings should not crash the app
            }
        }

        public static AppSettings Load()
        {
            try
            {
                if (File.Exists(_configPath))
                {
                    string json = File.ReadAllText(_configPath);
                    return JsonSerializer.Deserialize<AppSettings>(json) ?? new AppSettings();
                }
            }
            catch (Exception)
            {
                // If loading fails, fall back to default settings
            }
            return new AppSettings();
        }
    }
}

--------------------------------------------------------------------------------
// File: AdminTaskService.cs
--------------------------------------------------------------------------------
ï»¿using System.Diagnostics;
using System.Windows;

namespace MinimalFirewall
{
    public class AdminTaskService
    {
        public static void ExecutePowerShellRuleCommand(string command)
        {
            string fullCommand = "-NoProfile -ExecutionPolicy Bypass -Command \"" + command + "\"";
            Execute(fullCommand, "powershell.exe");
        }

        // THIS METHOD IS REWRITTEN TO BE MORE ROBUST
        public static void SetAuditPolicy(bool enable)
        {
            string subcategory = "\"Filtering Platform Connection\"";
            if (enable)
            {
                string arguments = $"/set /subcategory:{subcategory} /failure:enable";
                Execute(arguments, "auditpol.exe");
            }
            else
            {
                string disableFailureArgs = $"/set /subcategory:{subcategory} /failure:disable";
                Execute(disableFailureArgs, "auditpol.exe");
                string disableSuccessArgs = $"/set /subcategory:{subcategory} /success:disable";
                Execute(disableSuccessArgs, "auditpol.exe");
            }
        }

        private static void Execute(string arguments, string fileName)
        {
            var startInfo = new ProcessStartInfo()
            {
                FileName = fileName,
                Arguments = arguments,
                UseShellExecute = false,
                CreateNoWindow = true,
                RedirectStandardError = true,
                RedirectStandardOutput = true
            };
            using (var process = Process.Start(startInfo))
            {
                if (process == null)
                {
                    MessageBox.Show("Failed to start administrative process.", "Execution Error", MessageBoxButton.OK, MessageBoxImage.Error);
                    return;
                }

                string errors = process.StandardError.ReadToEnd();
                process.WaitForExit();

                if (!string.IsNullOrEmpty(errors) && !errors.Contains("0x00000490"))
                {
                    MessageBox.Show("An error occurred during an administrative task:\n\n" + errors, "Admin Task Error", MessageBoxButton.OK, MessageBoxImage.Warning);
                }
            }
        }
    }
}

--------------------------------------------------------------------------------
// File: App.xaml.cs
--------------------------------------------------------------------------------
ï»¿using System;
using System.Linq;
using System.Windows;

namespace MinimalFirewall
{
    public partial class App : Application
    {
        public void ApplyTheme(string themeName)
        {
            var themeFileName = (themeName == "Dark") ? "DarkTheme" : "LightTheme";

            var existingTheme = Resources.MergedDictionaries.FirstOrDefault(d => d.Source != null && d.Source.OriginalString.Contains("Theme.xaml"));
            if (existingTheme != null)
            {
                Resources.MergedDictionaries.Remove(existingTheme);
            }

            var newTheme = new ResourceDictionary() { Source = new Uri($"Themes/{themeFileName}.xaml", UriKind.Relative) };
            Resources.MergedDictionaries.Add(newTheme);
        }
    }
}

--------------------------------------------------------------------------------
// File: PathResolver.cs
--------------------------------------------------------------------------------
ï»¿using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;

namespace MinimalFirewall
{
    public static class PathResolver
    {
        private static readonly Dictionary<string, string> _deviceMap = new Dictionary<string, string>();

        static PathResolver()
        {
            // Pre-load the device-to-drive-letter map when the application starts.
            var driveLetters = Directory.GetLogicalDrives().Select(d => d.Substring(0, 2));
            foreach (var drive in driveLetters)
            {
                var targetPath = new StringBuilder(260);
                if (QueryDosDevice(drive, targetPath, targetPath.Capacity) != 0)
                {
                    _deviceMap[targetPath.ToString()] = drive;
                }
            }
        }

        public static string ConvertDevicePathToDrivePath(string devicePath)
        {
            if (string.IsNullOrEmpty(devicePath))
            {
                return devicePath;
            }

            // Check if the path is already a standard drive path
            if (devicePath.Length > 1 && devicePath[1] == ':' && char.IsLetter(devicePath[0]))
            {
                return devicePath;
            }

            var matchingDevice = _deviceMap.Keys.FirstOrDefault(d => devicePath.StartsWith(d, StringComparison.OrdinalIgnoreCase));
            if (matchingDevice != null)
            {
                return _deviceMap[matchingDevice] + devicePath.Substring(matchingDevice.Length);
            }

            return devicePath; // Return original path if no mapping is found
        }

        [DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
        private static extern uint QueryDosDevice(string lpDeviceName, StringBuilder lpTargetPath, int ucchMax);
    }
}

--------------------------------------------------------------------------------
// File: EditRuleWindow.xaml.cs
--------------------------------------------------------------------------------
ï»¿using System.Collections.Generic;
using System.Linq;
using System.Windows;
using System.Windows.Input;

namespace MinimalFirewall
{
    public partial class EditRuleWindow : Window
    {
        public string SelectedAction { get; private set; } = string.Empty;

        public EditRuleWindow(List<string> appNames)
        {
            InitializeComponent();
            Owner = Application.Current.MainWindow;

            if (appNames.Count == 1)
            {
                AppNameTextBlock.Text = $"Editing rule for: {appNames.First()}";
            }
            else
            {
                AppNameTextBlock.Text = $"Editing rules for {appNames.Count} applications.";
            }
        }

        private void OkButton_Click(object sender, RoutedEventArgs e)
        {
            if (AllowAllRadio.IsChecked == true) SelectedAction = "Allow (All)";
            else if (AllowOutboundRadio.IsChecked == true) SelectedAction = "Allow (Outbound)";
            else if (AllowInboundRadio.IsChecked == true) SelectedAction = "Allow (Inbound)";
            else if (BlockAllRadio.IsChecked == true) SelectedAction = "Block (All)";
            else if (BlockOutboundRadio.IsChecked == true) SelectedAction = "Block (Outbound)";
            else if (BlockInboundRadio.IsChecked == true) SelectedAction = "Block (Inbound)";

            this.DialogResult = true;
        }

        private void CloseButton_Click(object sender, RoutedEventArgs e)
        {
            this.Close();
        }

        private void TitleBar_MouseLeftButtonDown(object sender, MouseButtonEventArgs e)
        {
            DragMove();
        }
    }
}

--------------------------------------------------------------------------------
// File: EditRuleWindow.xaml
--------------------------------------------------------------------------------
ï»¿<Window x:Class="MinimalFirewall.EditRuleWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
        xmlns:local="clr-namespace:MinimalFirewall"
        mc:Ignorable="d"
        Title="Edit Rule" 
        Width="450"
        SizeToContent="Height"
        WindowStartupLocation="CenterOwner"
        ResizeMode="NoResize"
        MaxHeight="600"
        WindowStyle="None" AllowsTransparency="True" Background="Transparent">

    <Window.Resources>
        <Style x:Key="CaptionButtonStyle" TargetType="Button">
            <Setter Property="Width" Value="46"/>
            <Setter Property="Height" Value="32"/>
            <Setter Property="Background" Value="Transparent"/>
            <Setter Property="Foreground" Value="{DynamicResource App.Text.Default}"/>
            <Setter Property="BorderThickness" Value="0"/>
            <Setter Property="VerticalAlignment" Value="Top"/>
            <Setter Property="Template">
                <Setter.Value>
                    <ControlTemplate TargetType="{x:Type Button}">
                        <Border Background="{TemplateBinding Background}" Name="border">
                            <ContentPresenter HorizontalAlignment="Center" VerticalAlignment="Center"/>
                        </Border>
                    </ControlTemplate>
                </Setter.Value>
            </Setter>
            <Style.Triggers>
                <Trigger Property="IsMouseOver" Value="True">
                    <Setter Property="Background" Value="{DynamicResource CaptionButton.Background.MouseOver}" />
                </Trigger>
            </Style.Triggers>
        </Style>
        <Style x:Key="CloseButtonStyle" BasedOn="{StaticResource CaptionButtonStyle}" TargetType="Button">
            <Style.Triggers>
                <Trigger Property="IsMouseOver" Value="True">
                    <Setter Property="Background" Value="#E81123" />
                    <Setter Property="Foreground" Value="White" />
                </Trigger>
            </Style.Triggers>
        </Style>
    </Window.Resources>

    <Border BorderBrush="{DynamicResource App.Border.Default}" BorderThickness="1" Background="{DynamicResource App.Window.Background}">
        <DockPanel>
            <Border DockPanel.Dock="Top" Background="{DynamicResource TitleBar.Background.Default}" BorderBrush="{DynamicResource App.Border.Default}" BorderThickness="0,0,0,1" Height="30" MouseLeftButtonDown="TitleBar_MouseLeftButtonDown">
                <Grid>
                    <TextBlock Text="{Binding Title, RelativeSource={RelativeSource AncestorType=Window}}" VerticalAlignment="Center" HorizontalAlignment="Left" Margin="10,0,0,0" Foreground="{DynamicResource App.Text.Default}"/>
                    <Button Content="âœ•" Style="{StaticResource CloseButtonStyle}" Height="30" HorizontalAlignment="Right" Click="CloseButton_Click" />
                </Grid>
            </Border>

            <Grid Margin="15">
                <Grid.RowDefinitions>
                    <RowDefinition Height="Auto"/>
                    <RowDefinition Height="*"/>
                    <RowDefinition Height="Auto"/>
                </Grid.RowDefinitions>

                <TextBlock x:Name="AppNameTextBlock" Grid.Row="0" FontWeight="Bold" FontSize="14" TextWrapping="Wrap"
                           Text="Editing rule for:" Foreground="{DynamicResource App.Text.Default}"/>

                <StackPanel Grid.Row="1" VerticalAlignment="Center" Margin="0,15,0,0">
                    <RadioButton x:Name="AllowAllRadio" Content="Allow (All)" IsChecked="True" FontSize="14" Margin="0,5"/>
                    <RadioButton x:Name="AllowOutboundRadio" Content="Allow (Outbound)" FontSize="14" Margin="0,5"/>
                    <RadioButton x:Name="AllowInboundRadio" Content="Allow (Inbound)" FontSize="14" Margin="0,5"/>
                    <Separator Margin="0,10"/>
                    <RadioButton x:Name="BlockAllRadio" Content="Block (All)" FontSize="14" Margin="0,5"/>
                    <RadioButton x:Name="BlockOutboundRadio" Content="Block (Outbound)" FontSize="14" Margin="0,5"/>
                    <RadioButton x:Name="BlockInboundRadio" Content="Block (Inbound)" FontSize="14" Margin="0,5"/>
                </StackPanel>

                <StackPanel Grid.Row="2" Orientation="Horizontal" HorizontalAlignment="Right" Margin="0,20,0,0">
                    <Button Content="OK" Width="80" Margin="5" Click="OkButton_Click" IsDefault="True"/>
                    <Button Content="Cancel" Width="80" Margin="5" IsCancel="True"/>
                </StackPanel>
            </Grid>
        </DockPanel>
    </Border>
</Window>

--------------------------------------------------------------------------------
// File: StartupService.cs
--------------------------------------------------------------------------------
ï»¿using Microsoft.Win32;
using System;
using System.Reflection;

namespace MinimalFirewall
{
    public class StartupService
    {
        private const string RegistryKeyPath = "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run";
        private readonly string _appName;
        private readonly string _appPath;

        public StartupService()
        {
            _appName = Assembly.GetExecutingAssembly().GetName().Name;
            _appPath = Assembly.GetExecutingAssembly().Location;
        }

        public void SetStartup(bool isEnabled)
        {
            try
            {
                using (RegistryKey key = Registry.CurrentUser.OpenSubKey(RegistryKeyPath, true))
                {
                    if (key == null) return;

                    if (isEnabled)
                    {
                        // To ensure the path is correct and enclosed in quotes
                        key.SetValue(_appName, $"\"{_appPath}\"");
                    }
                    else
                    {
                        if (key.GetValue(_appName) != null)
                        {
                            key.DeleteValue(_appName, false);
                        }
                    }
                }
            }
            catch (Exception)
            {
                // Errors writing to registry should be handled gracefully
                // Optionally, log the exception
            }
        }
    }
}

--------------------------------------------------------------------------------
// File: MinimalFirewall.csproj.user
--------------------------------------------------------------------------------
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <ProjectView>ShowAllFiles</ProjectView>
  </PropertyGroup>
</Project>

--------------------------------------------------------------------------------
// File: App.xaml
--------------------------------------------------------------------------------
ï»¿<Application x:Class="MinimalFirewall.App"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:local="clr-namespace:MinimalFirewall"
             StartupUri="MainWindow.xaml">
    <Application.Resources>
        <ResourceDictionary>
            <ResourceDictionary.MergedDictionaries>
                <ResourceDictionary Source="Themes/Generic.xaml"/>
                <ResourceDictionary Source="Themes/LightTheme.xaml"/>
            </ResourceDictionary.MergedDictionaries>
        </ResourceDictionary>
    </Application.Resources>
</Application>

--------------------------------------------------------------------------------
// File: App.config
--------------------------------------------------------------------------------
ï»¿<?xml version="1.0" encoding="utf-8"?>
<configuration>
	<startup>
		<supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.8" />
	</startup>
	<runtime>
		<assemblyBinding xmlns="urn:schemas-microsoft-com:asm.v1">
			<dependentAssembly>
				<assemblyIdentity name="System.Runtime.CompilerServices.Unsafe" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
				<bindingRedirect oldVersion="0.0.0.0-4.0.6.0" newVersion="4.0.6.0" />
			</dependentAssembly>
			<dependentAssembly>
				<assemblyIdentity name="System.Memory" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
				<bindingRedirect oldVersion="0.0.0.0-4.0.1.1" newVersion="4.0.1.1" />
			</dependentAssembly>
			<dependentAssembly>
				<assemblyIdentity name="System.Buffers" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
				<bindingRedirect oldVersion="0.0.0.0-4.0.3.0" newVersion="4.0.3.0" />
			</dependentAssembly>
			<dependentAssembly>
				<assemblyIdentity name="System.Threading.Tasks.Extensions" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
				<bindingRedirect oldVersion="0.0.0.0-4.2.0.1" newVersion="4.2.0.1" />
			</dependentAssembly>
			<dependentAssembly>
				<assemblyIdentity name="System.Text.Encodings.Web" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
				<bindingRedirect oldVersion="0.0.0.0-4.0.5.1" newVersion="4.0.5.1" />
			</dependentAssembly>
			<dependentAssembly>
				<assemblyIdentity name="System.ValueTuple" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
				<bindingRedirect oldVersion="0.0.0.0-4.0.3.0" newVersion="4.0.3.0" />
			</dependentAssembly>
		</assemblyBinding>
	</runtime>
</configuration>


--------------------------------------------------------------------------------
// File: packages.config
--------------------------------------------------------------------------------
ï»¿<?xml version="1.0" encoding="utf-8"?>
<packages>
	<package id="Microsoft.Bcl.AsyncInterfaces" version="1.1.1" targetFramework="net48" />
	<package id="System.Buffers" version="4.5.1" targetFramework="net48" />
	<package id="System.Memory" version="4.5.4" targetFramework="net48" />
	<package id="System.Numerics.Vectors" version="4.5.0" targetFramework="net48" />
	<package id="System.Runtime.CompilerServices.Unsafe" version="4.7.1" targetFramework="net48" />
	<package id="System.Text.Encodings.Web" version="4.7.2" targetFramework="net48" />
	<package id="System.Text.Json" version="4.7.2" targetFramework="net48" />
	<package id="System.Threading.Tasks.Extensions" version="4.5.4" targetFramework="net48" />
	<package id="System.ValueTuple" version="4.5.0" targetFramework="net48" />
</packages>


--------------------------------------------------------------------------------
// File: app.manifest
--------------------------------------------------------------------------------
<?xml version="1.0" encoding="utf-8"?>
<assembly manifestVersion="1.0" xmlns="urn:schemas-microsoft-com:asm.v1">
	<assemblyIdentity version="1.0.0.0" name="MinimalFirewall.app"/>

	<trustInfo xmlns="urn:schemas-microsoft-com:asm.v2">
		<security>
			<requestedPrivileges xmlns="urn:schemas-microsoft-com:asm.v3">
				<requestedExecutionLevel  level="requireAdministrator" uiAccess="false" />
			</requestedPrivileges>
		</security>
	</trustInfo>

	<compatibility xmlns="urn:schemas-microsoft-com:compatibility.v1">
		<application>
			<supportedOS Id="{8e0f7a12-bfb3-4fe8-b9a5-48fd50a15a9a}" />
		</application>
	</compatibility>

</assembly>

--------------------------------------------------------------------------------
// File: UserActivityLogger.cs
--------------------------------------------------------------------------------
ï»¿using System;
using System.IO;

namespace MinimalFirewall
{
    public class UserActivityLogger
    {
        private readonly string _logFilePath;
        public bool IsEnabled { get; set; }

        public UserActivityLogger()
        {
            string baseDirectory = AppDomain.CurrentDomain.BaseDirectory;
            _logFilePath = Path.Combine(baseDirectory, "user_log.txt");
        }

        public void Log(string action, string details)
        {
            if (!IsEnabled)
            {
                return;
            }

            try
            {
                string timestamp = DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss");
                string logEntry = $"[{timestamp}] {action}: {details}{Environment.NewLine}";
                File.AppendAllText(_logFilePath, logEntry);
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"[FATAL LOGGING ERROR] {ex.Message}");
            }
        }
    }
}

--------------------------------------------------------------------------------
// File: FolderPicker.cs
--------------------------------------------------------------------------------
ï»¿using System;
using System.IO;
using System.Runtime.InteropServices;
using System.Windows;
using System.Windows.Interop;

namespace MinimalFirewall
{
    public static class FolderPicker
    {
        public static bool TryPickFolder(out string path, string initialDirectory = null)
        {
            var dialog = (IFileOpenDialog)new FileOpenDialog();
            try
            {
                if (!string.IsNullOrEmpty(initialDirectory) && Directory.Exists(initialDirectory))
                {
                    // Check if SHCreateItemFromParsingName is available before calling
                    SHCreateItemFromParsingName(initialDirectory, IntPtr.Zero, typeof(IShellItem).GUID, out var initialFolder);
                    if (initialFolder != null)
                    {
                        dialog.SetFolder(initialFolder);
                    }
                }

                dialog.SetOptions(FOS.FOS_PICKFOLDERS | FOS.FOS_FORCEFILESYSTEM);
                var hwnd = Application.Current.MainWindow == null ? IntPtr.Zero : new WindowInteropHelper(Application.Current.MainWindow).Handle;

                if (dialog.Show(hwnd) == 0)
                {
                    dialog.GetResult(out var result);
                    result.GetDisplayName(SIGDN.SIGDN_FILESYSPATH, out path);
                    Marshal.ReleaseComObject(result);
                    return true;
                }
            }
            catch (Exception ex)
            {
                MessageBox.Show("Could not open folder picker.\n\nError: " + ex.Message, "Error", MessageBoxButton.OK, MessageBoxImage.Error);
            }
            finally
            {
                Marshal.ReleaseComObject(dialog);
            }

            path = null;
            return false;
        }

        #region COM Interop Definitions

        [DllImport("shell32.dll", CharSet = CharSet.Unicode, SetLastError = true)]
        private static extern int SHCreateItemFromParsingName([MarshalAs(UnmanagedType.LPWStr)] string pszPath, IntPtr pbc, [In, MarshalAs(UnmanagedType.LPStruct)] Guid riid, out IShellItem ppv);

        [ComImport, Guid("DC1C5A9C-E88A-4dde-A5A1-60F82A20AEF7")]
        private class FileOpenDialog { }

        [ComImport, Guid("42f85136-db7e-439c-85f1-e4075d135fc8"), InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
        private interface IFileOpenDialog
        {
            [PreserveSig]
            int Show(IntPtr parent);
            void SetFileTypes(); void SetFileTypeIndex(); void GetFileTypeIndex(); void Advise(); void Unadvise();
            void SetOptions([In] FOS fos);
            void GetOptions(); void SetDefaultFolder();
            void SetFolder(IShellItem psi);
            void GetFolder(); void GetCurrentSelection(); void SetFileName(); void GetFileName();
            void SetTitle([In, MarshalAs(UnmanagedType.LPWStr)] string pszTitle);
            void SetOkButtonLabel(); void SetFileNameLabel();
            void GetResult(out IShellItem ppsi);
            void AddPlace(); void SetDefaultExtension(); void Close(); void SetClientGuid(); void ClearClientData(); void SetFilter();
        }

        [ComImport, Guid("43826D1E-E718-42EE-BC55-A1E261C37BFE"), InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
        private interface IShellItem
        {
            void BindToHandler(IntPtr pbc, [In, MarshalAs(UnmanagedType.LPStruct)] Guid bhid, [In, MarshalAs(UnmanagedType.LPStruct)] Guid riid, out IntPtr ppv);
            void GetParent(out IShellItem ppsi);
            void GetDisplayName([In] SIGDN sigdnName, [MarshalAs(UnmanagedType.LPWStr)] out string ppszName);
            void GetAttributes([In] uint sfgaoMask, out uint psfgaoAttribs);
            void Compare(IShellItem psi, uint hint, out int piOrder);
        }

        [Flags]
        private enum FOS : uint { FOS_PICKFOLDERS = 0x00000020, FOS_FORCEFILESYSTEM = 0x00000040, }
        private enum SIGDN : uint { SIGDN_FILESYSPATH = 0x80058000, }
        #endregion
    }
}

--------------------------------------------------------------------------------
// File: RelayCommand.cs
--------------------------------------------------------------------------------
ï»¿using System;
using System.Windows.Input;

namespace MinimalFirewall
{
    public class RelayCommand<T> : ICommand
    {
        private readonly Action<T> _execute;

        public RelayCommand(Action<T> execute)
        {
            _execute = execute;
        }

        public bool CanExecute(object parameter)
        {
            return true;
        }

        public void Execute(object parameter)
        {
            if (parameter is T t)
            {
                _execute(t);
            }
        }

        public event EventHandler CanExecuteChanged
        {
            add { CommandManager.RequerySuggested += value; }
            remove { CommandManager.RequerySuggested -= value; }
        }
    }

    public class RelayCommand : ICommand
    {
        private readonly Action _execute;

        public RelayCommand(Action execute)
        {
            _execute = execute;
        }

        public bool CanExecute(object parameter)
        {
            return true;
        }

        public void Execute(object parameter)
        {
            _execute();
        }

        public event EventHandler CanExecuteChanged
        {
            add { CommandManager.RequerySuggested += value; }
            remove { CommandManager.RequerySuggested -= value; }
        }
    }
}

--------------------------------------------------------------------------------
// File: StatusWindow.xaml.cs
--------------------------------------------------------------------------------
ï»¿using System.Windows;

namespace MinimalFirewall
{
    public partial class StatusWindow : Window
    {
        public StatusWindow(string title)
        {
            InitializeComponent();
            this.Title = title;
            this.Owner = Application.Current.MainWindow;
        }

        public void Complete(string message)
        {
            this.StatusTextBlock.Text = message;
            this.ProgressBar.IsIndeterminate = false;
            this.ProgressBar.Value = 100;
            this.OkButton.Visibility = Visibility.Visible;
            this.ProgressBar.Visibility = Visibility.Collapsed;
            this.OkButton.Focus();
            this.Title = "Scan Complete";
        }

        private void OkButton_Click(object sender, RoutedEventArgs e)
        {
            // A window shown with .Show() cannot have its DialogResult set.
            // We just need to close it.
            this.Close();
        }
    }
}


