CONTEXT SUMMARY:
Total Files: 72
------------------------------
- AdaptiveUI.cs
- App.config
- app.manifest
- Appdata.cs
- AppSettings.cs
- AuditControl.cs
- AuditControl.Designer.cs
- BackgroundFirewallTaskService.cs
- BrowseServicesForm.cs
- BrowseServicesForm.Designer.cs
- CreateAdvancedRuleForm.cs
- CreateAdvancedRuleForm.Designer.cs
- CreateProgramRuleForm.cs
- CreateProgramRuleForm.Designer.cs
- DarkModeCS.cs
- DashboardControl.cs
- DashboardControl.Designer.cs
- DataModels.cs
- FirewallActionService.cs
- FirewallDataService.cs
- FirewallEventListenerService.cs
- FirewallGroups.cs
- FirewallRuleBuilderExtensions.cs
- FirewallRuleService.cs
- FirewallSentryService.cs
- FirewallTraffic.cs
- FlatComboBox.cs
- FlatProgressBar.cs
- FlatTabControl.cs
- ForeignRuleTracker.cs
- GroupsControl.cs
- GroupsControl.Designer.cs
- IconService.cs
- LiveConnectionsControl.cs
- LiveConnectionsControl.Designer.cs
- logo.ico
- MainForm.cs
- MainForm.Designer.cs
- MainViewModel.cs
- ManagePublishersForm.cs
- ManagePublishersForm.Designer.cs
- Messenger.cs
- MFWConstants.cs
- MinimalFirewall-NET8.csproj
- MinimalFirewall-WindowsStore.sln
- NotifierForm.cs
- NotifierForm.Designer.cs
- ObservableViewModel.cs
- Program.cs
- PublisherWhitelistService.cs
- RulesControl.cs
- RulesControl.Designer.cs
- RuleWizardForm.cs
- RuleWizardForm.Designer.cs
- SettingsControl.cs
- SettingsControl.Designer.cs
- SignatureValidationService.cs
- SortableBindingList.cs
- StatusForm.cs
- StatusForm.Designer.cs
- SystemDiscoveryService.cs
- TemporaryRuleManager.cs
- TypedObjects.cs
- UserActivityLogger.cs
- Utilities.cs
- UtilityServices.cs
- UwpService.cs
- WildcardCreatorForm.cs
- WildcardCreatorForm.Designer.cs
- WildcardRulesControl.cs
- WildcardRulesControl.Designer.cs
- WildCardRuleService.cs
==================================================

--------------------------------------------------
// Full Path: C:/Users/anon/PROGRAMMING/C#/SimpleFirewall/VS Minimal Firewall/MinimalFirewall-NET8/Backups/v2.5.5 - ws/2.5.5.6 - security vulnerability fix 3/AdaptiveUI.cs
--------------------------------------------------------------------------------
// File: AdaptiveUI.cs
using System.ComponentModel;
using System.Runtime.CompilerServices;

namespace MinimalFirewall
{

    public struct ProtocolTypes : IEquatable<ProtocolTypes>
    {
        public static ProtocolTypes Any { get; } = new ProtocolTypes("Any", 256, false, false);
        public static ProtocolTypes TCP { get; } = new ProtocolTypes("TCP", 6, true, false);
        public static ProtocolTypes UDP { get; } = new ProtocolTypes("UDP", 17, true, false);
        public static ProtocolTypes ICMPv4 { get; } = new ProtocolTypes("ICMPv4", 1, false, true);
        public static ProtocolTypes ICMPv6 { get; } = new ProtocolTypes("ICMPv6", 58, false, true);
        public static ProtocolTypes IGMP { get; } = new ProtocolTypes("IGMP", 2, false, false);

        public string Name { get; }
        public short Value { get; }
        public bool SupportsPorts { get; }
        public bool SupportsIcmp { get; }

        private ProtocolTypes(string name, short value, bool supportsPorts, bool supportsIcmp)
        {
            Name = name;
            Value = value;
            SupportsPorts = supportsPorts;
            SupportsIcmp = supportsIcmp;
        }

        public override string ToString() => Name;
        public bool Equals(ProtocolTypes other) => this.Value == other.Value;
        public override bool Equals(object? obj) => obj is ProtocolTypes other && Equals(other);
        public override int GetHashCode() => Value.GetHashCode();
    }


    public class FirewallRuleViewModel : INotifyPropertyChanged
    {
        private ProtocolTypes _selectedProtocol;
        public ProtocolTypes SelectedProtocol
        {
            get => _selectedProtocol;
            set
            {
                if (_selectedProtocol.Equals(value)) return;
                _selectedProtocol = value;

                OnPropertyChanged();
                OnPropertyChanged(nameof(IsPortSectionVisible));
                OnPropertyChanged(nameof(IsIcmpSectionVisible));
            }
        }

        public bool IsPortSectionVisible => SelectedProtocol.SupportsPorts;
        public bool IsIcmpSectionVisible => SelectedProtocol.SupportsIcmp;

        public FirewallRuleViewModel()
        {
            SelectedProtocol = ProtocolTypes.Any;
        }

        public event PropertyChangedEventHandler? PropertyChanged;
        protected virtual void OnPropertyChanged([CallerMemberName] string? propertyName = null)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }
    }
}

--------------------------------------------------
// Full Path: C:/Users/anon/PROGRAMMING/C#/SimpleFirewall/VS Minimal Firewall/MinimalFirewall-NET8/Backups/v2.5.5 - ws/2.5.5.6 - security vulnerability fix 3/App.config
--------------------------------------------------------------------------------
<?xml version="1.0" encoding="utf-8" ?>
<configuration>
</configuration>

--------------------------------------------------
// Full Path: C:/Users/anon/PROGRAMMING/C#/SimpleFirewall/VS Minimal Firewall/MinimalFirewall-NET8/Backups/v2.5.5 - ws/2.5.5.6 - security vulnerability fix 3/app.manifest
--------------------------------------------------------------------------------
<?xml version="1.0" encoding="utf-8"?>
<assembly manifestVersion="1.0" xmlns="urn:schemas-microsoft-com:asm.v1">
	<assemblyIdentity version="1.0.0.0" name="MinimalFirewall.app"/>

	<application xmlns="urn:schemas-microsoft-com:asm.v3">
		<windowsSettings>
			<dpiAware xmlns="http://schemas.microsoft.com/SMI/2005/WindowsSettings">true/PM</dpiAware>
			<dpiAwareness xmlns="http://schemas.microsoft.com/SMI/2016/WindowsSettings">PerMonitorV2, System</dpiAwareness>
		</windowsSettings>
	</application>

	<trustInfo xmlns="urn:schemas-microsoft-com:asm.v2">
		<security>
			<requestedPrivileges xmlns="urn:schemas-microsoft-com:asm.v3">
				<requestedExecutionLevel level="requireAdministrator" uiAccess="false" />
			</requestedPrivileges>
		</security>
	</trustInfo>

	<compatibility xmlns="urn:schemas-microsoft-com:compatibility.v1">
		<application>
			<supportedOS Id="{8e0f7a12-bfb3-4fe8-b9a5-48fd50a15a9a}" />
			<supportedOS Id="{1f676c76-80e1-4239-95bb-83d0f6d0da78}" />
			<supportedOS Id="{4a2f28e3-53b9-4441-ba9c-d69d4a4a6e38}" />
			<supportedOS Id="{35138b9a-5d96-4fbd-8e2d-a2440225f93a}" />
			<supportedOS Id="{e2011457-1546-43c5-a5fe-008deee3d3f0}" />
		</application>
	</compatibility>

</assembly>

--------------------------------------------------
// Full Path: C:/Users/anon/PROGRAMMING/C#/SimpleFirewall/VS Minimal Firewall/MinimalFirewall-NET8/Backups/v2.5.5 - ws/2.5.5.6 - security vulnerability fix 3/Appdata.cs
--------------------------------------------------------------------------------
// File: Appdata.cs
using System.Diagnostics;
using System.IO;

namespace MinimalFirewall
{
    internal static class ConfigPathManager
    {
        private static readonly string _exeDirectory = Path.GetDirectoryName(Environment.ProcessPath)!;
        private static readonly string _appDataDirectory = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData), "MinimalFirewall");
        private static bool _useAppDataStorage = false;

        private static readonly List<string> _managedConfigFiles = new List<string>
        {
            "wildcard_rules.json",
            "foreign_rules_baseline.json",
            "temporary_rules.json",
            "debug_log.txt",
            "changelog.json",
            "uwp_apps.json",
            "trusted_publishers.json"
        };

        public static void Initialize(AppSettings settings)
        {
            _useAppDataStorage = settings.UseAppDataStorage;
            if (_useAppDataStorage)
            {
                try
                {
                    Directory.CreateDirectory(_appDataDirectory);
                }
                catch (Exception ex)
                {
                    Debug.WriteLine($"[ERROR] Could not create AppData directory: {ex.Message}");
                    _useAppDataStorage = false; 
                }
            }
        }

        public static string GetConfigPath(string fileName)
        {
            string basePath = _useAppDataStorage ? _appDataDirectory : _exeDirectory;
            return Path.Combine(basePath, fileName);
        }

        public static string GetSettingsPath()
        {
            return Path.Combine(_exeDirectory, "settings.json");
        }

        public static string GetExeDirectory() => _exeDirectory;
        public static string GetAppDataDirectory() => _appDataDirectory;
        public static List<string> GetManagedConfigFileNames() => _managedConfigFiles;
    }
}

--------------------------------------------------
// Full Path: C:/Users/anon/PROGRAMMING/C#/SimpleFirewall/VS Minimal Firewall/MinimalFirewall-NET8/Backups/v2.5.5 - ws/2.5.5.6 - security vulnerability fix 3/AppSettings.cs
--------------------------------------------------------------------------------
// File: AppSettings.cs
using System.ComponentModel;
using System.Diagnostics;
using System.Drawing;
using System.IO;
using System.Runtime.CompilerServices;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.Windows.Forms;

namespace MinimalFirewall
{
    public class AppSettings : INotifyPropertyChanged
    {
        private static readonly string _configPath = ConfigPathManager.GetSettingsPath();
        private bool _isPopupsEnabled = false;
        private bool _isLoggingEnabled;
        private string _theme = "Dark";
        private bool _startOnSystemStartup;
        private bool _closeToTray = true;
        private bool _useAppDataStorage = false;
        private int _autoRefreshIntervalMinutes = 10;
        private bool _isTrafficMonitorEnabled = false;
        private bool _showAppIcons = true;
        private bool _autoAllowSystemTrusted = false;
        private bool _alertOnForeignRules = true;
        private bool _filterPrograms = true;
        private bool _filterServices = true;
        private bool _filterUwp = true;
        private bool _filterWildcards = true;
        private bool _filterSystem = false;
        private string _rulesSearchText = "";
        private int _rulesSortColumn = -1;
        private int _rulesSortOrder = 0;
        private string _auditSearchText = "";
        private int _auditSortColumn = -1;
        private int _auditSortOrder = 0;
        private int _liveConnectionsSortColumn = -1;
        private int _liveConnectionsSortOrder = 0;

        public bool IsPopupsEnabled { get => _isPopupsEnabled; set => SetField(ref _isPopupsEnabled, value); }
        public bool IsLoggingEnabled { get => _isLoggingEnabled; set => SetField(ref _isLoggingEnabled, value); }
        public string Theme { get => _theme; set => SetField(ref _theme, value); }
        public bool StartOnSystemStartup { get => _startOnSystemStartup; set => SetField(ref _startOnSystemStartup, value); }
        public bool CloseToTray { get => _closeToTray; set => SetField(ref _closeToTray, value); }
        public bool UseAppDataStorage { get => _useAppDataStorage; set => SetField(ref _useAppDataStorage, value); }
        public int AutoRefreshIntervalMinutes { get => _autoRefreshIntervalMinutes; set => SetField(ref _autoRefreshIntervalMinutes, value); }
        public bool IsTrafficMonitorEnabled { get => _isTrafficMonitorEnabled; set => SetField(ref _isTrafficMonitorEnabled, value); }
        public bool ShowAppIcons { get => _showAppIcons; set => SetField(ref _showAppIcons, value); }
        public bool AutoAllowSystemTrusted { get => _autoAllowSystemTrusted; set => SetField(ref _autoAllowSystemTrusted, value); }
        public bool AlertOnForeignRules { get => _alertOnForeignRules; set => SetField(ref _alertOnForeignRules, value); }
        public bool FilterPrograms { get => _filterPrograms; set => SetField(ref _filterPrograms, value); }
        public bool FilterServices { get => _filterServices; set => SetField(ref _filterServices, value); }
        public bool FilterUwp { get => _filterUwp; set => SetField(ref _filterUwp, value); }
        public bool FilterWildcards { get => _filterWildcards; set => SetField(ref _filterWildcards, value); }
        public bool FilterSystem { get => _filterSystem; set => SetField(ref _filterSystem, value); }
        public string RulesSearchText { get => _rulesSearchText; set => SetField(ref _rulesSearchText, value); }
        public int RulesSortColumn { get => _rulesSortColumn; set => SetField(ref _rulesSortColumn, value); }
        public int RulesSortOrder { get => _rulesSortOrder; set => SetField(ref _rulesSortOrder, value); }
        public string AuditSearchText { get => _auditSearchText; set => SetField(ref _auditSearchText, value); }
        public int AuditSortColumn { get => _auditSortColumn; set => SetField(ref _auditSortColumn, value); }
        public int AuditSortOrder { get => _auditSortOrder; set => SetField(ref _auditSortOrder, value); }
        public int LiveConnectionsSortColumn { get => _liveConnectionsSortColumn; set => SetField(ref _liveConnectionsSortColumn, value); }
        public int LiveConnectionsSortOrder { get => _liveConnectionsSortOrder; set => SetField(ref _liveConnectionsSortOrder, value); }

        public Point WindowLocation { get; set; } = new Point(100, 100);
        public Size WindowSize { get; set; } = new Size(1280, 800);
        public int WindowState { get; set; } = (int)FormWindowState.Maximized;

        public event PropertyChangedEventHandler? PropertyChanged;
        protected void OnPropertyChanged(string propertyName)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }

        protected bool SetField<T>(ref T field, T value, [CallerMemberName] string? propertyName = null)
        {
            if (EqualityComparer<T>.Default.Equals(field, value)) return false;
            field = value;
            OnPropertyChanged(propertyName!);
            Save();
            return true;
        }

        public void Save()
        {
            try
            {
                string json = JsonSerializer.Serialize(this, AppSettingsJsonContext.Default.AppSettings);
                File.WriteAllText(_configPath, json);
            }
            catch (Exception ex) when (ex is IOException or UnauthorizedAccessException)
            {
                Debug.WriteLine($"[ERROR] Failed to save settings due to a file error: {ex.Message}");
            }
        }

        public static AppSettings Load()
        {
            try
            {
                if (File.Exists(_configPath))
                {
                    string json = File.ReadAllText(_configPath);
                    return JsonSerializer.Deserialize(json, AppSettingsJsonContext.Default.AppSettings) ?? new AppSettings();
                }
            }
            catch (Exception ex) when (ex is IOException or UnauthorizedAccessException or JsonException)
            {
                Debug.WriteLine($"[ERROR] Failed to load settings: {ex.Message}");
            }
            return new AppSettings();
        }
    }

    [JsonSourceGenerationOptions(WriteIndented = true)]
    [JsonSerializable(typeof(AppSettings))]
    internal partial class AppSettingsJsonContext : JsonSerializerContext
    {
    }
}

--------------------------------------------------
// Full Path: C:/Users/anon/PROGRAMMING/C#/SimpleFirewall/VS Minimal Firewall/MinimalFirewall-NET8/Backups/v2.5.5 - ws/2.5.5.6 - security vulnerability fix 3/AuditControl.cs
--------------------------------------------------------------------------------
// File: AuditControl.cs
using MinimalFirewall.TypedObjects;
using System.ComponentModel;
using DarkModeForms;
using System.Diagnostics;
using System;
using System.Collections.Generic;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Windows.Forms;
namespace MinimalFirewall
{
    public partial class AuditControl : UserControl
    {
        private IContainer components = null;
        private MainViewModel _viewModel = null!;
        private AppSettings _appSettings = null!;
        private ForeignRuleTracker _foreignRuleTracker;
        private FirewallSentryService _firewallSentryService;
        private DarkModeCS _dm;
        private BindingSource _bindingSource;
        public AuditControl()
        {
            InitializeComponent();
            this.DoubleBuffered = true;
        }

        public void Initialize(
            MainViewModel viewModel,
            ForeignRuleTracker foreignRuleTracker,
            FirewallSentryService firewallSentryService,
            AppSettings appSettings,
            DarkModeCS dm)
        {
            _viewModel = viewModel;
            _foreignRuleTracker = foreignRuleTracker;
            _firewallSentryService = firewallSentryService;
            _appSettings = appSettings;
            _dm = dm;

            systemChangesDataGridView.AutoGenerateColumns = false;
            _bindingSource = new BindingSource();
            systemChangesDataGridView.DataSource = _bindingSource;
            _viewModel.SystemChangesUpdated += OnSystemChangesUpdated;

            auditSearchTextBox.Text = _appSettings.AuditSearchText;
        }

        private void OnSystemChangesUpdated()
        {
            if (this.InvokeRequired)
            {
                this.Invoke(OnSystemChangesUpdated);
                return;
            }
            ApplySearchFilter();
        }

        public void ApplyThemeFixes()
        {
            if (_dm == null) return;
            rebuildBaselineButton.FlatAppearance.BorderSize = 1;
            rebuildBaselineButton.FlatAppearance.BorderColor = _dm.OScolors.ControlDark;
            if (_dm.IsDarkMode)
            {
                rebuildBaselineButton.ForeColor = Color.White;
            }
            else
            {
                rebuildBaselineButton.ForeColor = SystemColors.ControlText;
            }
        }

        public void ApplySearchFilter()
        {
            if (systemChangesDataGridView is null || _viewModel?.SystemChanges is null) return;
            string searchText = auditSearchTextBox.Text;

            var filteredChanges = string.IsNullOrWhiteSpace(searchText) ?
                _viewModel.SystemChanges : _viewModel.SystemChanges.Where(c => c.Name.Contains(searchText, StringComparison.OrdinalIgnoreCase) ||
                                                    c.Description.Contains(searchText, StringComparison.OrdinalIgnoreCase) ||
                                                   c.ApplicationName.Contains(searchText, StringComparison.OrdinalIgnoreCase));

            _bindingSource.DataSource = new SortableBindingList<FirewallRuleChange>(filteredChanges.ToList());

            int sortCol = _appSettings.AuditSortColumn;
            var sortOrder = (SortOrder)_appSettings.AuditSortOrder;

            if (sortCol > -1 && sortOrder != SortOrder.None)
            {
                var column = systemChangesDataGridView.Columns[sortCol];
                var direction = sortOrder == SortOrder.Ascending ? ListSortDirection.Ascending : ListSortDirection.Descending;
                systemChangesDataGridView.Sort(column, direction);
            }

            _bindingSource.ResetBindings(false);
            systemChangesDataGridView.Refresh();
        }

        private void AcceptAllToolStripMenuItem_Click(object sender, EventArgs e)
        {
            if (_viewModel.SystemChanges.Count == 0) return;
            var result = DarkModeForms.Messenger.MessageBox($"Are you sure you want to accept all {_viewModel.SystemChanges.Count} detected changes? They will be hidden from this list.", "Confirm Accept All", MessageBoxButtons.YesNo, MessageBoxIcon.Warning);
            if (result == DialogResult.Yes)
            {
                _viewModel.AcceptAllForeignRules();
            }
        }

        private async void rebuildBaselineButton_Click(object sender, EventArgs e)
        {
            if (_viewModel != null)
            {
                var result = DarkModeForms.Messenger.MessageBox("This will clear all accepted (hidden) rules from the Audit list, causing them to be displayed again. Are you sure?", "Clear Accepted Rules", MessageBoxButtons.YesNo,
                                       MessageBoxIcon.Warning);
                if (result != DialogResult.Yes) return;

                await _viewModel.RebuildBaselineAsync();
            }
        }

        private void auditSearchTextBox_TextChanged(object sender, EventArgs e)
        {
            _appSettings.AuditSearchText = auditSearchTextBox.Text;
            ApplySearchFilter();
        }

        private void systemChangesDataGridView_ColumnHeaderMouseClick(object sender, DataGridViewCellMouseEventArgs e)
        {
            if (e.ColumnIndex < 0) return;

            var newColumn = systemChangesDataGridView.Columns[e.ColumnIndex];
            var sortOrder = systemChangesDataGridView.SortOrder;

            _appSettings.AuditSortColumn = e.ColumnIndex;
            _appSettings.AuditSortOrder = (int)sortOrder;
        }

        private bool TryGetSelectedAppContext(out string? appPath)
        {
            appPath = null;
            if (systemChangesDataGridView.SelectedRows.Count == 0)
            {
                return false;
            }

            if (systemChangesDataGridView.SelectedRows[0].DataBoundItem is FirewallRuleChange change)
            {
                appPath = change.ApplicationName;
            }

            return !string.IsNullOrEmpty(appPath);
        }

        private void auditContextMenu_Opening(object sender, CancelEventArgs e)
        {
            if (!TryGetSelectedAppContext(out string? appPath))
            {
                openFileLocationToolStripMenuItem.Enabled = false;
                return;
            }

            openFileLocationToolStripMenuItem.Enabled = !string.IsNullOrEmpty(appPath) && (File.Exists(appPath) || Directory.Exists(appPath));
        }

        private void openFileLocationToolStripMenuItem_Click(object sender, EventArgs e)
        {
            if (!TryGetSelectedAppContext(out string? appPath) || string.IsNullOrEmpty(appPath))
            {
                DarkModeForms.Messenger.MessageBox("The path for this item is not available.", "Path Not Found", MessageBoxButtons.OK, MessageBoxIcon.Error);
                return;
            }

            if (!File.Exists(appPath) && !Directory.Exists(appPath))
            {
                DarkModeForms.Messenger.MessageBox("The path for this item is no longer valid or does not exist.", "Path Not Found", MessageBoxButtons.OK, MessageBoxIcon.Error);
                return;
            }

            try
            {
                Process.Start("explorer.exe", $"/select, \"{appPath}\"");
            }
            catch (Exception ex) when (ex is Win32Exception or FileNotFoundException)
            {
                DarkModeForms.Messenger.MessageBox($"Could not open file location.\n\nError: {ex.Message}", "Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
            }
        }

        private void copyDetailsToolStripMenuItem_Click(object sender, EventArgs e)
        {
            if (systemChangesDataGridView.SelectedRows.Count > 0)
            {
                var details = new System.Text.StringBuilder();

                foreach (DataGridViewRow row in systemChangesDataGridView.SelectedRows)
                {
                    if (row.DataBoundItem is FirewallRuleChange change)
                    {
                        if (details.Length > 0)
                        {
                            details.AppendLine();
                            details.AppendLine();
                        }

                        details.AppendLine($"Type: Audited Change ({change.Type})");
                        details.AppendLine($"Rule Name: {change.Name}");
                        details.AppendLine($"Application: {change.ApplicationName}");
                        details.AppendLine($"Action: {change.Status}");
                        details.AppendLine($"Direction: {change.Rule.Direction}");
                        details.AppendLine($"Protocol: {change.ProtocolName}");
                        details.AppendLine($"Local Ports: {change.LocalPorts}");
                        details.AppendLine($"Remote Ports: {change.RemotePorts}");
                        details.AppendLine($"Local Addresses: {change.LocalAddresses}");
                        details.AppendLine($"Remote Addresses: {change.RemoteAddresses}");
                    }
                }

                if (details.Length > 0)
                {
                    Clipboard.SetText(details.ToString());
                }
            }
        }

        private void systemChangesDataGridView_CellContentClick(object sender, DataGridViewCellEventArgs e)
        {
            if (e.RowIndex < 0) return;
            var grid = (DataGridView)sender;
            var column = grid.Columns[e.ColumnIndex];

            if (grid.Rows[e.RowIndex].DataBoundItem is FirewallRuleChange change)
            {
                if (column is DataGridViewButtonColumn)
                {
                    if (column.Name == "acceptButtonColumn")
                    {
                        _viewModel.AcceptForeignRule(change);
                    }
                    else if (column.Name == "deleteButtonColumn")
                    {
                        _viewModel.DeleteForeignRule(change);
                    }
                }
            }
        }

        private void systemChangesDataGridView_CellFormatting(object sender, DataGridViewCellFormattingEventArgs e)
        {
            if (e.RowIndex < 0) return;
            var grid = (DataGridView)sender;
            if (grid.Rows[e.RowIndex].DataBoundItem is not FirewallRuleChange change) return;

            Color rowBackColor;
            switch (change.Type)
            {
                case ChangeType.New:
                    rowBackColor = Color.FromArgb(204, 255, 204);
                    break;
                case ChangeType.Modified:
                    rowBackColor = change.Status.Contains("Allow", StringComparison.OrdinalIgnoreCase)
                        ? Color.FromArgb(204, 255, 204)
                        : Color.FromArgb(255, 204, 204);
                    break;
                case ChangeType.Deleted:
                    rowBackColor = Color.FromArgb(255, 204, 204);
                    break;
                default:
                    rowBackColor = e.CellStyle.BackColor;
                    break;
            }

            var column = grid.Columns[e.ColumnIndex];
            if (column.Name == "acceptButtonColumn")
            {
                e.CellStyle.BackColor = Color.FromArgb(108, 117, 125);
                e.CellStyle.ForeColor = Color.White;
            }
            else if (column.Name == "deleteButtonColumn")
            {
                e.CellStyle.BackColor = Color.FromArgb(52, 58, 64);
                e.CellStyle.ForeColor = Color.White;
            }
            else
            {
                e.CellStyle.BackColor = rowBackColor;
                e.CellStyle.ForeColor = Color.Black;
            }

            if (grid.Rows[e.RowIndex].Selected)
            {
                e.CellStyle.SelectionBackColor = SystemColors.Highlight;
                e.CellStyle.SelectionForeColor = SystemColors.HighlightText;
            }
            else
            {
                e.CellStyle.SelectionBackColor = e.CellStyle.BackColor;
                e.CellStyle.SelectionForeColor = e.CellStyle.ForeColor;
            }
        }

        private void systemChangesDataGridView_RowPostPaint(object sender, DataGridViewRowPostPaintEventArgs e)
        {
            var grid = (DataGridView)sender;
            var row = grid.Rows[e.RowIndex];

            if (row.Selected) return;
            var mouseOverRow = grid.HitTest(grid.PointToClient(MousePosition).X, grid.PointToClient(MousePosition).Y).RowIndex;
            if (e.RowIndex == mouseOverRow)
            {
                using var overlayBrush = new SolidBrush(Color.FromArgb(25, Color.Black));
                e.Graphics.FillRectangle(overlayBrush, e.RowBounds);
            }
        }

        private void systemChangesDataGridView_CellMouseEnter(object sender, DataGridViewCellEventArgs e)
        {
            if (e.RowIndex >= 0)
            {
                var grid = (DataGridView)sender;
                grid.InvalidateRow(e.RowIndex);
            }
        }

        private void systemChangesDataGridView_CellMouseLeave(object sender, DataGridViewCellEventArgs e)
        {
            if (e.RowIndex >= 0)
            {
                var grid = (DataGridView)sender;
                grid.InvalidateRow(e.RowIndex);
            }
        }

        private void systemChangesDataGridView_CellMouseDown(object sender, DataGridViewCellMouseEventArgs e)
        {
            if (e.Button == MouseButtons.Right && e.RowIndex >= 0)
            {
                var grid = (DataGridView)sender;
                var clickedRow = grid.Rows[e.RowIndex];

                if (!clickedRow.Selected)
                {
                    grid.ClearSelection();
                    clickedRow.Selected = true;
                }
            }
        }
    }
}

--------------------------------------------------
// Full Path: C:/Users/anon/PROGRAMMING/C#/SimpleFirewall/VS Minimal Firewall/MinimalFirewall-NET8/Backups/v2.5.5 - ws/2.5.5.6 - security vulnerability fix 3/AuditControl.Designer.cs
--------------------------------------------------------------------------------
// File: AuditControl.Designer.cs
namespace MinimalFirewall
{
    partial class AuditControl
    {
        private System.Windows.Forms.TextBox auditSearchTextBox;
        private System.Windows.Forms.Button rebuildBaselineButton;
        private System.Windows.Forms.ContextMenuStrip auditContextMenu;
        private System.Windows.Forms.ToolStripMenuItem acceptAllToolStripMenuItem;
        private System.Windows.Forms.ToolStripMenuItem copyDetailsToolStripMenuItem;
        private System.Windows.Forms.ToolStripSeparator toolStripSeparator1;
        private System.Windows.Forms.ToolStripMenuItem openFileLocationToolStripMenuItem;
        private System.Windows.Forms.Panel topPanel;
        private System.Windows.Forms.DataGridView systemChangesDataGridView;
        private System.Windows.Forms.DataGridViewButtonColumn acceptButtonColumn;
        private System.Windows.Forms.DataGridViewButtonColumn deleteButtonColumn;
        private System.Windows.Forms.DataGridViewTextBoxColumn advNameColumn;
        private System.Windows.Forms.DataGridViewTextBoxColumn advStatusColumn;
        private System.Windows.Forms.DataGridViewTextBoxColumn advProtocolColumn;
        private System.Windows.Forms.DataGridViewTextBoxColumn advLocalPortsColumn;
        private System.Windows.Forms.DataGridViewTextBoxColumn advRemotePortsColumn;
        private System.Windows.Forms.DataGridViewTextBoxColumn advLocalAddressColumn;
        private System.Windows.Forms.DataGridViewTextBoxColumn advRemoteAddressColumn;
        private System.Windows.Forms.DataGridViewTextBoxColumn advProgramColumn;
        private System.Windows.Forms.DataGridViewTextBoxColumn advServiceColumn;
        private System.Windows.Forms.DataGridViewTextBoxColumn advProfilesColumn;
        private System.Windows.Forms.DataGridViewTextBoxColumn advGroupingColumn;
        private System.Windows.Forms.DataGridViewTextBoxColumn advDescColumn;
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        private void InitializeComponent()
        {
            this.components = new System.ComponentModel.Container();
            System.Windows.Forms.DataGridViewCellStyle dataGridViewCellStyle1 = new System.Windows.Forms.DataGridViewCellStyle();
            System.Windows.Forms.DataGridViewCellStyle dataGridViewCellStyle2 = new System.Windows.Forms.DataGridViewCellStyle();
            System.Windows.Forms.DataGridViewCellStyle dataGridViewCellStyle3 = new System.Windows.Forms.DataGridViewCellStyle();
            this.auditSearchTextBox = new System.Windows.Forms.TextBox();
            this.rebuildBaselineButton = new System.Windows.Forms.Button();
            this.auditContextMenu = new System.Windows.Forms.ContextMenuStrip(this.components);
            this.acceptAllToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.copyDetailsToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.toolStripSeparator1 = new System.Windows.Forms.ToolStripSeparator();
            this.openFileLocationToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.topPanel = new System.Windows.Forms.Panel();
            this.systemChangesDataGridView = new System.Windows.Forms.DataGridView();
            this.acceptButtonColumn = new System.Windows.Forms.DataGridViewButtonColumn();
            this.deleteButtonColumn = new System.Windows.Forms.DataGridViewButtonColumn();
            this.advNameColumn = new System.Windows.Forms.DataGridViewTextBoxColumn();
            this.advStatusColumn = new System.Windows.Forms.DataGridViewTextBoxColumn();
            this.advProtocolColumn = new System.Windows.Forms.DataGridViewTextBoxColumn();
            this.advLocalPortsColumn = new System.Windows.Forms.DataGridViewTextBoxColumn();
            this.advRemotePortsColumn = new System.Windows.Forms.DataGridViewTextBoxColumn();
            this.advLocalAddressColumn = new System.Windows.Forms.DataGridViewTextBoxColumn();
            this.advRemoteAddressColumn = new System.Windows.Forms.DataGridViewTextBoxColumn();
            this.advProgramColumn = new System.Windows.Forms.DataGridViewTextBoxColumn();
            this.advServiceColumn = new System.Windows.Forms.DataGridViewTextBoxColumn();
            this.advProfilesColumn = new System.Windows.Forms.DataGridViewTextBoxColumn();
            this.advGroupingColumn = new System.Windows.Forms.DataGridViewTextBoxColumn();
            this.advDescColumn = new System.Windows.Forms.DataGridViewTextBoxColumn();
            this.auditContextMenu.SuspendLayout();
            this.topPanel.SuspendLayout();
            ((System.ComponentModel.ISupportInitialize)(this.systemChangesDataGridView)).BeginInit();
            this.SuspendLayout();
            // 
            // auditSearchTextBox
            // 
            this.auditSearchTextBox.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
            this.auditSearchTextBox.Location = new System.Drawing.Point(707, 27);
            this.auditSearchTextBox.Margin = new System.Windows.Forms.Padding(3, 4, 3, 4);
            this.auditSearchTextBox.Name = "auditSearchTextBox";
            this.auditSearchTextBox.PlaceholderText = "Search changes...";
            this.auditSearchTextBox.Size = new System.Drawing.Size(285, 27);
            this.auditSearchTextBox.TabIndex = 3;
            this.auditSearchTextBox.TextChanged += new System.EventHandler(this.auditSearchTextBox_TextChanged);
            // 
            // rebuildBaselineButton
            // 
            this.rebuildBaselineButton.Location = new System.Drawing.Point(3, 17);
            this.rebuildBaselineButton.Margin = new System.Windows.Forms.Padding(3, 4, 3, 4);
            this.rebuildBaselineButton.Name = "rebuildBaselineButton";
            this.rebuildBaselineButton.Size = new System.Drawing.Size(173, 48);
            this.rebuildBaselineButton.TabIndex = 2;
            this.rebuildBaselineButton.Text = "Rebuild Baseline";
            this.rebuildBaselineButton.Click += new System.EventHandler(this.rebuildBaselineButton_Click);
            // 
            // auditContextMenu
            // 
            this.auditContextMenu.ImageScalingSize = new System.Drawing.Size(20, 20);
            this.auditContextMenu.Items.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.acceptAllToolStripMenuItem,
            this.copyDetailsToolStripMenuItem,
            this.toolStripSeparator1,
            this.openFileLocationToolStripMenuItem});
            this.auditContextMenu.Name = "auditContextMenu";
            this.auditContextMenu.Size = new System.Drawing.Size(207, 88);
            this.auditContextMenu.Opening += new System.ComponentModel.CancelEventHandler(this.auditContextMenu_Opening);
            // 
            // acceptAllToolStripMenuItem
            // 
            this.acceptAllToolStripMenuItem.Name = "acceptAllToolStripMenuItem";
            this.acceptAllToolStripMenuItem.Size = new System.Drawing.Size(206, 24);
            this.acceptAllToolStripMenuItem.Text = "Accept All Changes";
            this.acceptAllToolStripMenuItem.Click += new System.EventHandler(this.AcceptAllToolStripMenuItem_Click);
            // 
            // copyDetailsToolStripMenuItem
            // 
            this.copyDetailsToolStripMenuItem.Name = "copyDetailsToolStripMenuItem";
            this.copyDetailsToolStripMenuItem.Size = new System.Drawing.Size(206, 24);
            this.copyDetailsToolStripMenuItem.Text = "Copy Details";
            this.copyDetailsToolStripMenuItem.Click += new System.EventHandler(this.copyDetailsToolStripMenuItem_Click);
            // 
            // toolStripSeparator1
            // 
            this.toolStripSeparator1.Name = "toolStripSeparator1";
            this.toolStripSeparator1.Size = new System.Drawing.Size(203, 6);
            // 
            // openFileLocationToolStripMenuItem
            // 
            this.openFileLocationToolStripMenuItem.Name = "openFileLocationToolStripMenuItem";
            this.openFileLocationToolStripMenuItem.Size = new System.Drawing.Size(206, 24);
            this.openFileLocationToolStripMenuItem.Text = "Open File Location";
            this.openFileLocationToolStripMenuItem.Click += new System.EventHandler(this.openFileLocationToolStripMenuItem_Click);
            // 
            // topPanel
            // 
            this.topPanel.Controls.Add(this.rebuildBaselineButton);
            this.topPanel.Controls.Add(this.auditSearchTextBox);
            this.topPanel.Dock = System.Windows.Forms.DockStyle.Top;
            this.topPanel.Location = new System.Drawing.Point(0, 0);
            this.topPanel.Name = "topPanel";
            this.topPanel.Size = new System.Drawing.Size(1000, 77);
            this.topPanel.TabIndex = 4;
            // 
            // systemChangesDataGridView
            // 
            this.systemChangesDataGridView.AllowUserToAddRows = false;
            this.systemChangesDataGridView.AllowUserToDeleteRows = false;
            this.systemChangesDataGridView.AllowUserToResizeRows = false;
            this.systemChangesDataGridView.AutoSizeColumnsMode = System.Windows.Forms.DataGridViewAutoSizeColumnsMode.Fill;
            this.systemChangesDataGridView.BackgroundColor = System.Drawing.SystemColors.Control;
            this.systemChangesDataGridView.BorderStyle = System.Windows.Forms.BorderStyle.None;
            this.systemChangesDataGridView.CellBorderStyle = System.Windows.Forms.DataGridViewCellBorderStyle.None;
            this.systemChangesDataGridView.ColumnHeadersBorderStyle = System.Windows.Forms.DataGridViewHeaderBorderStyle.None;
            dataGridViewCellStyle1.Alignment = System.Windows.Forms.DataGridViewContentAlignment.MiddleLeft;
            dataGridViewCellStyle1.BackColor = System.Drawing.SystemColors.Control;
            dataGridViewCellStyle1.Font = new System.Drawing.Font("Segoe UI", 9F);
            dataGridViewCellStyle1.ForeColor = System.Drawing.SystemColors.WindowText;
            dataGridViewCellStyle1.SelectionBackColor = System.Drawing.SystemColors.Highlight;
            dataGridViewCellStyle1.SelectionForeColor = System.Drawing.SystemColors.HighlightText;
            dataGridViewCellStyle1.WrapMode = System.Windows.Forms.DataGridViewTriState.True;
            this.systemChangesDataGridView.ColumnHeadersDefaultCellStyle = dataGridViewCellStyle1;
            this.systemChangesDataGridView.ColumnHeadersHeightSizeMode = System.Windows.Forms.DataGridViewColumnHeadersHeightSizeMode.AutoSize;
            this.systemChangesDataGridView.Columns.AddRange(new System.Windows.Forms.DataGridViewColumn[] {
            this.acceptButtonColumn,
            this.deleteButtonColumn,
            this.advNameColumn,
            this.advStatusColumn,
            this.advProtocolColumn,
            this.advLocalPortsColumn,
            this.advRemotePortsColumn,
            this.advLocalAddressColumn,
            this.advRemoteAddressColumn,
            this.advProgramColumn,
            this.advServiceColumn,
            this.advProfilesColumn,
            this.advGroupingColumn,
            this.advDescColumn});
            this.systemChangesDataGridView.ContextMenuStrip = this.auditContextMenu;
            this.systemChangesDataGridView.Dock = System.Windows.Forms.DockStyle.Fill;
            this.systemChangesDataGridView.EnableHeadersVisualStyles = false;
            this.systemChangesDataGridView.GridColor = System.Drawing.SystemColors.Control;
            this.systemChangesDataGridView.Location = new System.Drawing.Point(0, 77);
            this.systemChangesDataGridView.MultiSelect = true;
            this.systemChangesDataGridView.Name = "systemChangesDataGridView";
            this.systemChangesDataGridView.ReadOnly = true;
            this.systemChangesDataGridView.RowHeadersVisible = false;
            this.systemChangesDataGridView.RowTemplate.Height = 28;
            this.systemChangesDataGridView.SelectionMode = System.Windows.Forms.DataGridViewSelectionMode.FullRowSelect;
            this.systemChangesDataGridView.ShowCellToolTips = true;
            this.systemChangesDataGridView.Size = new System.Drawing.Size(1000, 843);
            this.systemChangesDataGridView.TabIndex = 5;
            this.systemChangesDataGridView.CellContentClick += new System.Windows.Forms.DataGridViewCellEventHandler(this.systemChangesDataGridView_CellContentClick);
            this.systemChangesDataGridView.CellFormatting += new System.Windows.Forms.DataGridViewCellFormattingEventHandler(this.systemChangesDataGridView_CellFormatting);
            this.systemChangesDataGridView.CellMouseDown += new System.Windows.Forms.DataGridViewCellMouseEventHandler(this.systemChangesDataGridView_CellMouseDown);
            this.systemChangesDataGridView.CellMouseEnter += new System.Windows.Forms.DataGridViewCellEventHandler(this.systemChangesDataGridView_CellMouseEnter);
            this.systemChangesDataGridView.CellMouseLeave += new System.Windows.Forms.DataGridViewCellEventHandler(this.systemChangesDataGridView_CellMouseLeave);
            this.systemChangesDataGridView.ColumnHeaderMouseClick += new System.Windows.Forms.DataGridViewCellMouseEventHandler(this.systemChangesDataGridView_ColumnHeaderMouseClick);
            this.systemChangesDataGridView.RowPostPaint += new System.Windows.Forms.DataGridViewRowPostPaintEventHandler(this.systemChangesDataGridView_RowPostPaint);
            // 
            // acceptButtonColumn
            // 
            this.acceptButtonColumn.AutoSizeMode = System.Windows.Forms.DataGridViewAutoSizeColumnMode.None;
            dataGridViewCellStyle2.Alignment = System.Windows.Forms.DataGridViewContentAlignment.MiddleCenter;
            dataGridViewCellStyle2.WrapMode = System.Windows.Forms.DataGridViewTriState.True;
            this.acceptButtonColumn.DefaultCellStyle = dataGridViewCellStyle2;
            this.acceptButtonColumn.FillWeight = 15F;
            this.acceptButtonColumn.FlatStyle = System.Windows.Forms.FlatStyle.Flat;
            this.acceptButtonColumn.HeaderText = "Action";
            this.acceptButtonColumn.MinimumWidth = 70;
            this.acceptButtonColumn.Name = "acceptButtonColumn";
            this.acceptButtonColumn.ReadOnly = true;
            this.acceptButtonColumn.Text = "Accept";
            this.acceptButtonColumn.UseColumnTextForButtonValue = true;
            this.acceptButtonColumn.Width = 70;
            // 
            // deleteButtonColumn
            // 
            this.deleteButtonColumn.AutoSizeMode = System.Windows.Forms.DataGridViewAutoSizeColumnMode.None;
            dataGridViewCellStyle3.Alignment = System.Windows.Forms.DataGridViewContentAlignment.MiddleCenter;
            dataGridViewCellStyle3.WrapMode = System.Windows.Forms.DataGridViewTriState.True;
            this.deleteButtonColumn.DefaultCellStyle = dataGridViewCellStyle3;
            this.deleteButtonColumn.FillWeight = 15F;
            this.deleteButtonColumn.FlatStyle = System.Windows.Forms.FlatStyle.Flat;
            this.deleteButtonColumn.HeaderText = "";
            this.deleteButtonColumn.MinimumWidth = 70;
            this.deleteButtonColumn.Name = "deleteButtonColumn";
            this.deleteButtonColumn.ReadOnly = true;
            this.deleteButtonColumn.Text = "Delete";
            this.deleteButtonColumn.UseColumnTextForButtonValue = true;
            this.deleteButtonColumn.Width = 70;
            // 
            // advNameColumn
            // 
            this.advNameColumn.DataPropertyName = "Name";
            this.advNameColumn.FillWeight = 20F;
            this.advNameColumn.HeaderText = "Name";
            this.advNameColumn.Name = "advNameColumn";
            this.advNameColumn.ReadOnly = true;
            // 
            // advStatusColumn
            // 
            this.advStatusColumn.DataPropertyName = "Status";
            this.advStatusColumn.FillWeight = 15F;
            this.advStatusColumn.HeaderText = "Action";
            this.advStatusColumn.Name = "advStatusColumn";
            this.advStatusColumn.ReadOnly = true;
            // 
            // advProtocolColumn
            // 
            this.advProtocolColumn.DataPropertyName = "ProtocolName";
            this.advProtocolColumn.FillWeight = 8F;
            this.advProtocolColumn.HeaderText = "Protocol";
            this.advProtocolColumn.Name = "advProtocolColumn";
            this.advProtocolColumn.ReadOnly = true;
            // 
            // advLocalPortsColumn
            // 
            this.advLocalPortsColumn.DataPropertyName = "LocalPorts";
            this.advLocalPortsColumn.FillWeight = 12F;
            this.advLocalPortsColumn.HeaderText = "Local Ports";
            this.advLocalPortsColumn.Name = "advLocalPortsColumn";
            this.advLocalPortsColumn.ReadOnly = true;
            // 
            // advRemotePortsColumn
            // 
            this.advRemotePortsColumn.DataPropertyName = "RemotePorts";
            this.advRemotePortsColumn.FillWeight = 12F;
            this.advRemotePortsColumn.HeaderText = "Remote Ports";
            this.advRemotePortsColumn.Name = "advRemotePortsColumn";
            this.advRemotePortsColumn.ReadOnly = true;
            // 
            // advLocalAddressColumn
            // 
            this.advLocalAddressColumn.DataPropertyName = "LocalAddresses";
            this.advLocalAddressColumn.FillWeight = 15F;
            this.advLocalAddressColumn.HeaderText = "Local Address";
            this.advLocalAddressColumn.Name = "advLocalAddressColumn";
            this.advLocalAddressColumn.ReadOnly = true;
            // 
            // advRemoteAddressColumn
            // 
            this.advRemoteAddressColumn.DataPropertyName = "RemoteAddresses";
            this.advRemoteAddressColumn.FillWeight = 15F;
            this.advRemoteAddressColumn.HeaderText = "Remote Address";
            this.advRemoteAddressColumn.Name = "advRemoteAddressColumn";
            this.advRemoteAddressColumn.ReadOnly = true;
            // 
            // advProgramColumn
            // 
            this.advProgramColumn.DataPropertyName = "ApplicationName";
            this.advProgramColumn.FillWeight = 25F;
            this.advProgramColumn.HeaderText = "Application";
            this.advProgramColumn.Name = "advProgramColumn";
            this.advProgramColumn.ReadOnly = true;
            // 
            // advServiceColumn
            // 
            this.advServiceColumn.DataPropertyName = "ServiceName";
            this.advServiceColumn.FillWeight = 15F;
            this.advServiceColumn.HeaderText = "Service";
            this.advServiceColumn.Name = "advServiceColumn";
            this.advServiceColumn.ReadOnly = true;
            // 
            // advProfilesColumn
            // 
            this.advProfilesColumn.DataPropertyName = "Profiles";
            this.advProfilesColumn.FillWeight = 10F;
            this.advProfilesColumn.HeaderText = "Profiles";
            this.advProfilesColumn.Name = "advProfilesColumn";
            this.advProfilesColumn.ReadOnly = true;
            // 
            // advGroupingColumn
            // 
            this.advGroupingColumn.DataPropertyName = "Grouping";
            this.advGroupingColumn.FillWeight = 15F;
            this.advGroupingColumn.HeaderText = "Group";
            this.advGroupingColumn.Name = "advGroupingColumn";
            this.advGroupingColumn.ReadOnly = true;
            // 
            // advDescColumn
            // 
            this.advDescColumn.DataPropertyName = "Description";
            this.advDescColumn.FillWeight = 30F;
            this.advDescColumn.HeaderText = "Description";
            this.advDescColumn.Name = "advDescColumn";
            this.advDescColumn.ReadOnly = true;
            // 
            // AuditControl
            // 
            this.AutoScaleDimensions = new System.Drawing.SizeF(8F, 20F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.Controls.Add(this.systemChangesDataGridView);
            this.Controls.Add(this.topPanel);
            this.Name = "AuditControl";
            this.Size = new System.Drawing.Size(1000, 920);
            this.auditContextMenu.ResumeLayout(false);
            this.topPanel.ResumeLayout(false);
            this.topPanel.PerformLayout();
            ((System.ComponentModel.ISupportInitialize)(this.systemChangesDataGridView)).EndInit();
            this.ResumeLayout(false);
        }
    }
}

--------------------------------------------------
// Full Path: C:/Users/anon/PROGRAMMING/C#/SimpleFirewall/VS Minimal Firewall/MinimalFirewall-NET8/Backups/v2.5.5 - ws/2.5.5.6 - security vulnerability fix 3/BackgroundFirewallTaskService.cs
--------------------------------------------------------------------------------
using System;
using System.Collections.Concurrent;
using System.Threading;
using System.Threading.Tasks;
using System.Runtime.InteropServices;
using MinimalFirewall.TypedObjects;

namespace MinimalFirewall
{
    public class BackgroundFirewallTaskService : IDisposable
    {
        private readonly BlockingCollection<FirewallTask> _taskQueue = new BlockingCollection<FirewallTask>();
        private readonly Task _worker;
        private readonly CancellationTokenSource _cancellationTokenSource = new CancellationTokenSource();
        private readonly FirewallActionsService _actionsService;
        private readonly UserActivityLogger _activityLogger;
        private readonly WildcardRuleService _wildcardRuleService;
        private readonly FirewallDataService _dataService;

        public event Action<int>? QueueCountChanged;

        public BackgroundFirewallTaskService(FirewallActionsService actionsService, UserActivityLogger activityLogger, WildcardRuleService wildcardRuleService, FirewallDataService dataService)
        {
            _actionsService = actionsService;
            _activityLogger = activityLogger;
            _wildcardRuleService = wildcardRuleService;
            _dataService = dataService;
            _worker = Task.Run(ProcessQueueAsync, _cancellationTokenSource.Token);
        }

        public void EnqueueTask(FirewallTask task)
        {
            if (!_taskQueue.IsAddingCompleted)
            {
                _taskQueue.Add(task);
                QueueCountChanged?.Invoke(_taskQueue.Count);
            }
        }

        private async Task ProcessQueueAsync()
        {
            foreach (var task in _taskQueue.GetConsumingEnumerable(_cancellationTokenSource.Token))
            {
                bool requiresCacheInvalidation = true;

                try
                {
                    await Task.Run(async () =>
                    {
                        switch (task.TaskType)
                        {
                            case FirewallTaskType.ApplyApplicationRule:
                                if (task.Payload is ApplyApplicationRulePayload p1) _actionsService.ApplyApplicationRuleChange(p1.AppPaths, p1.Action, p1.WildcardSourcePath);
                                break;
                            case FirewallTaskType.ApplyServiceRule:
                                if (task.Payload is ApplyServiceRulePayload p2) _actionsService.ApplyServiceRuleChange(p2.ServiceName, p2.Action, p2.AppPath);
                                break;
                            case FirewallTaskType.ApplyUwpRule:
                                if (task.Payload is ApplyUwpRulePayload p3) _actionsService.ApplyUwpRuleChange(p3.UwpApps, p3.Action);
                                break;
                            case FirewallTaskType.DeleteApplicationRules:
                                if (task.Payload is DeleteRulesPayload p4) _actionsService.DeleteApplicationRules(p4.RuleIdentifiers);
                                break;
                            case FirewallTaskType.DeleteUwpRules:
                                if (task.Payload is DeleteRulesPayload p5) _actionsService.DeleteUwpRules(p5.RuleIdentifiers);
                                break;
                            case FirewallTaskType.DeleteAdvancedRules:
                                if (task.Payload is DeleteRulesPayload p6) _actionsService.DeleteAdvancedRules(p6.RuleIdentifiers);
                                break;
                            case FirewallTaskType.DeleteGroup:
                                if (task.Payload is string p7) await _actionsService.DeleteGroupAsync(p7);
                                break;
                            case FirewallTaskType.DeleteWildcardRules:
                                if (task.Payload is DeleteWildcardRulePayload p8) _actionsService.DeleteRulesForWildcard(p8.Wildcard);
                                break;
                            case FirewallTaskType.ProcessPendingConnection:
                                if (task.Payload is ProcessPendingConnectionPayload p9) _actionsService.ProcessPendingConnection(p9.PendingConnection, p9.Decision, p9.Duration, p9.TrustPublisher);

                                break;
                            case FirewallTaskType.AcceptForeignRule:
                                if (task.Payload is ForeignRuleChangePayload p10) _actionsService.AcceptForeignRule(p10.Change);
                                requiresCacheInvalidation = false;
                                break;
                            case FirewallTaskType.DeleteForeignRule:
                                if (task.Payload is ForeignRuleChangePayload p12) _actionsService.DeleteForeignRule(p12.Change);
                                break;
                            case FirewallTaskType.AcceptAllForeignRules:
                                if (task.Payload is AllForeignRuleChangesPayload p13) _actionsService.AcceptAllForeignRules(p13.Changes);
                                requiresCacheInvalidation = false;
                                break;
                            case FirewallTaskType.CreateAdvancedRule:
                                if (task.Payload is CreateAdvancedRulePayload p15) _actionsService.CreateAdvancedRule(p15.ViewModel, p15.InterfaceTypes, p15.IcmpTypesAndCodes);
                                break;
                            case FirewallTaskType.AddWildcardRule:
                                if (task.Payload is WildcardRule p16) _wildcardRuleService.AddRule(p16);

                                requiresCacheInvalidation = false;
                                break;
                            case FirewallTaskType.SetGroupEnabledState:
                                if (task.Payload is SetGroupEnabledStatePayload p17) _actionsService.SetGroupEnabledState(p17.GroupName, p17.IsEnabled);
                                break;
                            case FirewallTaskType.UpdateWildcardRule:
                                if (task.Payload is UpdateWildcardRulePayload p18) _actionsService.UpdateWildcardRule(p18.OldRule, p18.NewRule);
                                break;
                            case FirewallTaskType.RemoveWildcardRule:
                                if (task.Payload is DeleteWildcardRulePayload p19) _actionsService.RemoveWildcardRule(p19.Wildcard);
                                break;
                            case FirewallTaskType.RemoveWildcardDefinitionOnly:
                                if (task.Payload is DeleteWildcardRulePayload p20) _actionsService.RemoveWildcardDefinitionOnly(p20.Wildcard);
                                requiresCacheInvalidation = false;
                                break;
                            case FirewallTaskType.DeleteAllMfwRules:
                                _actionsService.DeleteAllMfwRules();
                                break;
                            case FirewallTaskType.ImportRules:
                                if (task.Payload is ImportRulesPayload p21) await _actionsService.ImportRulesAsync(p21.JsonContent, p21.Replace);
                                break;
                            default:
                                requiresCacheInvalidation = false;
                                break;
                        }
                    }, _cancellationTokenSource.Token);
                }
                catch (OperationCanceledException)
                {
                    requiresCacheInvalidation = false;
                    break;
                }
                catch (COMException comEx)
                {
                    requiresCacheInvalidation = false;
                    _activityLogger.LogException($"BackgroundTask-{task.TaskType}-COM", comEx);
                }
                catch (InvalidComObjectException invComEx)
                {
                    requiresCacheInvalidation = false;
                    _activityLogger.LogException($"BackgroundTask-{task.TaskType}-InvalidCOM", invComEx);
                }
                catch (Exception ex)
                {
                    requiresCacheInvalidation = false;
                    _activityLogger.LogException($"BackgroundTask-{task.TaskType}", ex);
                }
                finally
                {
                    if (requiresCacheInvalidation)
                    {
                        _dataService.InvalidateRuleCache();
                        _activityLogger.LogDebug($"[Cache] Invalidated MFW Rules cache after task: {task.TaskType}");
                    }
                    QueueCountChanged?.Invoke(_taskQueue.Count);
                }
            }
        }

        public void Dispose()
        {
            _taskQueue.CompleteAdding();
            _cancellationTokenSource.Cancel();
            try
            {
                _worker.Wait(2000);
            }
            catch (OperationCanceledException) { }
            catch (AggregateException) { }

            _cancellationTokenSource.Dispose();
            _taskQueue.Dispose();
        }
    }
}


--------------------------------------------------
// Full Path: C:/Users/anon/PROGRAMMING/C#/SimpleFirewall/VS Minimal Firewall/MinimalFirewall-NET8/Backups/v2.5.5 - ws/2.5.5.6 - security vulnerability fix 3/BrowseServicesForm.cs
--------------------------------------------------------------------------------
// File: BrowseServicesForm.cs
using DarkModeForms;
using System.Data;

namespace MinimalFirewall
{
    public partial class BrowseServicesForm : Form
    {
        private readonly DarkModeCS dm;
        private readonly List<ServiceViewModel> _allServices;
        public ServiceViewModel? SelectedService { get; private set; }

        public BrowseServicesForm(List<ServiceViewModel> services, AppSettings appSettings)
        {
            InitializeComponent();
            dm = new DarkModeCS(this);
            dm.ColorMode = appSettings.Theme == "Dark" ? DarkModeCS.DisplayMode.DarkMode : DarkModeCS.DisplayMode.ClearMode;
            dm.ApplyTheme(appSettings.Theme == "Dark");
            _allServices = services;
            LoadServices();
        }

        private void LoadServices(string filter = "")
        {
            servicesListBox.BeginUpdate();
            servicesListBox.Items.Clear();

            var filteredServices = string.IsNullOrWhiteSpace(filter)
                ? _allServices
                : _allServices.Where(s =>
                    s.DisplayName.Contains(filter, StringComparison.OrdinalIgnoreCase) ||
                    s.ServiceName.Contains(filter, StringComparison.OrdinalIgnoreCase));

            foreach (var service in filteredServices)
            {
                servicesListBox.Items.Add($"{service.DisplayName} ({service.ServiceName})");
            }
            servicesListBox.EndUpdate();
        }

        private void searchTextBox_TextChanged(object sender, EventArgs e)
        {
            LoadServices(searchTextBox.Text);
        }

        private void okButton_Click(object sender, EventArgs e)
        {
            if (servicesListBox.SelectedItem is string selectedItem)
            {
                SelectedService = _allServices.FirstOrDefault(s => selectedItem == $"{s.DisplayName} ({s.ServiceName})");
                this.DialogResult = DialogResult.OK;
                this.Close();
            }
            else
            {
                this.DialogResult = DialogResult.Cancel;
                this.Close();
            }
        }

        private void cancelButton_Click(object sender, EventArgs e)
        {
            this.DialogResult = DialogResult.Cancel;
            this.Close();
        }

        private void servicesListBox_DoubleClick(object sender, EventArgs e)
        {
            okButton_Click(sender, e);
        }
    }
}

--------------------------------------------------
// Full Path: C:/Users/anon/PROGRAMMING/C#/SimpleFirewall/VS Minimal Firewall/MinimalFirewall-NET8/Backups/v2.5.5 - ws/2.5.5.6 - security vulnerability fix 3/BrowseServicesForm.Designer.cs
--------------------------------------------------------------------------------
namespace MinimalFirewall
{
    partial class BrowseServicesForm
    {
        private System.ComponentModel.IContainer components = null;
        private System.Windows.Forms.TextBox searchTextBox;
        private System.Windows.Forms.ListBox servicesListBox;
        private System.Windows.Forms.Button okButton;
        private System.Windows.Forms.Button cancelButton;
        private System.Windows.Forms.Panel bottomPanel;

        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        private void InitializeComponent()
        {
            this.searchTextBox = new System.Windows.Forms.TextBox();
            this.servicesListBox = new System.Windows.Forms.ListBox();
            this.okButton = new System.Windows.Forms.Button();
            this.cancelButton = new System.Windows.Forms.Button();
            this.bottomPanel = new System.Windows.Forms.Panel();
            this.bottomPanel.SuspendLayout();
            this.SuspendLayout();
            // 
            // searchTextBox
            // 
            this.searchTextBox.Dock = System.Windows.Forms.DockStyle.Top;
            this.searchTextBox.Location = new System.Drawing.Point(10, 10);
            this.searchTextBox.Name = "searchTextBox";
            this.searchTextBox.PlaceholderText = "Search services...";
            this.searchTextBox.Size = new System.Drawing.Size(464, 23);
            this.searchTextBox.TabIndex = 0;
            this.searchTextBox.TextChanged += new System.EventHandler(this.searchTextBox_TextChanged);
            // 
            // servicesListBox
            // 
            this.servicesListBox.Dock = System.Windows.Forms.DockStyle.Fill;
            this.servicesListBox.FormattingEnabled = true;
            this.servicesListBox.IntegralHeight = false;
            this.servicesListBox.ItemHeight = 15;
            this.servicesListBox.Location = new System.Drawing.Point(10, 33);
            this.servicesListBox.Name = "servicesListBox";
            this.servicesListBox.Size = new System.Drawing.Size(464, 358);
            this.servicesListBox.TabIndex = 1;
            this.servicesListBox.DoubleClick += new System.EventHandler(this.servicesListBox_DoubleClick);
            // 
            // okButton
            // 
            this.okButton.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
            this.okButton.Location = new System.Drawing.Point(265, 12);
            this.okButton.Name = "okButton";
            this.okButton.Size = new System.Drawing.Size(100, 36);
            this.okButton.TabIndex = 0;
            this.okButton.Text = "OK";
            this.okButton.UseVisualStyleBackColor = true;
            this.okButton.Click += new System.EventHandler(this.okButton_Click);
            // 
            // cancelButton
            // 
            this.cancelButton.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
            this.cancelButton.DialogResult = System.Windows.Forms.DialogResult.Cancel;
            this.cancelButton.Location = new System.Drawing.Point(371, 12);
            this.cancelButton.Name = "cancelButton";
            this.cancelButton.Size = new System.Drawing.Size(100, 36);
            this.cancelButton.TabIndex = 1;
            this.cancelButton.Text = "Cancel";
            this.cancelButton.UseVisualStyleBackColor = true;
            this.cancelButton.Click += new System.EventHandler(this.cancelButton_Click);
            // 
            // bottomPanel
            // 
            this.bottomPanel.Controls.Add(this.cancelButton);
            this.bottomPanel.Controls.Add(this.okButton);
            this.bottomPanel.Dock = System.Windows.Forms.DockStyle.Bottom;
            this.bottomPanel.Location = new System.Drawing.Point(0, 391);
            this.bottomPanel.Name = "bottomPanel";
            this.bottomPanel.Size = new System.Drawing.Size(484, 60);
            this.bottomPanel.TabIndex = 2;
            // 
            // BrowseServicesForm
            // 
            this.AcceptButton = this.okButton;
            this.AutoScaleDimensions = new System.Drawing.SizeF(7F, 15F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.CancelButton = this.cancelButton;
            this.ClientSize = new System.Drawing.Size(484, 451);
            this.Controls.Add(this.servicesListBox);
            this.Controls.Add(this.searchTextBox);
            this.Controls.Add(this.bottomPanel);
            this.MaximizeBox = false;
            this.MinimizeBox = false;
            this.MinimumSize = new System.Drawing.Size(400, 300);
            this.Name = "BrowseServicesForm";
            this.Padding = new System.Windows.Forms.Padding(10, 10, 10, 0);
            this.ShowIcon = false;
            this.ShowInTaskbar = false;
            this.StartPosition = System.Windows.Forms.FormStartPosition.CenterParent;
            this.Text = "Browse Services";
            this.bottomPanel.ResumeLayout(false);
            this.ResumeLayout(false);
            this.PerformLayout();

        }

        #endregion
    }
}

--------------------------------------------------
// Full Path: C:/Users/anon/PROGRAMMING/C#/SimpleFirewall/VS Minimal Firewall/MinimalFirewall-NET8/Backups/v2.5.5 - ws/2.5.5.6 - security vulnerability fix 3/CreateAdvancedRuleForm.cs
--------------------------------------------------------------------------------
using DarkModeForms;
using MinimalFirewall.TypedObjects;
using System.ComponentModel;
using NetFwTypeLib;
using MinimalFirewall.Groups;
using System.Text.RegularExpressions;
using System.Net;

namespace MinimalFirewall
{
    public partial class CreateAdvancedRuleForm : Form
    {
        private readonly DarkModeCS dm;
        private readonly FirewallActionsService _actionsService;
        private readonly FirewallRuleViewModel _viewModel;
        private readonly FirewallGroupManager _groupManager;
        private readonly ToolTip _toolTip;
        private readonly AppSettings _appSettings;
        public AdvancedRuleViewModel? RuleVm { get; private set; }
        private readonly AdvancedRuleViewModel? _originalRuleVm;

        public CreateAdvancedRuleForm(FirewallActionsService actionsService, AppSettings appSettings)
        {
            InitializeComponent();
            _appSettings = appSettings;
            dm = new DarkModeCS(this);
            dm.ColorMode = appSettings.Theme == "Dark" ? DarkModeCS.DisplayMode.DarkMode : DarkModeCS.DisplayMode.ClearMode;
            dm.ApplyTheme(appSettings.Theme == "Dark");

            _actionsService = actionsService;
            _groupManager = new FirewallGroupManager();
            _toolTip = new ToolTip();
            _viewModel = new FirewallRuleViewModel();
            _viewModel.PropertyChanged += ViewModel_PropertyChanged;

            protocolComboBox.Items.AddRange(new object[] {
                ProtocolTypes.Any,
                ProtocolTypes.TCP,
                ProtocolTypes.UDP,
                ProtocolTypes.ICMPv4,
                ProtocolTypes.ICMPv6,
                ProtocolTypes.IGMP
            });
            protocolComboBox.SelectedItem = ProtocolTypes.Any;
            LoadFirewallGroups();
            _toolTip.SetToolTip(groupComboBox, "Select an existing group, or type a new name to create a new group.");
            _toolTip.SetToolTip(serviceNameTextBox, "Enter the exact service name (not display name).");
            this.Load += (sender, e) =>
            {
                var workingArea = Screen.FromControl(this).WorkingArea;
                if (this.Height > workingArea.Height)
                {
                    this.Height = workingArea.Height;
                }
                this.CenterToParent();
            };
        }

        public CreateAdvancedRuleForm(FirewallActionsService actionsService, string appPath, string direction, AppSettings appSettings)
               : this(actionsService, appSettings)
        {
            programPathTextBox.Text = appPath;
            if (direction.Equals("Inbound", StringComparison.OrdinalIgnoreCase))
            {
                inboundRadioButton.Checked = true;
            }
            else if (direction.Equals("Outbound", StringComparison.OrdinalIgnoreCase))
            {
                outboundRadioButton.Checked = true;
            }
            else
            {
                bothDirRadioButton.Checked = true;
            }
        }

        public CreateAdvancedRuleForm(FirewallActionsService actionsService, AdvancedRuleViewModel ruleToEdit, AppSettings appSettings)
            : this(actionsService, appSettings)
        {
            _originalRuleVm = ruleToEdit;
            this.Text = "Edit Advanced Rule";
            PopulateFormFromRule(ruleToEdit);
        }

        private void PopulateFormFromRule(AdvancedRuleViewModel rule)
        {
            ruleNameTextBox.Text = rule.Name;
            descriptionTextBox.Text = rule.Description;
            enabledCheckBox.Checked = rule.IsEnabled;

            if (rule.Status == "Allow")
                allowRadioButton.Checked = true;
            else
                blockRadioButton.Checked = true;

            if (rule.Direction == (Directions.Incoming | Directions.Outgoing))
                bothDirRadioButton.Checked = true;
            else if (rule.Direction == Directions.Incoming)
                inboundRadioButton.Checked = true;
            else
                outboundRadioButton.Checked = true;

            programPathTextBox.Text = rule.ApplicationName;
            serviceNameTextBox.Text = (rule.ServiceName == "*" || string.IsNullOrEmpty(rule.ServiceName)) ? string.Empty : rule.ServiceName;

            int protocolIndex = -1;
            var items = protocolComboBox.Items.OfType<ProtocolTypes>().ToList();
            for (int i = 0; i < items.Count; i++)
            {
                if (items[i].Value == rule.Protocol)
                {
                    protocolIndex = i;
                    break;
                }
            }

            if (protocolIndex != -1)
                protocolComboBox.SelectedIndex = protocolIndex;
            else
                protocolComboBox.SelectedItem = ProtocolTypes.Any;
            _viewModel.SelectedProtocol = (ProtocolTypes)protocolComboBox.SelectedItem;

            localPortsTextBox.Text = rule.LocalPorts;
            remotePortsTextBox.Text = rule.RemotePorts;

            localAddressTextBox.Text = rule.LocalAddresses;
            remoteAddressTextBox.Text = rule.RemoteAddresses;

            domainCheckBox.Checked = rule.Profiles.Contains("Domain") ||
                rule.Profiles == "All";
            privateCheckBox.Checked = rule.Profiles.Contains("Private") || rule.Profiles == "All";
            publicCheckBox.Checked = rule.Profiles.Contains("Public") || rule.Profiles == "All";

            groupComboBox.Text = rule.Grouping;
            lanCheckBox.Checked = rule.InterfaceTypes.Contains("Lan") || rule.InterfaceTypes == "All";
            wirelessCheckBox.Checked = rule.InterfaceTypes.Contains("Wireless") || rule.InterfaceTypes == "All";
            remoteAccessCheckBox.Checked = rule.InterfaceTypes.Contains("RemoteAccess") ||
                rule.InterfaceTypes == "All";

            if (_viewModel.IsIcmpSectionVisible)
            {
                icmpTypesAndCodesTextBox.Text = rule.IcmpTypesAndCodes;
            }
        }


        private void LoadFirewallGroups()
        {
            var groups = _groupManager.GetAllGroups();
            var groupNames = new HashSet<string>(groups.Select(g => g.Name));

            groupNames.Add(MFWConstants.MainRuleGroup);
            groupNames.Add(MFWConstants.WildcardRuleGroup);

            groupComboBox.Items.Clear();
            foreach (var name in groupNames.OrderBy(n => n))
            {
                groupComboBox.Items.Add(name);
            }

            groupComboBox.SelectedItem = MFWConstants.MainRuleGroup;
        }

        private void ViewModel_PropertyChanged(object? sender, PropertyChangedEventArgs e)
        {
            if (e.PropertyName == nameof(_viewModel.IsPortSectionVisible))
            {
                portsGroupBox.Visible = _viewModel.IsPortSectionVisible;
            }
            else if (e.PropertyName == nameof(_viewModel.IsIcmpSectionVisible))
            {
                icmpGroupBox.Visible = _viewModel.IsIcmpSectionVisible;
            }
        }

        private void ProtocolComboBox_SelectedIndexChanged(object sender, EventArgs e)
        {
            if (protocolComboBox.SelectedItem is ProtocolTypes selectedProtocol)
            {
                _viewModel.SelectedProtocol = selectedProtocol;
            }
        }

        private void OkButton_Click(object sender, EventArgs e)
        {
            if (!this.ValidateChildren())
            {
                Messenger.MessageBox("Please correct the validation errors before submitting.", "Validation Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
                return;
            }

            if (string.IsNullOrWhiteSpace(ruleNameTextBox.Text))
            {
                Messenger.MessageBox("Rule name cannot be empty.", "Validation Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
                ruleNameTextBox.Focus();
                return;
            }

            if (protocolComboBox.SelectedItem is not ProtocolTypes selectedProtocol)
            {
                Messenger.MessageBox("A valid protocol must be selected.", "Validation Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
                return;
            }

            if (_originalRuleVm == null)
            {
                bool hasService = !string.IsNullOrWhiteSpace(serviceNameTextBox.Text);
                bool hasWildcardPorts = string.IsNullOrWhiteSpace(localPortsTextBox.Text) || localPortsTextBox.Text.Trim() == "*" ||
                                        string.IsNullOrWhiteSpace(remotePortsTextBox.Text) || remotePortsTextBox.Text.Trim() == "*";
                bool protocolIsNotAny = selectedProtocol.Value != ProtocolTypes.Any.Value;
                if (hasService && hasWildcardPorts && protocolIsNotAny)
                {
                    Messenger.MessageBox("When creating a rule for a service with a specific protocol (like TCP or UDP), you must also specify concrete Local and Remote ports. Wildcards (*) are only allowed if the protocol is 'Any'.", "Validation Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
                    return;
                }
            }

            string groupName = groupComboBox.Text;
            if (string.IsNullOrWhiteSpace(groupName))
            {
                groupName = MFWConstants.MainRuleGroup;
            }

            var rule = new AdvancedRuleViewModel
            {
                Name = ruleNameTextBox.Text,
                Description = descriptionTextBox.Text,
                IsEnabled = enabledCheckBox.Checked,
                Grouping = groupName,
                Status = allowRadioButton.Checked ?
                    "Allow" : "Block",
                Direction = GetDirection(),
                Protocol = selectedProtocol.Value,
                ProtocolName = selectedProtocol.Name,
                ApplicationName = programPathTextBox.Text,
                ServiceName = serviceNameTextBox.Text,
                LocalPorts = string.IsNullOrWhiteSpace(localPortsTextBox.Text) ?
                    "*" : localPortsTextBox.Text,
                RemotePorts = string.IsNullOrWhiteSpace(remotePortsTextBox.Text) ?
                    "*" : remotePortsTextBox.Text,
                LocalAddresses = string.IsNullOrWhiteSpace(localAddressTextBox.Text) ?
                    "*" : localAddressTextBox.Text,
                RemoteAddresses = string.IsNullOrWhiteSpace(remoteAddressTextBox.Text) ?
                    "*" : remoteAddressTextBox.Text,
                Profiles = GetProfileString(),
                Type = RuleType.Advanced,
                InterfaceTypes = GetInterfaceTypes(),
                IcmpTypesAndCodes = icmpTypesAndCodesTextBox.Text
            };
            this.RuleVm = rule;

            DialogResult = DialogResult.OK;
            Close();
        }

        private Directions GetDirection()
        {
            if (inboundRadioButton.Checked) return Directions.Incoming;
            if (outboundRadioButton.Checked) return Directions.Outgoing;
            return Directions.Incoming | Directions.Outgoing;
        }

        private string GetProfileString()
        {
            var profiles = new List<string>(3);
            if (domainCheckBox.Checked) profiles.Add("Domain");
            if (privateCheckBox.Checked) profiles.Add("Private");
            if (publicCheckBox.Checked) profiles.Add("Public");
            if (profiles.Count == 3 || profiles.Count == 0) return "All";
            return string.Join(", ", profiles);
        }

        public string GetInterfaceTypes()
        {
            var types = new List<string>(3);
            if (remoteAccessCheckBox.Checked) types.Add("RemoteAccess");
            if (wirelessCheckBox.Checked) types.Add("Wireless");
            if (lanCheckBox.Checked) types.Add("Lan");
            if (types.Count == 3 || types.Count == 0) return "All";
            return string.Join(",", types);
        }

        private void BrowseButton_Click(object sender, EventArgs e)
        {
            using var openFileDialog = new OpenFileDialog
            {
                Filter = "Executables (*.exe)|*.exe|All files (*.*)|*.*",
                Title = "Select a program"
            };
            if (openFileDialog.ShowDialog() == DialogResult.OK)
            {
                programPathTextBox.Text = openFileDialog.FileName;
            }
        }

        private void browseServiceButton_Click(object sender, EventArgs e)
        {
            var services = SystemDiscoveryService.GetServicesWithExePaths();
            using var browseForm = new BrowseServicesForm(services, _appSettings);
            if (browseForm.ShowDialog(this) == DialogResult.OK && browseForm.SelectedService != null)
            {
                serviceNameTextBox.Text = browseForm.SelectedService.ServiceName;
                if (!string.IsNullOrEmpty(browseForm.SelectedService.ExePath))
                {
                    programPathTextBox.Text = PathResolver.NormalizePath(browseForm.SelectedService.ExePath);
                }
            }
        }

        private void CancelButton_Click(object sender, EventArgs e)
        {
            this.DialogResult = DialogResult.Cancel;
            this.Close();
        }

        private void AddGroupButton_Click(object sender, EventArgs e)
        {
            string newGroupName = groupComboBox.Text;
            if (!string.IsNullOrWhiteSpace(newGroupName) && !newGroupName.EndsWith(MFWConstants.MfwRuleSuffix))
            {
                newGroupName += MFWConstants.MfwRuleSuffix;
            }

            if (!groupComboBox.Items.Contains(newGroupName))
            {
                groupComboBox.Items.Add(newGroupName);
                groupComboBox.SelectedItem = newGroupName;
            }
        }

        private void localPortsTextBox_Validating(object sender, CancelEventArgs e)
        {
            if (sender is TextBox textBox)
            {
                if (!ValidationUtility.ValidatePortString(textBox.Text, out string errorMessage))
                {
                    errorProvider1.SetError(textBox, errorMessage);
                    e.Cancel = true;
                }
                else
                {
                    errorProvider1.SetError(textBox, string.Empty);
                }
            }
        }

        private void remotePortsTextBox_Validating(object sender, CancelEventArgs e)
        {
            if (sender is TextBox textBox)
            {
                if (!ValidationUtility.ValidatePortString(textBox.Text, out string errorMessage))
                {
                    errorProvider1.SetError(textBox, errorMessage);
                    e.Cancel = true;
                }
                else
                {
                    errorProvider1.SetError(textBox, string.Empty);
                }
            }
        }

        private void localAddressTextBox_Validating(object sender, CancelEventArgs e)
        {
            if (sender is TextBox textBox)
            {
                if (!ValidationUtility.ValidateAddressString(textBox.Text, out string errorMessage))
                {
                    errorProvider1.SetError(textBox, errorMessage);
                    e.Cancel = true;
                }
                else
                {
                    errorProvider1.SetError(textBox, string.Empty);
                }
            }
        }

        private void remoteAddressTextBox_Validating(object sender, CancelEventArgs e)
        {
            if (sender is TextBox textBox)
            {
                if (!ValidationUtility.ValidateAddressString(textBox.Text, out string errorMessage))
                {
                    errorProvider1.SetError(textBox, errorMessage);
                    e.Cancel = true;
                }
                else
                {
                    errorProvider1.SetError(textBox, string.Empty);
                }
            }
        }

        private void icmpTypesAndCodesTextBox_Validating(object sender, CancelEventArgs e)
        {
            if (sender is TextBox textBox)
            {
                if (!ValidationUtility.ValidateIcmpString(textBox.Text, out string errorMessage))
                {
                    errorProvider1.SetError(textBox, errorMessage);
                    e.Cancel = true;
                }
                else
                {
                    errorProvider1.SetError(textBox, string.Empty);
                }
            }
        }
    }
}



--------------------------------------------------
// Full Path: C:/Users/anon/PROGRAMMING/C#/SimpleFirewall/VS Minimal Firewall/MinimalFirewall-NET8/Backups/v2.5.5 - ws/2.5.5.6 - security vulnerability fix 3/CreateAdvancedRuleForm.Designer.cs
--------------------------------------------------------------------------------
// File:CreateAdvancedRuleForm.Designer.cs
namespace MinimalFirewall
{
    partial class CreateAdvancedRuleForm
    {
        private System.ComponentModel.IContainer components = null;
        private System.Windows.Forms.Label labelName;
        private System.Windows.Forms.TextBox ruleNameTextBox;
        private System.Windows.Forms.Label labelDescription;
        private System.Windows.Forms.TextBox descriptionTextBox;
        private System.Windows.Forms.CheckBox enabledCheckBox;
        private System.Windows.Forms.GroupBox actionGroupBox;
        private System.Windows.Forms.RadioButton blockRadioButton;
        private System.Windows.Forms.RadioButton allowRadioButton;
        private System.Windows.Forms.GroupBox directionGroupBox;
        private System.Windows.Forms.RadioButton bothDirRadioButton;
        private System.Windows.Forms.RadioButton outboundRadioButton;
        private System.Windows.Forms.RadioButton inboundRadioButton;
        private System.Windows.Forms.GroupBox programGroupBox;
        private System.Windows.Forms.Button browseButton;
        private System.Windows.Forms.TextBox programPathTextBox;
        private System.Windows.Forms.Label labelProgram;
        private System.Windows.Forms.TextBox serviceNameTextBox;
        private System.Windows.Forms.Label labelService;
        private System.Windows.Forms.GroupBox protocolGroupBox;
        private DarkModeForms.FlatComboBox protocolComboBox;
        private System.Windows.Forms.Label labelProtocol;
        private System.Windows.Forms.GroupBox portsGroupBox;
        private System.Windows.Forms.TextBox remotePortsTextBox;
        private System.Windows.Forms.Label labelRemotePorts;
        private System.Windows.Forms.TextBox localPortsTextBox;
        private System.Windows.Forms.Label labelLocalPorts;
        private System.Windows.Forms.GroupBox icmpGroupBox;
        private System.Windows.Forms.TextBox icmpTypesAndCodesTextBox;
        private System.Windows.Forms.Label labelIcmpInfo;
        private System.Windows.Forms.GroupBox scopeGroupBox;
        private System.Windows.Forms.TextBox remoteAddressTextBox;
        private System.Windows.Forms.Label labelRemoteAddress;
        private System.Windows.Forms.TextBox localAddressTextBox;
        private System.Windows.Forms.Label labelLocalAddress;
        private System.Windows.Forms.GroupBox profilesGroupBox;
        private System.Windows.Forms.CheckBox publicCheckBox;
        private System.Windows.Forms.CheckBox privateCheckBox;
        private System.Windows.Forms.CheckBox domainCheckBox;
        private System.Windows.Forms.Button okButton;
        private System.Windows.Forms.Button cancelButton;
        private System.Windows.Forms.GroupBox interfaceTypesGroupBox;
        private System.Windows.Forms.CheckBox lanCheckBox;
        private System.Windows.Forms.CheckBox wirelessCheckBox;
        private System.Windows.Forms.CheckBox remoteAccessCheckBox;
        private System.Windows.Forms.Label labelGroup;
        private DarkModeForms.FlatComboBox groupComboBox;
        private System.Windows.Forms.Button addGroupButton;
        private System.Windows.Forms.Panel mainPanel;
        private System.Windows.Forms.Panel bottomPanel;
        private System.Windows.Forms.Label programPathNoteLabel;
        private System.Windows.Forms.Button browseServiceButton;
        private System.Windows.Forms.ErrorProvider errorProvider1;

        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        private void InitializeComponent()
        {
            this.components = new System.ComponentModel.Container();
            this.labelName = new System.Windows.Forms.Label();
            this.ruleNameTextBox = new System.Windows.Forms.TextBox();
            this.labelDescription = new System.Windows.Forms.Label();
            this.descriptionTextBox = new System.Windows.Forms.TextBox();
            this.enabledCheckBox = new System.Windows.Forms.CheckBox();
            this.actionGroupBox = new System.Windows.Forms.GroupBox();
            this.blockRadioButton = new System.Windows.Forms.RadioButton();
            this.allowRadioButton = new System.Windows.Forms.RadioButton();
            this.directionGroupBox = new System.Windows.Forms.GroupBox();
            this.bothDirRadioButton = new System.Windows.Forms.RadioButton();
            this.outboundRadioButton = new System.Windows.Forms.RadioButton();
            this.inboundRadioButton = new System.Windows.Forms.RadioButton();
            this.programGroupBox = new System.Windows.Forms.GroupBox();
            this.browseServiceButton = new System.Windows.Forms.Button();
            this.programPathNoteLabel = new System.Windows.Forms.Label();
            this.serviceNameTextBox = new System.Windows.Forms.TextBox();
            this.labelService = new System.Windows.Forms.Label();
            this.browseButton = new System.Windows.Forms.Button();
            this.programPathTextBox = new System.Windows.Forms.TextBox();
            this.labelProgram = new System.Windows.Forms.Label();
            this.protocolGroupBox = new System.Windows.Forms.GroupBox();
            this.protocolComboBox = new DarkModeForms.FlatComboBox();
            this.labelProtocol = new System.Windows.Forms.Label();
            this.portsGroupBox = new System.Windows.Forms.GroupBox();
            this.remotePortsTextBox = new System.Windows.Forms.TextBox();
            this.labelRemotePorts = new System.Windows.Forms.Label();
            this.localPortsTextBox = new System.Windows.Forms.TextBox();
            this.labelLocalPorts = new System.Windows.Forms.Label();
            this.icmpGroupBox = new System.Windows.Forms.GroupBox();
            this.icmpTypesAndCodesTextBox = new System.Windows.Forms.TextBox();
            this.labelIcmpInfo = new System.Windows.Forms.Label();
            this.scopeGroupBox = new System.Windows.Forms.GroupBox();
            this.remoteAddressTextBox = new System.Windows.Forms.TextBox();
            this.labelRemoteAddress = new System.Windows.Forms.Label();
            this.localAddressTextBox = new System.Windows.Forms.TextBox();
            this.labelLocalAddress = new System.Windows.Forms.Label();
            this.profilesGroupBox = new System.Windows.Forms.GroupBox();
            this.publicCheckBox = new System.Windows.Forms.CheckBox();
            this.privateCheckBox = new System.Windows.Forms.CheckBox();
            this.domainCheckBox = new System.Windows.Forms.CheckBox();
            this.okButton = new System.Windows.Forms.Button();
            this.cancelButton = new System.Windows.Forms.Button();
            this.interfaceTypesGroupBox = new System.Windows.Forms.GroupBox();
            this.lanCheckBox = new System.Windows.Forms.CheckBox();
            this.wirelessCheckBox = new System.Windows.Forms.CheckBox();
            this.remoteAccessCheckBox = new System.Windows.Forms.CheckBox();
            this.labelGroup = new System.Windows.Forms.Label();
            this.groupComboBox = new DarkModeForms.FlatComboBox();
            this.addGroupButton = new System.Windows.Forms.Button();
            this.mainPanel = new System.Windows.Forms.Panel();
            this.bottomPanel = new System.Windows.Forms.Panel();
            this.errorProvider1 = new System.Windows.Forms.ErrorProvider(this.components);
            this.actionGroupBox.SuspendLayout();
            this.directionGroupBox.SuspendLayout();
            this.programGroupBox.SuspendLayout();
            this.protocolGroupBox.SuspendLayout();
            this.portsGroupBox.SuspendLayout();
            this.icmpGroupBox.SuspendLayout();
            this.scopeGroupBox.SuspendLayout();
            this.profilesGroupBox.SuspendLayout();
            this.interfaceTypesGroupBox.SuspendLayout();
            this.mainPanel.SuspendLayout();
            this.bottomPanel.SuspendLayout();
            ((System.ComponentModel.ISupportInitialize)(this.errorProvider1)).BeginInit();
            this.SuspendLayout();
            // 
            // labelName
            // 
            this.labelName.AutoSize = true;
            this.labelName.Location = new System.Drawing.Point(12, 15);
            this.labelName.Name = "labelName";
            this.labelName.Size = new System.Drawing.Size(49, 20);
            this.labelName.TabIndex = 0;
            this.labelName.Text = "Name";
            // 
            // ruleNameTextBox
            // 
            this.ruleNameTextBox.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)
            | System.Windows.Forms.AnchorStyles.Right)));
            this.ruleNameTextBox.Location = new System.Drawing.Point(80, 12);
            this.ruleNameTextBox.Name = "ruleNameTextBox";
            this.ruleNameTextBox.Size = new System.Drawing.Size(692, 27);
            this.ruleNameTextBox.TabIndex = 1;
            // 
            // labelDescription
            // 
            this.labelDescription.AutoSize = true;
            this.labelDescription.Location = new System.Drawing.Point(12, 44);
            this.labelDescription.Name = "labelDescription";
            this.labelDescription.Size = new System.Drawing.Size(85, 20);
            this.labelDescription.TabIndex = 2;
            this.labelDescription.Text = "Description";
            // 
            // descriptionTextBox
            // 
            this.descriptionTextBox.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)
            | System.Windows.Forms.AnchorStyles.Right)));
            this.descriptionTextBox.Location = new System.Drawing.Point(80, 41);
            this.descriptionTextBox.Name = "descriptionTextBox";
            this.descriptionTextBox.Size = new System.Drawing.Size(692, 27);
            this.descriptionTextBox.TabIndex = 3;
            // 
            // enabledCheckBox
            // 
            this.enabledCheckBox.AutoSize = true;
            this.enabledCheckBox.Checked = true;
            this.enabledCheckBox.CheckState = System.Windows.Forms.CheckState.Checked;
            this.enabledCheckBox.Location = new System.Drawing.Point(15, 75);
            this.enabledCheckBox.Name = "enabledCheckBox";
            this.enabledCheckBox.Size = new System.Drawing.Size(84, 24);
            this.enabledCheckBox.TabIndex = 4;
            this.enabledCheckBox.Text = "Enabled";
            this.enabledCheckBox.UseVisualStyleBackColor = true;
            // 
            // actionGroupBox
            // 
            this.actionGroupBox.Controls.Add(this.blockRadioButton);
            this.actionGroupBox.Controls.Add(this.allowRadioButton);
            this.actionGroupBox.Location = new System.Drawing.Point(15, 100);
            this.actionGroupBox.Name = "actionGroupBox";
            this.actionGroupBox.Size = new System.Drawing.Size(130, 105);
            this.actionGroupBox.TabIndex = 5;
            this.actionGroupBox.TabStop = false;
            this.actionGroupBox.Text = "Action";
            // 
            // blockRadioButton
            // 
            this.blockRadioButton.AutoSize = true;
            this.blockRadioButton.Location = new System.Drawing.Point(15, 60);
            this.blockRadioButton.Name = "blockRadioButton";
            this.blockRadioButton.Size = new System.Drawing.Size(66, 24);
            this.blockRadioButton.TabIndex = 1;
            this.blockRadioButton.Text = "Block";
            this.blockRadioButton.UseVisualStyleBackColor = true;
            // 
            // allowRadioButton
            // 
            this.allowRadioButton.AutoSize = true;
            this.allowRadioButton.Checked = true;
            this.allowRadioButton.Location = new System.Drawing.Point(15, 30);
            this.allowRadioButton.Name = "allowRadioButton";
            this.allowRadioButton.Size = new System.Drawing.Size(68, 24);
            this.allowRadioButton.TabIndex = 0;
            this.allowRadioButton.TabStop = true;
            this.allowRadioButton.Text = "Allow";
            this.allowRadioButton.UseVisualStyleBackColor = true;
            // 
            // directionGroupBox
            // 
            this.directionGroupBox.Controls.Add(this.bothDirRadioButton);
            this.directionGroupBox.Controls.Add(this.outboundRadioButton);
            this.directionGroupBox.Controls.Add(this.inboundRadioButton);
            this.directionGroupBox.Location = new System.Drawing.Point(151, 100);
            this.directionGroupBox.Name = "directionGroupBox";
            this.directionGroupBox.Size = new System.Drawing.Size(130, 105);
            this.directionGroupBox.TabIndex = 6;
            this.directionGroupBox.TabStop = false;
            this.directionGroupBox.Text = "Direction";
            // 
            // bothDirRadioButton
            // 
            this.bothDirRadioButton.AutoSize = true;
            this.bothDirRadioButton.Location = new System.Drawing.Point(15, 72);
            this.bothDirRadioButton.Name = "bothDirRadioButton";
            this.bothDirRadioButton.Size = new System.Drawing.Size(62, 24);
            this.bothDirRadioButton.TabIndex = 2;
            this.bothDirRadioButton.Text = "Both";
            this.bothDirRadioButton.UseVisualStyleBackColor = true;
            // 
            // outboundRadioButton
            // 
            this.outboundRadioButton.AutoSize = true;
            this.outboundRadioButton.Checked = true;
            this.outboundRadioButton.Location = new System.Drawing.Point(15, 47);
            this.outboundRadioButton.Name = "outboundRadioButton";
            this.outboundRadioButton.Size = new System.Drawing.Size(98, 24);
            this.outboundRadioButton.TabIndex = 1;
            this.outboundRadioButton.TabStop = true;
            this.outboundRadioButton.Text = "Outbound";
            this.outboundRadioButton.UseVisualStyleBackColor = true;
            // 
            // inboundRadioButton
            // 
            this.inboundRadioButton.AutoSize = true;
            this.inboundRadioButton.Location = new System.Drawing.Point(15, 22);
            this.inboundRadioButton.Name = "inboundRadioButton";
            this.inboundRadioButton.Size = new System.Drawing.Size(86, 24);
            this.inboundRadioButton.TabIndex = 0;
            this.inboundRadioButton.Text = "Inbound";
            this.inboundRadioButton.UseVisualStyleBackColor = true;
            // 
            // programGroupBox
            // 
            this.programGroupBox.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)
            | System.Windows.Forms.AnchorStyles.Right)));
            this.programGroupBox.Controls.Add(this.browseServiceButton);
            this.programGroupBox.Controls.Add(this.programPathNoteLabel);
            this.programGroupBox.Controls.Add(this.serviceNameTextBox);
            this.programGroupBox.Controls.Add(this.labelService);
            this.programGroupBox.Controls.Add(this.browseButton);
            this.programGroupBox.Controls.Add(this.programPathTextBox);
            this.programGroupBox.Controls.Add(this.labelProgram);
            this.programGroupBox.Location = new System.Drawing.Point(15, 211);
            this.programGroupBox.Name = "programGroupBox";
            this.programGroupBox.Size = new System.Drawing.Size(757, 140);
            this.programGroupBox.TabIndex = 7;
            this.programGroupBox.TabStop = false;
            this.programGroupBox.Text = "Program and Service";
            // 
            // browseServiceButton
            // 
            this.browseServiceButton.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
            this.browseServiceButton.Location = new System.Drawing.Point(657, 82);
            this.browseServiceButton.Name = "browseServiceButton";
            this.browseServiceButton.Size = new System.Drawing.Size(94, 29);
            this.browseServiceButton.TabIndex = 7;
            this.browseServiceButton.Text = "Browse...";
            this.browseServiceButton.UseVisualStyleBackColor = true;
            this.browseServiceButton.Click += new System.EventHandler(this.browseServiceButton_Click);
            // 
            // programPathNoteLabel
            // 
            this.programPathNoteLabel.AutoSize = true;
            this.programPathNoteLabel.ForeColor = System.Drawing.SystemColors.GrayText;
            this.programPathNoteLabel.Location = new System.Drawing.Point(75, 50);
            this.programPathNoteLabel.Name = "programPathNoteLabel";
            this.programPathNoteLabel.Size = new System.Drawing.Size(431, 20);
            this.programPathNoteLabel.TabIndex = 6;
            this.programPathNoteLabel.Text = "Leave blank to apply the rule to any program hosting the service.";
            // 
            // serviceNameTextBox
            // 
            this.serviceNameTextBox.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)
            | System.Windows.Forms.AnchorStyles.Right)));
            this.serviceNameTextBox.Location = new System.Drawing.Point(75, 82);
            this.serviceNameTextBox.Name = "serviceNameTextBox";
            this.serviceNameTextBox.Size = new System.Drawing.Size(576, 27);
            this.serviceNameTextBox.TabIndex = 4;
            // 
            // labelService
            // 
            this.labelService.AutoSize = true;
            this.labelService.Location = new System.Drawing.Point(15, 85);
            this.labelService.Name = "labelService";
            this.labelService.Size = new System.Drawing.Size(56, 20);
            this.labelService.TabIndex = 3;
            this.labelService.Text = "Service";
            // 
            // browseButton
            // 
            this.browseButton.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
            this.browseButton.Location = new System.Drawing.Point(657, 22);
            this.browseButton.Name = "browseButton";
            this.browseButton.Size = new System.Drawing.Size(94, 29);
            this.browseButton.TabIndex = 2;
            this.browseButton.Text = "Browse...";
            this.browseButton.UseVisualStyleBackColor = true;
            this.browseButton.Click += new System.EventHandler(this.BrowseButton_Click);
            // 
            // programPathTextBox
            // 
            this.programPathTextBox.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)
            | System.Windows.Forms.AnchorStyles.Right)));
            this.programPathTextBox.Location = new System.Drawing.Point(75, 22);
            this.programPathTextBox.Name = "programPathTextBox";
            this.programPathTextBox.Size = new System.Drawing.Size(576, 27);
            this.programPathTextBox.TabIndex = 1;
            // 
            // labelProgram
            // 
            this.labelProgram.AutoSize = true;
            this.labelProgram.Location = new System.Drawing.Point(15, 25);
            this.labelProgram.Name = "labelProgram";
            this.labelProgram.Size = new System.Drawing.Size(66, 20);
            this.labelProgram.TabIndex = 0;
            this.labelProgram.Text = "Program";
            // 
            // protocolGroupBox
            // 
            this.protocolGroupBox.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)
            | System.Windows.Forms.AnchorStyles.Right)));
            this.protocolGroupBox.Controls.Add(this.protocolComboBox);
            this.protocolGroupBox.Controls.Add(this.labelProtocol);
            this.protocolGroupBox.Location = new System.Drawing.Point(15, 357);
            this.protocolGroupBox.Name = "protocolGroupBox";
            this.protocolGroupBox.Size = new System.Drawing.Size(757, 60);
            this.protocolGroupBox.TabIndex = 8;
            this.protocolGroupBox.TabStop = false;
            this.protocolGroupBox.Text = "Protocol";
            // 
            // protocolComboBox
            // 
            this.protocolComboBox.BorderColor = System.Drawing.Color.Gray;
            this.protocolComboBox.ButtonColor = System.Drawing.Color.LightGray;
            this.protocolComboBox.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;
            this.protocolComboBox.FormattingEnabled = true;
            this.protocolComboBox.Location = new System.Drawing.Point(75, 22);
            this.protocolComboBox.Name = "protocolComboBox";
            this.protocolComboBox.Size = new System.Drawing.Size(150, 28);
            this.protocolComboBox.TabIndex = 1;
            this.protocolComboBox.SelectedIndexChanged += new System.EventHandler(this.ProtocolComboBox_SelectedIndexChanged);
            // 
            // labelProtocol
            // 
            this.labelProtocol.AutoSize = true;
            this.labelProtocol.Location = new System.Drawing.Point(15, 25);
            this.labelProtocol.Name = "labelProtocol";
            this.labelProtocol.Size = new System.Drawing.Size(64, 20);
            this.labelProtocol.TabIndex = 0;
            this.labelProtocol.Text = "Protocol";
            // 
            // portsGroupBox
            // 
            this.portsGroupBox.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)
            | System.Windows.Forms.AnchorStyles.Right)));
            this.portsGroupBox.Controls.Add(this.remotePortsTextBox);
            this.portsGroupBox.Controls.Add(this.labelRemotePorts);
            this.portsGroupBox.Controls.Add(this.localPortsTextBox);
            this.portsGroupBox.Controls.Add(this.labelLocalPorts);
            this.portsGroupBox.Location = new System.Drawing.Point(15, 423);
            this.portsGroupBox.Name = "portsGroupBox";
            this.portsGroupBox.Size = new System.Drawing.Size(757, 90);
            this.portsGroupBox.TabIndex = 9;
            this.portsGroupBox.TabStop = false;
            this.portsGroupBox.Text = "Ports";
            this.portsGroupBox.Visible = false;
            // 
            // remotePortsTextBox
            // 
            this.remotePortsTextBox.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)
            | System.Windows.Forms.AnchorStyles.Right)));
            this.remotePortsTextBox.Location = new System.Drawing.Point(90, 53);
            this.remotePortsTextBox.Name = "remotePortsTextBox";
            this.remotePortsTextBox.Size = new System.Drawing.Size(657, 27);
            this.remotePortsTextBox.TabIndex = 3;
            this.remotePortsTextBox.Text = "*";
            this.remotePortsTextBox.Validating += new System.ComponentModel.CancelEventHandler(this.remotePortsTextBox_Validating);
            // 
            // labelRemotePorts
            // 
            this.labelRemotePorts.AutoSize = true;
            this.labelRemotePorts.Location = new System.Drawing.Point(6, 56);
            this.labelRemotePorts.Name = "labelRemotePorts";
            this.labelRemotePorts.Size = new System.Drawing.Size(95, 20);
            this.labelRemotePorts.TabIndex = 2;
            this.labelRemotePorts.Text = "Remote Ports";
            // 
            // localPortsTextBox
            // 
            this.localPortsTextBox.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)
            | System.Windows.Forms.AnchorStyles.Right)));
            this.localPortsTextBox.Location = new System.Drawing.Point(90, 22);
            this.localPortsTextBox.Name = "localPortsTextBox";
            this.localPortsTextBox.Size = new System.Drawing.Size(657, 27);
            this.localPortsTextBox.TabIndex = 1;
            this.localPortsTextBox.Text = "*";
            this.localPortsTextBox.Validating += new System.ComponentModel.CancelEventHandler(this.localPortsTextBox_Validating);
            // 
            // labelLocalPorts
            // 
            this.labelLocalPorts.AutoSize = true;
            this.labelLocalPorts.Location = new System.Drawing.Point(6, 25);
            this.labelLocalPorts.Name = "labelLocalPorts";
            this.labelLocalPorts.Size = new System.Drawing.Size(81, 20);
            this.labelLocalPorts.TabIndex = 0;
            this.labelLocalPorts.Text = "Local Ports";
            // 
            // icmpGroupBox
            // 
            this.icmpGroupBox.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)
            | System.Windows.Forms.AnchorStyles.Right)));
            this.icmpGroupBox.Controls.Add(this.icmpTypesAndCodesTextBox);
            this.icmpGroupBox.Controls.Add(this.labelIcmpInfo);
            this.icmpGroupBox.Location = new System.Drawing.Point(15, 423);
            this.icmpGroupBox.Name = "icmpGroupBox";
            this.icmpGroupBox.Size = new System.Drawing.Size(757, 90);
            this.icmpGroupBox.TabIndex = 10;
            this.icmpGroupBox.TabStop = false;
            this.icmpGroupBox.Text = "ICMP Settings";
            this.icmpGroupBox.Visible = false;
            // 
            // icmpTypesAndCodesTextBox
            // 
            this.icmpTypesAndCodesTextBox.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)
            | System.Windows.Forms.AnchorStyles.Right)));
            this.icmpTypesAndCodesTextBox.Location = new System.Drawing.Point(110, 22);
            this.icmpTypesAndCodesTextBox.Name = "icmpTypesAndCodesTextBox";
            this.icmpTypesAndCodesTextBox.Size = new System.Drawing.Size(637, 27);
            this.icmpTypesAndCodesTextBox.TabIndex = 1;
            this.icmpTypesAndCodesTextBox.Text = "*";
            this.icmpTypesAndCodesTextBox.Validating += new System.ComponentModel.CancelEventHandler(this.icmpTypesAndCodesTextBox_Validating);
            // 
            // labelIcmpInfo
            // 
            this.labelIcmpInfo.AutoSize = true;
            this.labelIcmpInfo.Location = new System.Drawing.Point(15, 25);
            this.labelIcmpInfo.Name = "labelIcmpInfo";
            this.labelIcmpInfo.Size = new System.Drawing.Size(125, 20);
            this.labelIcmpInfo.TabIndex = 0;
            this.labelIcmpInfo.Text = "Type:Code (e.g. 8:0)";
            // 
            // scopeGroupBox
            // 
            this.scopeGroupBox.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)
            | System.Windows.Forms.AnchorStyles.Right)));
            this.scopeGroupBox.Controls.Add(this.remoteAddressTextBox);
            this.scopeGroupBox.Controls.Add(this.labelRemoteAddress);
            this.scopeGroupBox.Controls.Add(this.localAddressTextBox);
            this.scopeGroupBox.Controls.Add(this.labelLocalAddress);
            this.scopeGroupBox.Location = new System.Drawing.Point(15, 519);
            this.scopeGroupBox.Name = "scopeGroupBox";
            this.scopeGroupBox.Size = new System.Drawing.Size(757, 90);
            this.scopeGroupBox.TabIndex = 11;
            this.scopeGroupBox.TabStop = false;
            this.scopeGroupBox.Text = "Scope (Addresses)";
            // 
            // remoteAddressTextBox
            // 
            this.remoteAddressTextBox.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)
            | System.Windows.Forms.AnchorStyles.Right)));
            this.remoteAddressTextBox.Location = new System.Drawing.Point(105, 53);
            this.remoteAddressTextBox.Name = "remoteAddressTextBox";
            this.remoteAddressTextBox.Size = new System.Drawing.Size(642, 27);
            this.remoteAddressTextBox.TabIndex = 3;
            this.remoteAddressTextBox.Text = "*";
            this.remoteAddressTextBox.Validating += new System.ComponentModel.CancelEventHandler(this.remoteAddressTextBox_Validating);
            // 
            // labelRemoteAddress
            // 
            this.labelRemoteAddress.AutoSize = true;
            this.labelRemoteAddress.Location = new System.Drawing.Point(6, 56);
            this.labelRemoteAddress.Name = "labelRemoteAddress";
            this.labelRemoteAddress.Size = new System.Drawing.Size(117, 20);
            this.labelRemoteAddress.TabIndex = 2;
            this.labelRemoteAddress.Text = "Remote Address";
            // 
            // localAddressTextBox
            // 
            this.localAddressTextBox.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)
            | System.Windows.Forms.AnchorStyles.Right)));
            this.localAddressTextBox.Location = new System.Drawing.Point(105, 22);
            this.localAddressTextBox.Name = "localAddressTextBox";
            this.localAddressTextBox.Size = new System.Drawing.Size(642, 27);
            this.localAddressTextBox.TabIndex = 1;
            this.localAddressTextBox.Text = "*";
            this.localAddressTextBox.Validating += new System.ComponentModel.CancelEventHandler(this.localAddressTextBox_Validating);
            // 
            // labelLocalAddress
            // 
            this.labelLocalAddress.AutoSize = true;
            this.labelLocalAddress.Location = new System.Drawing.Point(6, 25);
            this.labelLocalAddress.Name = "labelLocalAddress";
            this.labelLocalAddress.Size = new System.Drawing.Size(101, 20);
            this.labelLocalAddress.TabIndex = 0;
            this.labelLocalAddress.Text = "Local Address";
            // 
            // profilesGroupBox
            // 
            this.profilesGroupBox.Controls.Add(this.publicCheckBox);
            this.profilesGroupBox.Controls.Add(this.privateCheckBox);
            this.profilesGroupBox.Controls.Add(this.domainCheckBox);
            this.profilesGroupBox.Location = new System.Drawing.Point(287, 100);
            this.profilesGroupBox.Name = "profilesGroupBox";
            this.profilesGroupBox.Size = new System.Drawing.Size(130, 105);
            this.profilesGroupBox.TabIndex = 12;
            this.profilesGroupBox.TabStop = false;
            this.profilesGroupBox.Text = "Profiles";
            // 
            // publicCheckBox
            // 
            this.publicCheckBox.AutoSize = true;
            this.publicCheckBox.Checked = true;
            this.publicCheckBox.CheckState = System.Windows.Forms.CheckState.Checked;
            this.publicCheckBox.Location = new System.Drawing.Point(15, 72);
            this.publicCheckBox.Name = "publicCheckBox";
            this.publicCheckBox.Size = new System.Drawing.Size(71, 24);
            this.publicCheckBox.TabIndex = 2;
            this.publicCheckBox.Text = "Public";
            this.publicCheckBox.UseVisualStyleBackColor = true;
            // 
            // privateCheckBox
            // 
            this.privateCheckBox.AutoSize = true;
            this.privateCheckBox.Checked = true;
            this.privateCheckBox.CheckState = System.Windows.Forms.CheckState.Checked;
            this.privateCheckBox.Location = new System.Drawing.Point(15, 47);
            this.privateCheckBox.Name = "privateCheckBox";
            this.privateCheckBox.Size = new System.Drawing.Size(75, 24);
            this.privateCheckBox.TabIndex = 1;
            this.privateCheckBox.Text = "Private";
            this.privateCheckBox.UseVisualStyleBackColor = true;
            // 
            // domainCheckBox
            // 
            this.domainCheckBox.AutoSize = true;
            this.domainCheckBox.Checked = true;
            this.domainCheckBox.CheckState = System.Windows.Forms.CheckState.Checked;
            this.domainCheckBox.Location = new System.Drawing.Point(15, 22);
            this.domainCheckBox.Name = "domainCheckBox";
            this.domainCheckBox.Size = new System.Drawing.Size(83, 24);
            this.domainCheckBox.TabIndex = 0;
            this.domainCheckBox.Text = "Domain";
            this.domainCheckBox.UseVisualStyleBackColor = true;
            // 
            // okButton
            // 
            this.okButton.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
            this.okButton.Location = new System.Drawing.Point(580, 8);
            this.okButton.Name = "okButton";
            this.okButton.Size = new System.Drawing.Size(100, 36);
            this.okButton.TabIndex = 13;
            this.okButton.Text = "OK";
            this.okButton.UseVisualStyleBackColor = true;
            this.okButton.Click += new System.EventHandler(this.OkButton_Click);
            // 
            // cancelButton
            // 
            this.cancelButton.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
            this.cancelButton.Location = new System.Drawing.Point(688, 8);
            this.cancelButton.Name = "cancelButton";
            this.cancelButton.Size = new System.Drawing.Size(100, 36);
            this.cancelButton.TabIndex = 14;
            this.cancelButton.Text = "Cancel";
            this.cancelButton.UseVisualStyleBackColor = true;
            this.cancelButton.Click += new System.EventHandler(this.CancelButton_Click);
            // 
            // interfaceTypesGroupBox
            // 
            this.interfaceTypesGroupBox.Controls.Add(this.lanCheckBox);
            this.interfaceTypesGroupBox.Controls.Add(this.wirelessCheckBox);
            this.interfaceTypesGroupBox.Controls.Add(this.remoteAccessCheckBox);
            this.interfaceTypesGroupBox.Location = new System.Drawing.Point(423, 100);
            this.interfaceTypesGroupBox.Name = "interfaceTypesGroupBox";
            this.interfaceTypesGroupBox.Size = new System.Drawing.Size(149, 105);
            this.interfaceTypesGroupBox.TabIndex = 15;
            this.interfaceTypesGroupBox.TabStop = false;
            this.interfaceTypesGroupBox.Text = "Interface Types";
            // 
            // lanCheckBox
            // 
            this.lanCheckBox.AutoSize = true;
            this.lanCheckBox.Checked = true;
            this.lanCheckBox.CheckState = System.Windows.Forms.CheckState.Checked;
            this.lanCheckBox.Location = new System.Drawing.Point(15, 72);
            this.lanCheckBox.Name = "lanCheckBox";
            this.lanCheckBox.Size = new System.Drawing.Size(116, 24);
            this.lanCheckBox.TabIndex = 2;
            this.lanCheckBox.Text = "Wired (LAN)";
            this.lanCheckBox.UseVisualStyleBackColor = true;
            // 
            // wirelessCheckBox
            // 
            this.wirelessCheckBox.AutoSize = true;
            this.wirelessCheckBox.Checked = true;
            this.wirelessCheckBox.CheckState = System.Windows.Forms.CheckState.Checked;
            this.wirelessCheckBox.Location = new System.Drawing.Point(15, 47);
            this.wirelessCheckBox.Name = "wirelessCheckBox";
            this.wirelessCheckBox.Size = new System.Drawing.Size(85, 24);
            this.wirelessCheckBox.TabIndex = 1;
            this.wirelessCheckBox.Text = "Wireless";
            this.wirelessCheckBox.UseVisualStyleBackColor = true;
            // 
            // remoteAccessCheckBox
            // 
            this.remoteAccessCheckBox.AutoSize = true;
            this.remoteAccessCheckBox.Checked = true;
            this.remoteAccessCheckBox.CheckState = System.Windows.Forms.CheckState.Checked;
            this.remoteAccessCheckBox.Location = new System.Drawing.Point(15, 22);
            this.remoteAccessCheckBox.Name = "remoteAccessCheckBox";
            this.remoteAccessCheckBox.Size = new System.Drawing.Size(126, 24);
            this.remoteAccessCheckBox.TabIndex = 0;
            this.remoteAccessCheckBox.Text = "Remote (VPN)";
            this.remoteAccessCheckBox.UseVisualStyleBackColor = true;
            // 
            // labelGroup
            // 
            this.labelGroup.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)));
            this.labelGroup.AutoSize = true;
            this.labelGroup.Location = new System.Drawing.Point(12, 16);
            this.labelGroup.Name = "labelGroup";
            this.labelGroup.Size = new System.Drawing.Size(50, 20);
            this.labelGroup.TabIndex = 16;
            this.labelGroup.Text = "Group";
            // 
            // groupComboBox
            // 
            this.groupComboBox.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)
            | System.Windows.Forms.AnchorStyles.Right)));
            this.groupComboBox.BorderColor = System.Drawing.Color.Gray;
            this.groupComboBox.ButtonColor = System.Drawing.Color.LightGray;
            this.groupComboBox.FormattingEnabled = true;
            this.groupComboBox.Location = new System.Drawing.Point(80, 13);
            this.groupComboBox.Name = "groupComboBox";
            this.groupComboBox.Size = new System.Drawing.Size(350, 28);
            this.groupComboBox.TabIndex = 17;
            // 
            // addGroupButton
            // 
            this.addGroupButton.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
            this.addGroupButton.Location = new System.Drawing.Point(436, 13);
            this.addGroupButton.Name = "addGroupButton";
            this.addGroupButton.Size = new System.Drawing.Size(110, 29);
            this.addGroupButton.TabIndex = 18;
            this.addGroupButton.Text = "Add Group";
            this.addGroupButton.UseVisualStyleBackColor = true;
            this.addGroupButton.Click += new System.EventHandler(this.AddGroupButton_Click);
            // 
            // mainPanel
            // 
            this.mainPanel.AutoScroll = true;
            this.mainPanel.Controls.Add(this.labelName);
            this.mainPanel.Controls.Add(this.ruleNameTextBox);
            this.mainPanel.Controls.Add(this.labelDescription);
            this.mainPanel.Controls.Add(this.descriptionTextBox);
            this.mainPanel.Controls.Add(this.enabledCheckBox);
            this.mainPanel.Controls.Add(this.actionGroupBox);
            this.mainPanel.Controls.Add(this.directionGroupBox);
            this.mainPanel.Controls.Add(this.profilesGroupBox);
            this.mainPanel.Controls.Add(this.interfaceTypesGroupBox);
            this.mainPanel.Controls.Add(this.programGroupBox);
            this.mainPanel.Controls.Add(this.protocolGroupBox);
            this.mainPanel.Controls.Add(this.portsGroupBox);
            this.mainPanel.Controls.Add(this.icmpGroupBox);
            this.mainPanel.Controls.Add(this.scopeGroupBox);
            this.mainPanel.Dock = System.Windows.Forms.DockStyle.Fill;
            this.mainPanel.Location = new System.Drawing.Point(0, 0);
            this.mainPanel.Name = "mainPanel";
            this.mainPanel.Size = new System.Drawing.Size(800, 560);
            this.mainPanel.TabIndex = 19;
            // 
            // bottomPanel
            // 
            this.bottomPanel.Controls.Add(this.addGroupButton);
            this.bottomPanel.Controls.Add(this.groupComboBox);
            this.bottomPanel.Controls.Add(this.labelGroup);
            this.bottomPanel.Controls.Add(this.cancelButton);
            this.bottomPanel.Controls.Add(this.okButton);
            this.bottomPanel.Dock = System.Windows.Forms.DockStyle.Bottom;
            this.bottomPanel.Location = new System.Drawing.Point(0, 560);
            this.bottomPanel.Name = "bottomPanel";
            this.bottomPanel.Size = new System.Drawing.Size(800, 60);
            this.bottomPanel.TabIndex = 20;
            // 
            // errorProvider1
            // 
            this.errorProvider1.ContainerControl = this;
            // 
            // CreateAdvancedRuleForm
            // 
            this.AutoScaleDimensions = new System.Drawing.SizeF(8F, 20F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.ClientSize = new System.Drawing.Size(800, 620);
            this.Controls.Add(this.mainPanel);
            this.Controls.Add(this.bottomPanel);
            this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.Sizable;
            this.MaximizeBox = true;
            this.MinimizeBox = true;
            this.MinimumSize = new System.Drawing.Size(816, 400);
            this.Name = "CreateAdvancedRuleForm";
            this.StartPosition = System.Windows.Forms.FormStartPosition.CenterParent;
            this.Text = "Create Advanced Rule";
            this.actionGroupBox.ResumeLayout(false);
            this.actionGroupBox.PerformLayout();
            this.directionGroupBox.ResumeLayout(false);
            this.directionGroupBox.PerformLayout();
            this.programGroupBox.ResumeLayout(false);
            this.programGroupBox.PerformLayout();
            this.protocolGroupBox.ResumeLayout(false);
            this.protocolGroupBox.PerformLayout();
            this.portsGroupBox.ResumeLayout(false);
            this.portsGroupBox.PerformLayout();
            this.icmpGroupBox.ResumeLayout(false);
            this.icmpGroupBox.PerformLayout();
            this.scopeGroupBox.ResumeLayout(false);
            this.scopeGroupBox.PerformLayout();
            this.profilesGroupBox.ResumeLayout(false);
            this.profilesGroupBox.PerformLayout();
            this.interfaceTypesGroupBox.ResumeLayout(false);
            this.interfaceTypesGroupBox.PerformLayout();
            this.mainPanel.ResumeLayout(false);
            this.mainPanel.PerformLayout();
            this.bottomPanel.ResumeLayout(false);
            this.bottomPanel.PerformLayout();
            ((System.ComponentModel.ISupportInitialize)(this.errorProvider1)).EndInit();
            this.ResumeLayout(false);

        }
        #endregion
    }
}

--------------------------------------------------
// Full Path: C:/Users/anon/PROGRAMMING/C#/SimpleFirewall/VS Minimal Firewall/MinimalFirewall-NET8/Backups/v2.5.5 - ws/2.5.5.6 - security vulnerability fix 3/CreateProgramRuleForm.cs
--------------------------------------------------------------------------------
// File: CreateProgramRuleForm.cs
using DarkModeForms;

namespace MinimalFirewall
{
    public partial class CreateProgramRuleForm : Form
    {
        private readonly string[] _filePaths;
        private readonly FirewallActionsService _actionsService;
        private readonly DarkModeCS dm;

        public CreateProgramRuleForm(string[] filePaths, FirewallActionsService actionsService)
        {
            InitializeComponent();
            dm = new DarkModeCS(this);
            _filePaths = filePaths;
            _actionsService = actionsService;
            programListLabel.Text = filePaths.Length == 1
                ? $"Program: {System.IO.Path.GetFileName(filePaths[0])}"
                : $"{filePaths.Length} programs selected.";
        }

        private void okButton_Click(object sender, EventArgs e)
        {
            string action = allowRadio.Checked ? "Allow" : "Block";
            string direction = allowRadio.Checked ? allowDirectionCombo.Text : blockDirectionCombo.Text;
            string finalAction = $"{action} ({direction})";

            _actionsService.ApplyApplicationRuleChange(new List<string>(_filePaths), finalAction);
            DialogResult = DialogResult.OK;
        }

        private void cancelButton_Click(object sender, EventArgs e)
        {
            DialogResult = DialogResult.Cancel;
        }
    }
}

--------------------------------------------------
// Full Path: C:/Users/anon/PROGRAMMING/C#/SimpleFirewall/VS Minimal Firewall/MinimalFirewall-NET8/Backups/v2.5.5 - ws/2.5.5.6 - security vulnerability fix 3/CreateProgramRuleForm.Designer.cs
--------------------------------------------------------------------------------
// File: CreateProgramRuleForm.Designer.cs
namespace MinimalFirewall
{
    public partial class CreateProgramRuleForm
    {
        private System.ComponentModel.IContainer components = null;
        private System.Windows.Forms.Label programListLabel;
        private System.Windows.Forms.RadioButton allowRadio;
        private System.Windows.Forms.RadioButton blockRadio;
        private DarkModeForms.FlatComboBox allowDirectionCombo;
        private DarkModeForms.FlatComboBox blockDirectionCombo;
        private System.Windows.Forms.Button okButton;
        private System.Windows.Forms.Button cancelButton;
        private GroupBox actionGroupBox;

        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        private void InitializeComponent()
        {
            this.programListLabel = new System.Windows.Forms.Label();
            this.actionGroupBox = new System.Windows.Forms.GroupBox();
            this.blockRadio = new System.Windows.Forms.RadioButton();
            this.allowRadio = new System.Windows.Forms.RadioButton();
            this.okButton = new System.Windows.Forms.Button();
            this.cancelButton = new System.Windows.Forms.Button();
            this.blockDirectionCombo = new DarkModeForms.FlatComboBox();
            this.allowDirectionCombo = new DarkModeForms.FlatComboBox();
            this.actionGroupBox.SuspendLayout();
            this.SuspendLayout();

            this.programListLabel.Location = new System.Drawing.Point(23, 80);
            this.programListLabel.Name = "programListLabel";
            this.programListLabel.Size = new System.Drawing.Size(454, 50);
            this.programListLabel.TabIndex = 0;
            this.programListLabel.Text = "Program List";

            this.actionGroupBox.Controls.Add(this.blockDirectionCombo);
            this.actionGroupBox.Controls.Add(this.allowDirectionCombo);
            this.actionGroupBox.Controls.Add(this.blockRadio);
            this.actionGroupBox.Controls.Add(this.allowRadio);
            this.actionGroupBox.Location = new System.Drawing.Point(23, 140);
            this.actionGroupBox.Name = "actionGroupBox";
            this.actionGroupBox.Size = new System.Drawing.Size(454, 150);
            this.actionGroupBox.TabIndex = 1;
            this.actionGroupBox.TabStop = false;
            this.actionGroupBox.Text = "Action";

            this.blockRadio.AutoSize = true;
            this.blockRadio.Location = new System.Drawing.Point(20, 90);
            this.blockRadio.Name = "blockRadio";
            this.blockRadio.Size = new System.Drawing.Size(54, 19);
            this.blockRadio.TabIndex = 1;
            this.blockRadio.TabStop = true;
            this.blockRadio.Text = "Block";
            this.blockRadio.UseVisualStyleBackColor = true;

            this.allowRadio.AutoSize = true;
            this.allowRadio.Checked = true;
            this.allowRadio.Location = new System.Drawing.Point(20, 30);
            this.allowRadio.Name = "allowRadio";
            this.allowRadio.Size = new System.Drawing.Size(55, 19);
            this.allowRadio.TabIndex = 0;
            this.allowRadio.TabStop = true;
            this.allowRadio.Text = "Allow";
            this.allowRadio.UseVisualStyleBackColor = true;

            this.okButton.Location = new System.Drawing.Point(260, 310);
            this.okButton.Name = "okButton";
            this.okButton.Size = new System.Drawing.Size(100, 36);
            this.okButton.TabIndex = 2;
            this.okButton.Text = "OK";
            this.okButton.UseVisualStyleBackColor = true;
            this.okButton.Click += new System.EventHandler(this.okButton_Click);

            this.cancelButton.Location = new System.Drawing.Point(377, 310);
            this.cancelButton.Name = "cancelButton";
            this.cancelButton.Size = new System.Drawing.Size(100, 36);
            this.cancelButton.TabIndex = 3;
            this.cancelButton.Text = "Cancel";
            this.cancelButton.UseVisualStyleBackColor = true;
            this.cancelButton.Click += new System.EventHandler(this.cancelButton_Click);

            this.blockDirectionCombo.BorderColor = System.Drawing.Color.Gray;
            this.blockDirectionCombo.ButtonColor = System.Drawing.Color.LightGray;
            this.blockDirectionCombo.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;
            this.blockDirectionCombo.FormattingEnabled = true;
            this.blockDirectionCombo.Items.AddRange(new object[] {
            "Outbound",
            "Inbound",
            "All"});
            this.blockDirectionCombo.Location = new System.Drawing.Point(150, 90);
            this.blockDirectionCombo.Name = "blockDirectionCombo";
            this.blockDirectionCombo.Size = new System.Drawing.Size(280, 23);
            this.blockDirectionCombo.TabIndex = 3;

            this.allowDirectionCombo.BorderColor = System.Drawing.Color.Gray;
            this.allowDirectionCombo.ButtonColor = System.Drawing.Color.LightGray;
            this.allowDirectionCombo.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;
            this.allowDirectionCombo.FormattingEnabled = true;
            this.allowDirectionCombo.Items.AddRange(new object[] {
            "Outbound",
            "Inbound",
            "All"});
            this.allowDirectionCombo.Location = new System.Drawing.Point(150, 30);
            this.allowDirectionCombo.Name = "allowDirectionCombo";
            this.allowDirectionCombo.Size = new System.Drawing.Size(280, 23);
            this.allowDirectionCombo.TabIndex = 2;

            this.AutoScaleDimensions = new System.Drawing.SizeF(7F, 15F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.ClientSize = new System.Drawing.Size(500, 370);
            this.Controls.Add(this.cancelButton);
            this.Controls.Add(this.okButton);
            this.Controls.Add(this.actionGroupBox);
            this.Controls.Add(this.programListLabel);
            this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedDialog;
            this.MaximizeBox = false;
            this.MinimizeBox = false;
            this.Name = "CreateProgramRuleForm";
            this.StartPosition = System.Windows.Forms.FormStartPosition.CenterParent;
            this.Text = "Create Program Rule";
            this.actionGroupBox.ResumeLayout(false);
            this.actionGroupBox.PerformLayout();
            this.ResumeLayout(false);
        }
        #endregion
    }
}

--------------------------------------------------
// Full Path: C:/Users/anon/PROGRAMMING/C#/SimpleFirewall/VS Minimal Firewall/MinimalFirewall-NET8/Backups/v2.5.5 - ws/2.5.5.6 - security vulnerability fix 3/DarkModeCS.cs
--------------------------------------------------------------------------------
// File: DarkModeCS.cs
using Microsoft.Win32;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.Drawing;
using System.Drawing.Drawing2D;
using System.Drawing.Imaging;
using System.Linq;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Windows.Forms;

namespace DarkModeForms
{
    public class DarkModeCS : IDisposable
    {
        private class NotificationInfo
        {
            public int Count
            { get; set; }
        }
        private static readonly ConditionalWeakTable<Control, NotificationInfo> _notificationInfo = new();
        public void SetNotificationCount(Control control, int count)
        {
            if (count > 0)
            {
                if (_notificationInfo.TryGetValue(control, out var info))
                {
                    info.Count = count;
                }
                else
                {
                    _notificationInfo.Add(control, new NotificationInfo { Count = count });
                }
            }
            else
            {
                if (_notificationInfo.TryGetValue(control, out _))
                {
                    _notificationInfo.Remove(control);
                }
            }

            if (control is TabPage tabPage && tabPage.Parent is TabControl parentTab)
            {
                parentTab.Invalidate();
            }
        }

        private void DrawNotificationBubble(Graphics g, Rectangle tabRect, string text, TabAlignment alignment)
        {
            using (Font notifFont = new Font("Segoe UI", 7F, FontStyle.Bold))
            {
                SizeF textSize = g.MeasureString(text, notifFont);
                int diameter = (int)Math.Max(textSize.Width, textSize.Height) + 4;
                int x, y;
                switch (alignment)
                {
                    case TabAlignment.Left:
                    case TabAlignment.Right:
                        x = tabRect.Left + 5;
                        y = tabRect.Bottom - diameter - 5;
                        break;
                    default:
                        x = tabRect.Right - diameter - 3;
                        y = tabRect.Top + 3;
                        break;
                }


                Rectangle bubbleRect = new Rectangle(x, y, diameter, diameter);
                g.SmoothingMode = SmoothingMode.AntiAlias;

                using (var path = new GraphicsPath())
                {
                    path.AddEllipse(bubbleRect);
                    PointF point1 = PointF.Empty, point2 = PointF.Empty, point3 = PointF.Empty;
                    switch (alignment)
                    {
                        case TabAlignment.Left:
                            point1 = new PointF(bubbleRect.Right - 2, bubbleRect.Top + diameter * 0.2f);
                            point2 = new PointF(bubbleRect.Right - 2, bubbleRect.Top + diameter * 0.4f);
                            point3 = new PointF(bubbleRect.Right + 6, bubbleRect.Top - 4);
                            break;
                        case TabAlignment.Right:
                            point1 = new PointF(bubbleRect.Left + 2, bubbleRect.Top + diameter * 0.2f);
                            point2 = new PointF(bubbleRect.Left + 2, bubbleRect.Top + diameter * 0.4f);
                            point3 = new PointF(bubbleRect.Left - 6, bubbleRect.Top - 4);
                            break;
                        default:
                            point1 = new PointF(bubbleRect.Left + diameter * 0.2f, bubbleRect.Bottom - 2);
                            point2 = new PointF(bubbleRect.Left + diameter * 0.4f, bubbleRect.Bottom - 2);
                            point3 = new PointF(bubbleRect.Left - 4, bubbleRect.Bottom + 6);
                            break;
                    }

                    path.AddPolygon(new[] { point1, point2, point3 });
                    using (SolidBrush redBrush = new SolidBrush(Color.Red))
                    {
                        g.FillPath(redBrush, path);
                    }
                }

                using (SolidBrush whiteBrush = new SolidBrush(Color.White))
                {
                    using (StringFormat sf = new StringFormat
                    {

                        Alignment = StringAlignment.Center,
                        LineAlignment = StringAlignment.Center
                    })
                    {
                        g.DrawString(text, notifFont, whiteBrush, bubbleRect, sf);
                    }
                }
            }
        }


        public struct DWMCOLORIZATIONcolors
        {
            public uint ColorizationColor,
              ColorizationAfterglow,
              ColorizationColorBalance,
              ColorizationAfterglowBalance,
              ColorizationBlurBalance,
              ColorizationGlassReflectionIntensity,
              ColorizationOpaqueBlend;
        }

        [Flags]
        public enum DWMWINDOWATTRIBUTE : uint
        {
            DWMWA_USE_IMMERSIVE_DARK_MODE = 20,
        }

        [DllImport("user32.dll")]
        private static extern int SendMessage(IntPtr hWnd, int wMsg, bool wParam, int lParam);
        private const int WM_SETREDRAW = 0x000B;

        [DllImport("DwmApi")]
        public static extern int DwmSetWindowAttribute(IntPtr hwnd, int attr, int[] attrValue, int attrSize);
        [DllImport("uxtheme.dll", CharSet = CharSet.Unicode)]
        private static extern int SetWindowTheme(IntPtr hWnd, string pszSubAppName, string? pszSubIdList);
        [DllImport("dwmapi.dll", EntryPoint = "#127")]
        public static extern void DwmGetColorizationParameters(ref DWMCOLORIZATIONcolors colors);
        [DllImport("Gdi32.dll", EntryPoint = "CreateRoundRectRgn")]
        private static extern IntPtr CreateRoundRectRgn
        (
          int nLeftRect,
          int nTopRect,
          int nRightRect,
          int nBottomRect,
          int nWidthEllipse,
          int nHeightEllipse
        );
        [DllImport("user32.dll", ExactSpelling = true, CharSet = CharSet.Auto)]
        private static extern IntPtr GetWindow(IntPtr hWnd, uint uCmd);
        private const uint GW_CHILD = 5;

        private static readonly ControlStatusStorage controlStatusStorage = new();
        private ControlEventHandler? ownerFormControlAdded;
        private ControlEventHandler? controlControlAdded;
        private bool _IsDarkMode;

        public enum DisplayMode
        {
            SystemDefault,
            ClearMode,
            DarkMode
        }

        public DisplayMode ColorMode
        { get; set; } = DisplayMode.SystemDefault;
        public bool IsDarkMode => _IsDarkMode;
        public bool ColorizeIcons { get; set; } = true;
        public bool RoundedPanels { get; set; } = false;
        public Form OwnerForm
        { get; set; }
        public ComponentCollection? Components
        { get; set; }
        public OSThemeColors OScolors
        { get; set; }

        public DarkModeCS(Form _Form, bool _ColorizeIcons = true, bool _RoundedPanels = false)
        {
            OwnerForm = _Form;
            typeof(Control).GetProperty("DoubleBuffered", BindingFlags.NonPublic | BindingFlags.Instance)
                ?.SetValue(OwnerForm, true, null);
            Components = null;
            ColorizeIcons = _ColorizeIcons;
            RoundedPanels = _RoundedPanels;
            OScolors = GetSystemColors(isDarkMode() ? 0 : 1);
            OwnerForm.HandleCreated += (sender, e) => ApplyTitleBarTheme();
        }

        private static void SuspendDrawing(Control parent)
        {
            SendMessage(parent.Handle, WM_SETREDRAW, false, 0);
        }

        private static void ResumeDrawing(Control parent)
        {
            SendMessage(parent.Handle, WM_SETREDRAW, true, 0);
            parent.Refresh();
        }

        private void ApplyTitleBarTheme()
        {
            if (OwnerForm.Handle != IntPtr.Zero)
            {
                bool useDark = (ColorMode == DisplayMode.DarkMode) ||
                    (ColorMode == DisplayMode.SystemDefault && isDarkMode());
                int[] DarkModeOn = useDark ? [0x01] : [0x00];
                DwmSetWindowAttribute(OwnerForm.Handle, (int)DWMWINDOWATTRIBUTE.DWMWA_USE_IMMERSIVE_DARK_MODE, DarkModeOn, 4);
            }
        }

        public bool isDarkMode()
        {
            return GetWindowsColorMode() <= 0;
        }

        public void ApplyTheme(bool pIsDarkMode = true)
        {
            try
            {
                _IsDarkMode = pIsDarkMode;
                OScolors = GetSystemColors(pIsDarkMode ? 0 : 1);

                SuspendDrawing(OwnerForm);
                OwnerForm.SuspendLayout();

                ApplyTitleBarTheme();
                OwnerForm.BackColor = OScolors.Background;
                OwnerForm.ForeColor = OScolors.TextInactive;
                if (OwnerForm.Controls != null)
                {
                    foreach (Control _control in OwnerForm.Controls)
                    {
                        ThemeControl(_control);
                    }

                    ownerFormControlAdded = (sender, e) =>
                    {
                        if (e.Control != null)
                        {
                            ThemeControl(e.Control!);
                        }
                    };
                    OwnerForm.ControlAdded -= ownerFormControlAdded;
                    OwnerForm.ControlAdded += ownerFormControlAdded;
                }

                if (Components != null)
                {
                    foreach (var item in Components.OfType<ContextMenuStrip>())
                        ThemeControl(item);
                }
                OwnerForm.ResumeLayout(true);
                ResumeDrawing(OwnerForm);
            }
            catch (Exception ex)
            {
                MessageBox.Show(ex.ToString());
            }
        }

        public void ApplyTheme(DisplayMode pColorMode)
        {
            if (ColorMode == pColorMode) return;
            ColorMode = pColorMode;
            _IsDarkMode = isDarkMode();
            if (ColorMode != DisplayMode.SystemDefault)
            {
                _IsDarkMode = ColorMode == DisplayMode.DarkMode;
            }

            ApplyTheme(_IsDarkMode);
        }

        private void ListView_DrawColumnHeader(object? sender, DrawListViewColumnHeaderEventArgs e)
        {
            if (sender is not ListView listView) return;
            if (IsDarkMode)
            {
                using (var backBrush = new SolidBrush(OScolors.Surface))
                {
                    e.Graphics.FillRectangle(backBrush, e.Bounds);
                }
                TextRenderer.DrawText(e.Graphics, e.Header!.Text, e.Font, e.Bounds, OScolors.TextActive, TextFormatFlags.VerticalCenter | TextFormatFlags.Left);
            }
            else
            {
                e.DrawDefault = true;
            }
        }

        public void ThemeControl(Control control)
        {
            var info = controlStatusStorage.GetControlStatusInfo(control);
            if (info != null)
            {
                if (info.IsExcluded) return;
                if (info.LastThemeAppliedIsDark == IsDarkMode) return;
                info.LastThemeAppliedIsDark = IsDarkMode;
            }
            else
            {
                controlStatusStorage.RegisterProcessedControl(control, IsDarkMode);
            }
            control.SuspendLayout();
            BorderStyle BStyle = (IsDarkMode ? BorderStyle.FixedSingle : BorderStyle.Fixed3D);
            controlControlAdded = (sender, e) =>
            {
                if (e.Control != null)
                {
                    ThemeControl(e.Control);
                }
            };
            control.ControlAdded -= controlControlAdded;
            control.ControlAdded += controlControlAdded;
            string Mode = IsDarkMode ? "DarkMode_Explorer" : "ClearMode_Explorer";
            SetWindowTheme(control.Handle, Mode, null);

            control.GetType().GetProperty("BackColor")?.SetValue(control, OScolors.Control);
            control.GetType().GetProperty("ForeColor")?.SetValue(control, OScolors.TextActive);
            if (control is Label lbl && control.Parent != null)
            {
                control.BackColor = control.Parent.BackColor;
                control.GetType().GetProperty("BorderStyle")?.SetValue(control, BorderStyle.None);
                lbl.Paint -= Label_Paint;
                lbl.Paint += Label_Paint;
            }
            else if (control is LinkLabel linkLabel && linkLabel.Parent != null)
            {
                linkLabel.BackColor = linkLabel.Parent.BackColor;
                linkLabel.LinkColor = OScolors.AccentLight;
                linkLabel.VisitedLinkColor = OScolors.Primary;
            }
            else if (control is TextBox)
            {
                control.GetType().GetProperty("BorderStyle")?.SetValue(control, BStyle);
            }
            else if (control is NumericUpDown)
            {
                Mode = IsDarkMode ?
                    "DarkMode_ItemsView" : "ClearMode_ItemsView";
                SetWindowTheme(control.Handle, Mode, null);
            }
            else if (control is Button button)
            {
                button.FlatStyle = IsDarkMode ?
                    FlatStyle.Flat : FlatStyle.Standard;
                button.FlatAppearance.CheckedBackColor = OScolors.Accent;
                button.BackColor = OScolors.Control;
                button.FlatAppearance.BorderColor = (button.FindForm()?.AcceptButton == button) ? OScolors.Accent : OScolors.Control;
                button.FlatAppearance.MouseOverBackColor = OScolors.ControlLight;
            }
            else if (control is ComboBox comboBox)
            {
                if (comboBox.DropDownStyle != ComboBoxStyle.DropDownList)
                {
                    comboBox.SelectionStart = comboBox.Text.Length;
                }
                control.BeginInvoke(new Action(() =>
                {
                    if (control is ComboBox invokedComboBox && !invokedComboBox.DropDownStyle.Equals(ComboBoxStyle.DropDownList))
                        invokedComboBox.SelectionLength = 0;

                }));

                if (!control.Enabled && IsDarkMode)
                {
                    comboBox.DropDownStyle = ComboBoxStyle.DropDownList;
                }

                Mode = IsDarkMode ?
                    "DarkMode_CFD" : "ClearMode_CFD";
                SetWindowTheme(control.Handle, Mode, null);
            }
            else if (control is TabPage tabPage)
            {
                tabPage.BackColor = OScolors.Surface;
            }
            else if (control is Panel panel && panel.Parent != null)
            {
                panel.BackColor = panel.Parent.BackColor;
                panel.BorderStyle = BorderStyle.None;
                if (panel.Parent is not TabControl && panel.Parent is not TableLayoutPanel)
                {
                    if (RoundedPanels)
                    {
                        SetRoundBorders(panel, 6, OScolors.SurfaceDark, 1);
                    }
                }
            }
            else if (control is GroupBox groupBox && groupBox.Parent != null)
            {
                groupBox.BackColor = groupBox.Parent.BackColor;
                groupBox.ForeColor = OScolors.TextActive;
                groupBox.Paint -= GroupBox_Paint;
                groupBox.Paint += GroupBox_Paint;
            }
            else if (control is TableLayoutPanel tablePanel && tablePanel.Parent != null)
            {
                tablePanel.BackColor = tablePanel.Parent.BackColor;
                tablePanel.ForeColor = OScolors.TextInactive;
            }
            else if (control is TabControl tab && tab.Parent != null)
            {
                tab.Appearance = TabAppearance.Normal;
                tab.DrawMode = TabDrawMode.OwnerDrawFixed;
                tab.DrawItem -= Tab_DrawItem;
                tab.DrawItem += Tab_DrawItem;
            }
            else if (control is PictureBox pictureBox && pictureBox.Parent != null)
            {
                pictureBox.BackColor = pictureBox.Parent.BackColor;
                if (OScolors != null)
                {
                    pictureBox.ForeColor = OScolors.TextActive;
                }
                pictureBox.BorderStyle = BorderStyle.None;
            }
            else if (control is CheckBox checkBox && checkBox.Parent != null)
            {
                checkBox.BackColor = checkBox.Parent.BackColor;
                checkBox.ForeColor = control.Enabled ? OScolors.TextActive : OScolors.TextInactive;
                checkBox.Paint -= CheckBox_Paint;
                checkBox.Paint += CheckBox_Paint;
            }
            else if (control is RadioButton radioButton && radioButton.Parent != null)
            {
                radioButton.BackColor = radioButton.Parent.BackColor;
                radioButton.ForeColor = control.Enabled ? OScolors.TextActive : OScolors.TextInactive;
                radioButton.Paint -= RadioButton_Paint;
                radioButton.Paint += RadioButton_Paint;
            }
            else if (control is MenuStrip menuStrip)
            {
                menuStrip.RenderMode = ToolStripRenderMode.Professional;
                menuStrip.Renderer = new MyRenderer(new CustomColorTable(OScolors), ColorizeIcons)
                {
                    MyColors = OScolors
                };
            }
            else if (control is ToolStrip toolStrip)
            {
                toolStrip.RenderMode = ToolStripRenderMode.Professional;
                toolStrip.Renderer = new MyRenderer(new CustomColorTable(OScolors), ColorizeIcons) { MyColors = OScolors };
            }
            else if (control is ToolStripPanel toolStripPanel && toolStripPanel.Parent != null)
            {
                toolStripPanel.BackColor = toolStripPanel.Parent.BackColor;
            }
            else if (control is ToolStripDropDown dropDown)
            {
                dropDown.Opening -= Tsdd_Opening;
                dropDown.Opening += Tsdd_Opening;
            }
            else if (control is ContextMenuStrip contextMenu)
            {
                contextMenu.RenderMode = ToolStripRenderMode.Professional;
                contextMenu.Renderer = new MyRenderer(new CustomColorTable(OScolors), ColorizeIcons) { MyColors = OScolors };
                contextMenu.Opening -= Tsdd_Opening;
                contextMenu.Opening += Tsdd_Opening;
            }
            else if (control is MdiClient mdiClient)
            {
                mdiClient.BackColor = OScolors.Surface;
            }
            else if (control is PropertyGrid pGrid)
            {
                pGrid.BackColor = OScolors.Control;
                pGrid.ViewBackColor = OScolors.Control;
                pGrid.LineColor = OScolors.Surface;
                pGrid.ViewForeColor = OScolors.TextActive;
                pGrid.ViewBorderColor = OScolors.ControlDark;
                pGrid.CategoryForeColor = OScolors.TextActive;
                pGrid.CategorySplitterColor = OScolors.ControlLight;
            }
            else if (control is ListView lView)
            {
                lView.OwnerDraw = true;

                lView.DrawColumnHeader -= ListView_DrawColumnHeader;
                lView.DrawColumnHeader += ListView_DrawColumnHeader;

                if (!lView.OwnerDraw)
                {
                    Mode = IsDarkMode ?
                        "DarkMode_Explorer" : "ClearMode_Explorer";
                    SetWindowTheme(control.Handle, Mode, null);
                }
            }
            else if (control is TreeView)
            {
                control.GetType().GetProperty("BorderStyle")?.SetValue(control, BorderStyle.None);
            }
            else if (control is DataGridView grid)
            {
                grid.EnableHeadersVisualStyles = false;
                grid.BorderStyle = BorderStyle.FixedSingle;
                grid.BackgroundColor = OScolors.Control;
                grid.GridColor = OScolors.Control;

                grid.Paint -= DataGridView_Paint;
                grid.Paint += DataGridView_Paint;

                grid.DefaultCellStyle.BackColor = OScolors.Surface;
                grid.DefaultCellStyle.ForeColor = OScolors.TextActive;
                grid.ColumnHeadersDefaultCellStyle.BackColor = OScolors.Surface;
                grid.ColumnHeadersDefaultCellStyle.ForeColor = OScolors.TextActive;
                grid.ColumnHeadersDefaultCellStyle.SelectionBackColor = OScolors.Surface;
                grid.ColumnHeadersBorderStyle = DataGridViewHeaderBorderStyle.Single;
                grid.RowHeadersDefaultCellStyle.BackColor = OScolors.Surface;
                grid.RowHeadersDefaultCellStyle.ForeColor = OScolors.TextActive;
                grid.RowHeadersDefaultCellStyle.SelectionBackColor = OScolors.Surface;
                grid.RowHeadersBorderStyle = DataGridViewHeaderBorderStyle.Single;
            }
            else if (control is RichTextBox richText && richText.Parent != null)
            {
                richText.BackColor = richText.Parent.BackColor;
                richText.BorderStyle = BorderStyle.None;
            }
            else if (control is FlowLayoutPanel flowLayout && flowLayout.Parent != null)
            {
                flowLayout.BackColor = flowLayout.Parent.BackColor;
            }

            if (control.ContextMenuStrip != null)
                ThemeControl(control.ContextMenuStrip);
            foreach (Control childControl in control.Controls)
            {
                ThemeControl(childControl);
            }
            control.ResumeLayout(false);
        }

        private void Label_Paint(object? sender, PaintEventArgs e)
        {
            if (sender is not Label lbl || !(!lbl.Enabled && IsDarkMode && lbl.Parent != null)) return;
            e.Graphics.Clear(lbl.Parent.BackColor);
            e.Graphics.SmoothingMode = SmoothingMode.HighQuality;
            using Brush B = new SolidBrush(lbl.ForeColor);
            MethodInfo? mi = lbl.GetType().GetMethod("CreateStringFormat", BindingFlags.NonPublic | BindingFlags.Instance);
            if (mi?.Invoke(lbl, []) is StringFormat sf)
            {
                e.Graphics.DrawString(lbl.Text ?? "", lbl.Font, B, new PointF(1, 0), sf);
            }
        }

        private void GroupBox_Paint(object? sender, PaintEventArgs e)
        {
            if (sender is not GroupBox gBox || !(!gBox.Enabled && IsDarkMode)) return;
            using Brush B = new SolidBrush(gBox.ForeColor);
            e.Graphics.DrawString(gBox.Text, gBox.Font, B, new PointF(6, 0));
        }

        private void Tab_DrawItem(object? sender, DrawItemEventArgs e)
        {
            if (sender is not TabControl tab || tab.Parent == null) return;
            using (SolidBrush headerBrush = new SolidBrush(tab.Parent.BackColor))
            {
                e.Graphics.FillRectangle(headerBrush, new Rectangle(0, 0, tab.Width, tab.Height));
            }
            for (int i = 0; i < tab.TabPages.Count; i++)
            {
                TabPage tabPage = tab.TabPages[i];
                if (tabPage.Tag == null)
                {
                    tabPage.BackColor = OScolors.Surface;
                    tabPage.BorderStyle = BorderStyle.FixedSingle;
                    foreach (Control child in tabPage.Controls)
                    {
                        ThemeControl(child);
                    }
                    tabPage.ControlAdded += (_s, _e) => { if (_e.Control != null) ThemeControl(_e.Control); };
                    tabPage.Tag = "themed";
                }
                Rectangle tabRect = tab.GetTabRect(i);
                bool isSelected = tab.SelectedIndex == i;
                if (isSelected)
                {
                    using (SolidBrush tabBackColor = new SolidBrush(OScolors.Surface))
                    {
                        e.Graphics.FillRectangle(tabBackColor, tabRect);
                    }
                }
                Image?
                icon = null;
                if (tab.ImageList != null && tabPage.ImageIndex >= 0 && tabPage.ImageIndex < tab.ImageList.Images.Count)
                {
                    icon = tab.ImageList.Images[tabPage.ImageIndex];
                }
                Rectangle textBounds;
                TextFormatFlags textFlags = TextFormatFlags.HorizontalCenter | TextFormatFlags.VerticalCenter | TextFormatFlags.WordBreak;
                Color textColor = isSelected ? OScolors.TextActive : OScolors.TextInactive;

                e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;
                e.Graphics.InterpolationMode = InterpolationMode.HighQualityBicubic;

                if (tab.Alignment == TabAlignment.Left || tab.Alignment == TabAlignment.Right)
                {
                    if (icon != null)
                    {
                        int iconHeight = tab.ImageList.ImageSize.Height;
                        int iconWidth = tab.ImageList.ImageSize.Width;
                        int iconX = tabRect.X + (tabRect.Width - iconWidth) / 2;
                        int iconY = tabRect.Y + 15;
                        Image imageToDraw = icon;
                        bool shouldDispose = false;
                        if (IsDarkMode && tabPage.ImageKey != "locked.png")
                        {
                            imageToDraw = RecolorImage(icon, Color.White);
                            shouldDispose = true;
                        }
                        e.Graphics.DrawImage(imageToDraw, new Rectangle(iconX, iconY, iconWidth, iconHeight));
                        if (shouldDispose)
                        {
                            imageToDraw.Dispose();
                        }
                        textBounds = new Rectangle(tabRect.X, iconY + iconHeight, tabRect.Width, tabRect.Height - iconHeight - 20);
                        textFlags = TextFormatFlags.HorizontalCenter | TextFormatFlags.Top | TextFormatFlags.WordBreak;
                    }
                    else
                    {
                        textBounds = tabRect;
                    }
                }
                else
                {
                    textBounds = tabRect;
                }
                TextRenderer.DrawText(e.Graphics, tabPage.Text, tabPage.Font, textBounds, textColor, textFlags);
                if (_notificationInfo.TryGetValue(tabPage, out var info) && info.Count > 0)
                {
                    DrawNotificationBubble(e.Graphics, tabRect, info.Count.ToString(), tab.Alignment);
                }
            }
        }

        private void CheckBox_Paint(object? sender, PaintEventArgs e)
        {
            if (sender is not CheckBox chkBox || !(!chkBox.Enabled && IsDarkMode)) return;
            using Brush B = new SolidBrush(chkBox.ForeColor);
            e.Graphics.DrawString(chkBox.Text, chkBox.Font, B, new PointF(16, 0));
        }

        private void RadioButton_Paint(object? sender, PaintEventArgs e)
        {
            if (sender is not RadioButton rdoBtn || !(!rdoBtn.Enabled && IsDarkMode)) return;
            using Brush B = new SolidBrush(rdoBtn.ForeColor);
            e.Graphics.DrawString(rdoBtn.Text, rdoBtn.Font, B, new PointF(16, 0));
        }

        private void DataGridView_Paint(object? sender, PaintEventArgs e)
        {
            if (sender is not DataGridView dgv) return;
            PropertyInfo? hsp = typeof(DataGridView).GetProperty("HorizontalScrollBar", BindingFlags.Instance | BindingFlags.NonPublic);
            PropertyInfo? vsp = typeof(DataGridView).GetProperty("VerticalScrollBar", BindingFlags.Instance | BindingFlags.NonPublic);
            if (hsp?.GetValue(dgv) is HScrollBar hs && hs.Visible && vsp?.GetValue(dgv) is VScrollBar vs && vs.Visible)
            {
                using Brush brush = new SolidBrush(OScolors.SurfaceDark);
                var w = vs.Size.Width;
                var h = hs.Size.Height;
                e.Graphics.FillRectangle(brush, dgv.ClientRectangle.X + dgv.ClientRectangle.Width - w - 1, dgv.ClientRectangle.Y + dgv.ClientRectangle.Height - h - 1, w, h);
            }
        }

        public static void ExcludeFromProcessing(Control control)
        {
            controlStatusStorage.ExcludeFromProcessing(control);
        }

        public static int GetWindowsColorMode(bool GetSystemColorModeInstead = false)
        {
            try
            {
                return (int?)Registry.GetValue(
                   @"HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Themes\Personalize",
                   GetSystemColorModeInstead ? "SystemUsesLightTheme" : "AppsUseLightTheme",
                   -1) ??
                    1;
            }
            catch
            {
                return 1;
            }
        }

        public static Color GetWindowsAccentColor()
        {
            try
            {
                DWMCOLORIZATIONcolors colors = new DWMCOLORIZATIONcolors();
                DwmGetColorizationParameters(ref colors);

                if (IsWindows10orGreater())
                {
                    var color = colors.ColorizationColor;
                    var colorValue = long.Parse(color.ToString(), System.Globalization.NumberStyles.HexNumber);
                    var transparency = (colorValue >> 24) & 0xFF;
                    var red = (colorValue >> 16) & 0xFF;
                    var green = (colorValue >> 8) & 0xFF;
                    var blue = (colorValue >> 0) & 0xFF;
                    return Color.FromArgb((int)transparency, (int)red, (int)green, (int)blue);
                }
                return Color.CadetBlue;
            }
            catch (Exception)
            {
                return Color.CadetBlue;
            }
        }

        public static Color GetWindowsAccentOpaqueColor()
        {
            DWMCOLORIZATIONcolors colors = new DWMCOLORIZATIONcolors();
            DwmGetColorizationParameters(ref colors);
            if (IsWindows10orGreater())
            {
                var color = colors.ColorizationColor;
                var colorValue = long.Parse(color.ToString(), System.Globalization.NumberStyles.HexNumber);
                var red = (colorValue >> 16) & 0xFF;
                var green = (colorValue >> 8) & 0xFF;
                var blue = (colorValue >> 0) & 0xFF;
                return Color.FromArgb(255, (int)red, (int)green, (int)blue);
            }
            return Color.CadetBlue;
        }

        public static OSThemeColors GetSystemColors(int ColorMode = 0)
        {
            OSThemeColors _ret = new();
            if (ColorMode <= 0)
            {
                _ret.Background = Color.FromArgb(32, 32, 32);
                _ret.BackgroundDark = Color.FromArgb(18, 18, 18);
                _ret.BackgroundLight = ControlPaint.Light(_ret.Background);
                _ret.Surface = Color.FromArgb(43, 43, 43);
                _ret.SurfaceLight = Color.FromArgb(50, 50, 50);
                _ret.SurfaceDark = Color.FromArgb(29, 29, 29);
                _ret.TextActive = Color.White;
                _ret.TextInactive = Color.FromArgb(176, 176, 176);
                _ret.TextInAccent = GetReadableColor(_ret.Accent);
                _ret.Control = Color.FromArgb(55, 55, 55);
                _ret.ControlDark = ControlPaint.Dark(_ret.Control);
                _ret.ControlLight = Color.FromArgb(67, 67, 67);
                _ret.Primary = Color.FromArgb(3, 218, 198);
                _ret.Secondary = Color.MediumSlateBlue;
            }

            return _ret;
        }

        public static void SetRoundBorders(Control _Control, int Radius = 10, Color? borderColor = null, int borderSize = 2, bool underlinedStyle = false)
        {
            borderColor ??= Color.MediumSlateBlue;
            if (_Control?.Parent != null)
            {
                _Control.GetType().GetProperty("BorderStyle")?.SetValue(_Control, BorderStyle.None);
                _Control.Region = Region.FromHrgn(CreateRoundRectRgn(0, 0, _Control.Width, _Control.Height, Radius, Radius));
                _Control.Paint += (sender, e) =>
                {
                    Graphics graph = e.Graphics;
                    if (Radius > 1 && _Control.Parent != null)
                    {
                        var rectBorderSmooth = _Control.ClientRectangle;
                        var rectBorder = Rectangle.Inflate(rectBorderSmooth, -borderSize, -borderSize);
                        int smoothSize = borderSize > 0 ? borderSize : 1;
                        using GraphicsPath pathBorderSmooth = GetFigurePath(rectBorderSmooth, Radius);
                        using GraphicsPath pathBorder = GetFigurePath(rectBorder, Radius - borderSize);
                        using Pen penBorderSmooth = new(_Control.Parent.BackColor, smoothSize);
                        using Pen penBorder = new((Color)borderColor, borderSize);

                        _Control.Region = new Region(pathBorderSmooth);
                        if (Radius > 15)
                        {
                            using GraphicsPath pathTxt = GetFigurePath(_Control.ClientRectangle, borderSize * 2);
                            _Control.Region = new Region(pathTxt);
                        }
                        graph.SmoothingMode = SmoothingMode.AntiAlias;
                        penBorder.Alignment = PenAlignment.Center;

                        if (underlinedStyle)
                        {
                            graph.DrawPath(penBorderSmooth, pathBorderSmooth);
                            graph.SmoothingMode = SmoothingMode.None;
                            graph.DrawLine(penBorder, 0, _Control.Height - 1, _Control.Width, _Control.Height - 1);
                        }
                        else
                        {
                            graph.DrawPath(penBorderSmooth, pathBorderSmooth);
                            graph.DrawPath(penBorder, pathBorder);
                        }
                    }
                };
            }
        }

        public static Image RecolorImage(Image sourceImage, Color newColor)
        {
            var newBitmap = new Bitmap(sourceImage.Width, sourceImage.Height, PixelFormat.Format32bppArgb);
            using (var g = Graphics.FromImage(newBitmap))
            {
                g.SmoothingMode = SmoothingMode.AntiAlias;
                g.InterpolationMode = InterpolationMode.HighQualityBicubic;
                g.CompositingQuality = CompositingQuality.HighQuality;
                float r = newColor.R / 255f;
                float g_ = newColor.G / 255f;
                float b = newColor.B / 255f;
                var colorMatrix = new ColorMatrix(
                new float[][]
                {
                    new float[] {0, 0, 0, 0, 0},
                    new float[] {0, 0, 0, 0, 0},
                    new float[] {0, 0, 0, 0, 0},
                    new float[] {0, 0, 0, 1, 0},
                    new float[] {r, g_, b, 0, 1}
                });
                using (var attributes = new ImageAttributes())
                {
                    attributes.SetColorMatrix(colorMatrix, ColorMatrixFlag.Default, ColorAdjustType.Bitmap);
                    g.DrawImage(sourceImage, new Rectangle(0, 0, sourceImage.Width, sourceImage.Height),
                        0, 0, sourceImage.Width, sourceImage.Height, GraphicsUnit.Pixel, attributes);
                }
            }
            return newBitmap;
        }

        private void Tsdd_Opening(object? sender, CancelEventArgs e)
        {
            if (sender is ToolStripDropDown tsdd)
            {
                foreach (ToolStripMenuItem toolStripMenuItem in tsdd.Items.OfType<ToolStripMenuItem>())
                {

                    toolStripMenuItem.DropDownOpening -= Tsmi_DropDownOpening;
                    toolStripMenuItem.DropDownOpening += Tsmi_DropDownOpening;
                }
            }
        }

        private void Tsmi_DropDownOpening(object? sender, EventArgs e)
        {
            if (sender is ToolStripMenuItem tsmi)
            {
                if (tsmi.DropDown != null && tsmi.DropDown.Items.Count > 0)

                {
                    ThemeControl(tsmi.DropDown);
                }
                tsmi.DropDownOpening -= Tsmi_DropDownOpening;
            }
        }

        private static bool IsWindows10orGreater()
        {
            return WindowsVersion() >= 10;
        }

        private static int WindowsVersion()
        {
            try
            {
                using var reg = Registry.LocalMachine.OpenSubKey(@"SOFTWARE\Microsoft\Windows NT\CurrentVersion");
                string? productName = reg?.GetValue("ProductName")?.ToString();
                if (!string.IsNullOrEmpty(productName))
                {
                    var parts = productName.Split(' ');
                    if (parts.Length > 1 && int.TryParse(parts[1], out int result))
                    {
                        return result;
                    }
                }
            }
            catch { }

            return Environment.OSVersion.Version.Major;
        }

        private static Color GetReadableColor(Color backgroundColor)
        {
            double normalizedR = backgroundColor.R / 255.0;
            double normalizedG = backgroundColor.G / 255.0;
            double normalizedB = backgroundColor.B / 255.0;
            double luminance = 0.299 * normalizedR + 0.587 * normalizedG + 0.114 * normalizedB;
            return luminance < 0.5 ?
                Color.FromArgb(182, 180, 215) : Color.FromArgb(34, 34, 34);
        }

        private static GraphicsPath GetFigurePath(Rectangle rect, int radius)
        {
            GraphicsPath path = new();
            float curveSize = radius * 2F;

            path.StartFigure();
            path.AddArc(rect.X, rect.Y, curveSize, curveSize, 180, 90);
            path.AddArc(rect.Right - curveSize, rect.Y, curveSize, curveSize, 270, 90);
            path.AddArc(rect.Right - curveSize, rect.Bottom - curveSize, curveSize, curveSize, 0, 90);
            path.AddArc(rect.X, rect.Bottom - curveSize, curveSize, curveSize, 90, 90);
            path.CloseFigure();
            return path;
        }

        private bool disposedValue;
        protected virtual void Dispose(bool disposing)
        {
            if (!disposedValue)
            {
                if (disposing)
                {
                    if (OwnerForm != null && ownerFormControlAdded != null)

                    {
                        OwnerForm.ControlAdded -= ownerFormControlAdded;
                    }
                }
                disposedValue = true;
            }
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }
    }

    public class OSThemeColors
    {
        public Color Background
        { get; set; } = SystemColors.Control;
        public Color BackgroundDark { get; set; } = SystemColors.ControlDark;
        public Color BackgroundLight
        { get; set; } = SystemColors.ControlLight;
        public Color Surface { get; set; } = SystemColors.ControlLightLight;
        public Color SurfaceDark
        { get; set; } = SystemColors.ControlLight;
        public Color SurfaceLight { get; set; } = Color.White;
        public Color TextActive
        { get; set; } = SystemColors.ControlText;
        public Color TextInactive { get; set; } = SystemColors.GrayText;
        public Color TextInAccent
        { get; set; } = SystemColors.HighlightText;
        public Color Control { get; set; } = SystemColors.ButtonFace;
        public Color ControlDark
        { get; set; } = SystemColors.ButtonShadow;
        public Color ControlLight { get; set; } = SystemColors.ButtonHighlight;
        public Color Accent
        { get; set; } = DarkModeCS.GetWindowsAccentColor();
        public Color AccentOpaque { get; set; } = DarkModeCS.GetWindowsAccentOpaqueColor();
        public Color AccentDark => ControlPaint.Dark(Accent);
        public Color AccentLight => ControlPaint.Light(Accent);
        public Color Primary { get; set; } = SystemColors.Highlight;
        public Color PrimaryDark => ControlPaint.Dark(Primary);
        public Color PrimaryLight => ControlPaint.Light(Primary);
        public Color Secondary { get; set; } = SystemColors.HotTrack;
        public Color SecondaryDark => ControlPaint.Dark(Secondary);
        public Color SecondaryLight => ControlPaint.Light(Secondary);
    }

    public class MyRenderer : ToolStripProfessionalRenderer
    {
        public bool ColorizeIcons
        { get; set; } = true;
        public OSThemeColors MyColors
        { get; set; }

        public MyRenderer(ProfessionalColorTable table, bool pColorizeIcons = true) : base(table)
        {
            ColorizeIcons = pColorizeIcons;
            MyColors = new OSThemeColors();
        }

        protected override void OnRenderGrip(ToolStripGripRenderEventArgs e)
        {
            base.OnRenderGrip(e);
        }

        protected override void OnRenderToolStripBorder(ToolStripRenderEventArgs e)
        {
            if (e.ToolStrip is ToolStripDropDown)
            {
                using var p = new Pen(MyColors.ControlDark);
                e.Graphics.DrawRectangle(p, 0, 0, e.AffectedBounds.Width - 1, e.AffectedBounds.Height - 1);
            }
            else
            {
                base.OnRenderToolStripBorder(e);
            }
        }

        protected override void OnRenderToolStripBackground(ToolStripRenderEventArgs e)
        {
            if (e.ToolStrip != null)
            {
                e.ToolStrip!.BackColor = MyColors.Background;
            }
            base.OnRenderToolStripBackground(e);
        }

        protected override void OnRenderButtonBackground(ToolStripItemRenderEventArgs e)
        {
            if (e.Item is not ToolStripButton button) return;
            Graphics g = e.Graphics;
            Rectangle bounds = new(Point.Empty, e.Item.Size);

            Color gradientBegin = MyColors.Background;
            Color gradientEnd = MyColors.Background;
            using Pen BordersPencil = new(MyColors.Background);

            if (button.Pressed || button.Checked)
            {
                gradientBegin = MyColors.Control;
                gradientEnd = MyColors.Control;
            }
            else if (button.Selected)
            {
                gradientBegin = MyColors.Accent;
                gradientEnd = MyColors.Accent;
            }

            using (Brush b = new LinearGradientBrush(bounds, gradientBegin, gradientEnd, LinearGradientMode.Vertical))
            {
                g.FillRectangle(b, bounds);
            }

            g.DrawRectangle(BordersPencil, bounds);
            g.DrawLine(BordersPencil, bounds.X, bounds.Y, bounds.Width - 1, bounds.Y);
            g.DrawLine(BordersPencil, bounds.X, bounds.Y, bounds.X, bounds.Height - 1);
        }

        protected override void OnRenderDropDownButtonBackground(ToolStripItemRenderEventArgs e)
        {
            Rectangle bounds = new(Point.Empty, e.Item.Size);
            Color gradientBegin = MyColors.Background;
            Color gradientEnd = MyColors.Background;

            if (e.Item.Pressed)
            {
                gradientBegin = MyColors.Control;
                gradientEnd = MyColors.Control;
            }
            else if (e.Item.Selected)
            {
                gradientBegin = MyColors.Accent;
                gradientEnd = MyColors.Accent;
            }

            using Brush b = new LinearGradientBrush(bounds, gradientBegin, gradientEnd, LinearGradientMode.Vertical);
            e.Graphics.FillRectangle(b, bounds);
        }

        protected override void OnRenderSplitButtonBackground(ToolStripItemRenderEventArgs e)
        {
            Rectangle bounds = new(Point.Empty, e.Item.Size);
            Color gradientBegin = MyColors.Background;
            Color gradientEnd = MyColors.Background;

            if (e.Item.Pressed)
            {
                gradientBegin = MyColors.Control;
                gradientEnd = MyColors.Control;
            }
            else if (e.Item.Selected)
            {
                gradientBegin = MyColors.Accent;
                gradientEnd = MyColors.Accent;
            }

            using (Brush b = new LinearGradientBrush(bounds, gradientBegin, gradientEnd, LinearGradientMode.Vertical))
            {
                e.Graphics.FillRectangle(b, bounds);
            }

            int Padding = 2;
            Size cSize = new(8, 4);
            using Pen ChevronPen = new(MyColors.TextInactive, 2);
            Point P1 = new(bounds.Width - (cSize.Width + Padding), (bounds.Height / 2) - (cSize.Height / 2));
            Point P2 = new(bounds.Width - Padding, (bounds.Height / 2) - (cSize.Height / 2));
            Point P3 = new(bounds.Width - (cSize.Width / 2 + Padding), (bounds.Height / 2) + (cSize.Height / 2));

            e.Graphics.DrawLine(ChevronPen, P1, P3);
            e.Graphics.DrawLine(ChevronPen, P2, P3);
        }

        protected override void OnRenderItemText(ToolStripItemTextRenderEventArgs e)
        {
            if (e.Item != null)
            {
                e.TextColor = e.Item.Enabled ?
                    MyColors.TextActive : MyColors.TextInactive;
            }
            base.OnRenderItemText(e);
        }

        protected override void OnRenderItemBackground(ToolStripItemRenderEventArgs e)
        {
            base.OnRenderItemBackground(e);
            if (e.Item is ToolStripComboBox)
            {
                Rectangle rect = new(Point.Empty, e.Item.Size);
                using Pen p = new(MyColors.ControlLight, 1);
                e.Graphics.DrawRectangle(p, rect);
            }
        }

        protected override void OnRenderMenuItemBackground(ToolStripItemRenderEventArgs e)
        {
            if (e.Item is not ToolStripMenuItem)
            {
                base.OnRenderMenuItemBackground(e);
                return;
            }

            Rectangle bounds = new(Point.Empty, e.Item.Size);
            Color gradientBegin = MyColors.Background;
            Color gradientEnd = MyColors.Background;
            bool DrawIt = false;
            if (e.Item.Pressed)
            {
                gradientBegin = MyColors.Control;
                gradientEnd = MyColors.Control;
                DrawIt = true;
            }
            else if (e.Item.Selected)
            {
                gradientBegin = MyColors.Accent;
                gradientEnd = MyColors.Accent;
                DrawIt = true;
            }

            if (DrawIt)
            {
                using Brush b = new LinearGradientBrush(bounds, gradientBegin, gradientEnd, LinearGradientMode.Vertical);
                e.Graphics.FillRectangle(b, bounds);
            }
        }

        protected override void OnRenderItemImage(ToolStripItemImageRenderEventArgs e)
        {
            if (e.Image == null || e.Item == null)
            {
                base.OnRenderItemImage(e);
                return;
            }

            if (e.Item.GetType().FullName == "System.Windows.Forms.MdiControlStrip+ControlBoxMenuItem")
            {
                Color _ClearColor = e.Item.Enabled ?
                    MyColors.TextActive : MyColors.SurfaceDark;
                using (Image adjustedImage = DarkModeCS.RecolorImage(e.Image, _ClearColor))
                {
                    e.Graphics.InterpolationMode = InterpolationMode.HighQualityBilinear;
                    e.Graphics.CompositingQuality = CompositingQuality.AssumeLinear;
                    e.Graphics.SmoothingMode = SmoothingMode.HighQuality;
                    e.Graphics.DrawImage(adjustedImage, e.ImageRectangle);
                }
                return;
            }

            if (ColorizeIcons)
            {
                Color _ClearColor = e.Item.Enabled ?
                    MyColors.TextInactive : MyColors.SurfaceDark;
                using (Image adjustedImage = DarkModeCS.RecolorImage(e.Image, _ClearColor))
                {
                    e.Graphics.InterpolationMode = InterpolationMode.HighQualityBilinear;
                    e.Graphics.CompositingQuality = CompositingQuality.HighQuality;
                    e.Graphics.SmoothingMode = SmoothingMode.HighQuality;
                    e.Graphics.DrawImage(adjustedImage, e.ImageRectangle);
                }
            }
            else
            {
                base.OnRenderItemImage(e);
            }
        }
    }

    public class CustomColorTable : ProfessionalColorTable
    {
        public OSThemeColors Colors
        { get; set; }

        public CustomColorTable(OSThemeColors _Colors)
        {
            Colors = _Colors;
            UseSystemColors = false;
        }

        public override Color ImageMarginGradientBegin => Colors.Control;
        public override Color ImageMarginGradientMiddle => Colors.Control;
        public override Color ImageMarginGradientEnd => Colors.Control;
    }

    public class ControlStatusStorage
    {
        private readonly ConditionalWeakTable<Control, ControlStatusInfo> _controlsProcessed = new();
        public void ExcludeFromProcessing(Control control)
        {
            _controlsProcessed.Remove(control);
            _controlsProcessed.Add(control, new ControlStatusInfo() { IsExcluded = true });
        }

        public ControlStatusInfo?
        GetControlStatusInfo(Control control)
        {
            _controlsProcessed.TryGetValue(control, out ControlStatusInfo? info);
            return info;
        }

        public void RegisterProcessedControl(Control control, bool isDarkMode)
        {
            _controlsProcessed.Add(control,
                new ControlStatusInfo() { IsExcluded = false, LastThemeAppliedIsDark = isDarkMode });
        }
    }

    public class ControlStatusInfo
    {
        public bool IsExcluded
        { get; set; }
        public bool LastThemeAppliedIsDark
        { get; set; }
    }
}

--------------------------------------------------
// Full Path: C:/Users/anon/PROGRAMMING/C#/SimpleFirewall/VS Minimal Firewall/MinimalFirewall-NET8/Backups/v2.5.5 - ws/2.5.5.6 - security vulnerability fix 3/DashboardControl.cs
--------------------------------------------------------------------------------
using DarkModeForms;
using MinimalFirewall.TypedObjects;
using System;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Drawing;
using System.Linq;
using System.Windows.Forms;

namespace MinimalFirewall
{
    public partial class DashboardControl : UserControl
    {
        private MainViewModel _viewModel = null!;
        private AppSettings _appSettings = null!;
        private IconService _iconService = null!;
        private WildcardRuleService _wildcardRuleService = null!;
        private FirewallActionsService _actionsService = null!;
        private BackgroundFirewallTaskService _backgroundTaskService = null!;
        private BindingSource _bindingSource;

        public DashboardControl()
        {
            InitializeComponent();
            this.DoubleBuffered = true;
        }

        public void Initialize(MainViewModel viewModel, AppSettings appSettings, IconService iconService, DarkModeCS dm, WildcardRuleService wildcardRuleService, FirewallActionsService actionsService, BackgroundFirewallTaskService backgroundTaskService)
        {
            _viewModel = viewModel;
            _appSettings = appSettings;
            _iconService = iconService;
            _wildcardRuleService = wildcardRuleService;
            _actionsService = actionsService;
            _backgroundTaskService = backgroundTaskService;

            dashboardDataGridView.AutoGenerateColumns = false;
            _bindingSource = new BindingSource { DataSource = _viewModel.PendingConnections };
            dashboardDataGridView.DataSource = _bindingSource;

            _viewModel.PendingConnections.CollectionChanged += PendingConnections_CollectionChanged;
            LoadDashboardItems();
        }

        public void SetIconColumnVisibility(bool visible)
        {
            if (dashIconColumn != null)
            {
                dashIconColumn.Visible = visible;
            }
        }

        private void PendingConnections_CollectionChanged(object? sender, NotifyCollectionChangedEventArgs e)
        {
            if (this.InvokeRequired)
            {
                this.Invoke(new Action(LoadDashboardItems));
            }
            else
            {
                LoadDashboardItems();
            }
        }

        private void LoadDashboardItems()
        {
            _bindingSource.ResetBindings(false);
            dashboardDataGridView.Refresh();
        }

        private void dashboardDataGridView_CellContentClick(object sender, DataGridViewCellEventArgs e)
        {
            if (e.RowIndex < 0) return;

            var grid = (DataGridView)sender;
            var column = grid.Columns[e.ColumnIndex];

            if (grid.Rows[e.RowIndex].DataBoundItem is PendingConnectionViewModel pending)
            {
                if (column is DataGridViewButtonColumn)
                {
                    if (column.Name == "allowButtonColumn")
                    {
                        _viewModel.ProcessDashboardAction(pending, "Allow");
                    }
                    else if (column.Name == "blockButtonColumn")
                    {
                        _viewModel.ProcessDashboardAction(pending, "Block");
                    }
                    else if (column.Name == "ignoreButtonColumn")
                    {
                        _viewModel.ProcessDashboardAction(pending, "Ignore");
                    }
                }
            }
        }

        private void dashboardDataGridView_CellFormatting(object sender, DataGridViewCellFormattingEventArgs e)
        {
            if (e.RowIndex < 0) return;

            var grid = (DataGridView)sender;

            if (grid.Columns[e.ColumnIndex].Name == "dashIconColumn")
            {
                if (grid.Rows[e.RowIndex].DataBoundItem is PendingConnectionViewModel pending && _appSettings.ShowAppIcons)
                {
                    int iconIndex = _iconService.GetIconIndex(pending.AppPath);
                    if (iconIndex != -1 && _iconService.ImageList != null)
                    {
                        e.Value = _iconService.ImageList.Images[iconIndex];
                    }
                }
                return;
            }

            var allowColumn = grid.Columns["allowButtonColumn"];
            var blockColumn = grid.Columns["blockButtonColumn"];
            var ignoreColumn = grid.Columns["ignoreButtonColumn"];

            if (e.ColumnIndex == allowColumn.Index)
            {
                e.CellStyle.BackColor = Color.FromArgb(204, 255, 204);
                e.CellStyle.ForeColor = Color.Black;
            }
            else if (e.ColumnIndex == blockColumn.Index)
            {
                e.CellStyle.BackColor = Color.FromArgb(255, 204, 204);
                e.CellStyle.ForeColor = Color.Black;
            }

            if (grid.Rows[e.RowIndex].Selected)
            {
                e.CellStyle.SelectionBackColor = SystemColors.Highlight;
                e.CellStyle.SelectionForeColor = SystemColors.HighlightText;
            }
            else
            {
                e.CellStyle.SelectionBackColor = e.CellStyle.BackColor;
                e.CellStyle.SelectionForeColor = e.CellStyle.ForeColor;
            }
        }

        private void dashboardDataGridView_RowPostPaint(object sender, DataGridViewRowPostPaintEventArgs e)
        {
            var grid = (DataGridView)sender;
            var row = grid.Rows[e.RowIndex];

            if (row.Selected) return;

            var mouseOverRow = grid.HitTest(grid.PointToClient(MousePosition).X, grid.PointToClient(MousePosition).Y).RowIndex;
            if (e.RowIndex == mouseOverRow)
            {
                using var overlayBrush = new SolidBrush(Color.FromArgb(25, Color.Black));
                e.Graphics.FillRectangle(overlayBrush, e.RowBounds);
            }
        }

        private void dashboardDataGridView_CellMouseEnter(object sender, DataGridViewCellEventArgs e)
        {
            if (e.RowIndex >= 0)
            {
                var grid = (DataGridView)sender;
                grid.InvalidateRow(e.RowIndex);
            }
        }

        private void dashboardDataGridView_CellMouseLeave(object sender, DataGridViewCellEventArgs e)
        {
            if (e.RowIndex >= 0)
            {
                var grid = (DataGridView)sender;
                grid.InvalidateRow(e.RowIndex);
            }
        }

        private void TempAllowMenuItem_Click(object sender, EventArgs e)
        {
            if (dashboardDataGridView.SelectedRows.Count > 0 &&
                dashboardDataGridView.SelectedRows[0].DataBoundItem is PendingConnectionViewModel pending &&
                sender is ToolStripMenuItem menuItem &&
                int.TryParse(menuItem.Tag?.ToString(), out int minutes))
            {
                _viewModel.ProcessTemporaryDashboardAction(pending, "TemporaryAllow", TimeSpan.FromMinutes(minutes));
            }
        }



        private void PermanentAllowToolStripMenuItem_Click(object sender, EventArgs e)
        {
            if (dashboardDataGridView.SelectedRows.Count > 0 &&
                dashboardDataGridView.SelectedRows[0].DataBoundItem is PendingConnectionViewModel pending)
            {
                _viewModel.ProcessDashboardAction(pending, "Allow");
            }
        }

        private void AllowAndTrustPublisherToolStripMenuItem_Click(object sender, EventArgs e)
        {
            if (dashboardDataGridView.SelectedRows.Count > 0 &&
                dashboardDataGridView.SelectedRows[0].DataBoundItem is PendingConnectionViewModel pending)
            {
                _viewModel.ProcessDashboardAction(pending, "Allow", trustPublisher: true);
            }
        }

        private void PermanentBlockToolStripMenuItem_Click(object sender, EventArgs e)
        {
            if (dashboardDataGridView.SelectedRows.Count > 0 &&
                dashboardDataGridView.SelectedRows[0].DataBoundItem is PendingConnectionViewModel pending)
            {
                _viewModel.ProcessDashboardAction(pending, "Block");
            }
        }

        private void IgnoreToolStripMenuItem_Click(object sender, EventArgs e)
        {
            if (dashboardDataGridView.SelectedRows.Count > 0 &&
                dashboardDataGridView.SelectedRows[0].DataBoundItem is PendingConnectionViewModel pending)
            {
                _viewModel.ProcessDashboardAction(pending, "Ignore");
            }
        }

        private void createWildcardRuleToolStripMenuItem_Click(object sender, EventArgs e)
        {
            if (dashboardDataGridView.SelectedRows.Count > 0 &&
                dashboardDataGridView.SelectedRows[0].DataBoundItem is PendingConnectionViewModel pending)
            {
                using var wildcardDialog = new WildcardCreatorForm(_wildcardRuleService, pending.AppPath, _appSettings);
                if (wildcardDialog.ShowDialog(this.FindForm()) == DialogResult.OK)
                {
                    var newRule = wildcardDialog.NewRule;
                    _backgroundTaskService.EnqueueTask(new FirewallTask(FirewallTaskType.AddWildcardRule, newRule));

                    string decision = newRule.Action.StartsWith("Block", StringComparison.OrdinalIgnoreCase) ? "Block" : "Allow";
                    var allowPayload = new ProcessPendingConnectionPayload
                    {
                        PendingConnection = pending,
                        Decision = decision,
                        Duration = default,
                        TrustPublisher = false
                    };
                    _backgroundTaskService.EnqueueTask(new FirewallTask(FirewallTaskType.ProcessPendingConnection, allowPayload));
                }
            }
        }

        private void ContextMenu_Opening(object sender, System.ComponentModel.CancelEventArgs e)
        {
            if (dashboardDataGridView.SelectedRows.Count == 0)
            {
                e.Cancel = true;
                return;
            }

            if (dashboardDataGridView.SelectedRows[0].DataBoundItem is PendingConnectionViewModel pending)
            {
                bool isSigned = SignatureValidationService.GetPublisherInfo(pending.AppPath, out _);
                allowAndTrustPublisherToolStripMenuItem.Visible = isSigned;
            }
        }

        private void createAdvancedRuleToolStripMenuItem_Click(object sender, EventArgs e)
        {
            if (dashboardDataGridView.SelectedRows.Count > 0 &&
                dashboardDataGridView.SelectedRows[0].DataBoundItem is PendingConnectionViewModel pending)
            {
                using var dialog = new
                 CreateAdvancedRuleForm(_actionsService, pending.AppPath!, pending.Direction!, _appSettings);
                dialog.ShowDialog(this.FindForm());
            }
        }

        private void openFileLocationToolStripMenuItem1_Click(object sender, EventArgs e)
        {
            if (dashboardDataGridView.SelectedRows.Count > 0 &&
                dashboardDataGridView.SelectedRows[0].DataBoundItem is PendingConnectionViewModel pending &&
                !string.IsNullOrEmpty(pending.AppPath))
            {
                if (!File.Exists(pending.AppPath) && !Directory.Exists(pending.AppPath))
                {
                    DarkModeForms.Messenger.MessageBox("The path for this item is no longer valid or does not exist.", "Path Not Found", MessageBoxButtons.OK, MessageBoxIcon.Error);
                    return;
                }

                try
                {
                    System.Diagnostics.Process.Start("explorer.exe", $"/select, \"{pending.AppPath}\"");
                }
                catch (Exception ex) when (ex is Win32Exception or FileNotFoundException)
                {
                    DarkModeForms.Messenger.MessageBox($"Could not open file location.\n\nError: {ex.Message}", "Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
                }
            }
            else
            {
                DarkModeForms.Messenger.MessageBox("The path for this item is not available.", "Path Not Found", MessageBoxButtons.OK, MessageBoxIcon.Error);
            }
        }

        private void copyDetailsToolStripMenuItem_Click(object sender, EventArgs e)
        {
            if (dashboardDataGridView.SelectedRows.Count > 0 &&
                dashboardDataGridView.SelectedRows[0].DataBoundItem is PendingConnectionViewModel pending)
            {
                var details = new System.Text.StringBuilder();
                details.AppendLine($"Type: Pending Connection");
                details.AppendLine($"Application: {pending.FileName}");
                details.AppendLine($"Path: {pending.AppPath}");
                details.AppendLine($"Service: {pending.ServiceName}");
                details.AppendLine($"Direction: {pending.Direction}");
                Clipboard.SetText(details.ToString());
            }
        }
        private void showBlockingRuleInfoToolStripMenuItem_Click(object sender, EventArgs e)
        {
            if (dashboardDataGridView.SelectedRows.Count > 0 &&
                dashboardDataGridView.SelectedRows[0].DataBoundItem is PendingConnectionViewModel pending)
            {
                string filterId = string.IsNullOrEmpty(pending.FilterId) ? "N/A" : pending.FilterId;
                string layerId = string.IsNullOrEmpty(pending.LayerId) ? "N/A" : pending.LayerId;

                string message = $"Application: {pending.FileName}\n" +
                                 $"Direction: {pending.Direction}\n" +
                                 $"Remote: {pending.RemoteAddress}:{pending.RemotePort}\n\n" +
                                 $"Blocking Filter ID: {filterId}\n" +
                                 $"Blocking Layer ID: {layerId}\n\n" +
                                 "You can use these IDs to search within the advanced 'Windows Defender Firewall' console (wf.msc) or with PowerShell's Get-NetFirewallRule / Get-NetFirewallFilter commands to find the specific rule/filter.";

                DarkModeForms.Messenger.MessageBox(message, "Blocking Rule Information", MessageBoxButtons.OK, DarkModeForms.MsgIcon.Info);
            }
        }

    }
}



--------------------------------------------------
// Full Path: C:/Users/anon/PROGRAMMING/C#/SimpleFirewall/VS Minimal Firewall/MinimalFirewall-NET8/Backups/v2.5.5 - ws/2.5.5.6 - security vulnerability fix 3/DashboardControl.Designer.cs
--------------------------------------------------------------------------------
// File: DashboardControl.Designer.cs
namespace MinimalFirewall
{
    partial class DashboardControl
    {
        private System.ComponentModel.IContainer components = null;
        private System.Windows.Forms.ContextMenuStrip dashboardContextMenu;
        private System.Windows.Forms.ToolStripMenuItem tempAllowToolStripMenuItem;
        private System.Windows.Forms.ToolStripMenuItem allow2MinutesToolStripMenuItem;
        private System.Windows.Forms.ToolStripMenuItem allow5MinutesToolStripMenuItem;
        private System.Windows.Forms.ToolStripMenuItem allow15MinutesToolStripMenuItem;
        private System.Windows.Forms.ToolStripMenuItem allow1HourToolStripMenuItem;
        private System.Windows.Forms.ToolStripMenuItem allow3HoursToolStripMenuItem;
        private System.Windows.Forms.ToolStripMenuItem allow8HoursToolStripMenuItem;
        private System.Windows.Forms.ToolStripSeparator toolStripSeparator3;
        private System.Windows.Forms.ToolStripMenuItem permanentAllowToolStripMenuItem;
        private System.Windows.Forms.ToolStripMenuItem allowAndTrustPublisherToolStripMenuItem;
        private System.Windows.Forms.ToolStripMenuItem permanentBlockToolStripMenuItem;
        private System.Windows.Forms.ToolStripMenuItem ignoreToolStripMenuItem;
        private System.Windows.Forms.ToolStripSeparator toolStripSeparator4;
        private System.Windows.Forms.ToolStripMenuItem createWildcardRuleToolStripMenuItem;
        private System.Windows.Forms.ToolStripSeparator toolStripSeparator5;
        private System.Windows.Forms.ToolStripMenuItem createAdvancedRuleToolStripMenuItem;
        private System.Windows.Forms.ToolStripSeparator toolStripSeparator7;
        private System.Windows.Forms.ToolStripMenuItem openFileLocationToolStripMenuItem1;
        private System.Windows.Forms.ToolStripSeparator toolStripSeparator6;
        private System.Windows.Forms.ToolStripMenuItem copyDetailsToolStripMenuItem;
        private System.Windows.Forms.DataGridView dashboardDataGridView;
        private System.Windows.Forms.DataGridViewImageColumn dashIconColumn;
        private System.Windows.Forms.DataGridViewButtonColumn allowButtonColumn;
        private System.Windows.Forms.DataGridViewButtonColumn blockButtonColumn;
        private System.Windows.Forms.DataGridViewButtonColumn ignoreButtonColumn;
        private System.Windows.Forms.DataGridViewTextBoxColumn dashAppColumn;
        private System.Windows.Forms.DataGridViewTextBoxColumn dashServiceColumn;
        private System.Windows.Forms.DataGridViewTextBoxColumn dashDirectionColumn;
        private System.Windows.Forms.DataGridViewTextBoxColumn dashPathColumn;
        private System.Windows.Forms.ToolStripMenuItem showBlockingRuleInfoToolStripMenuItem;
        private System.Windows.Forms.ToolStripSeparator toolStripSeparator8;


        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Component Designer generated code
        private void InitializeComponent()
        {
            this.components = new System.ComponentModel.Container();
            System.Windows.Forms.DataGridViewCellStyle dataGridViewCellStyle1 = new System.Windows.Forms.DataGridViewCellStyle();
            System.Windows.Forms.DataGridViewCellStyle dataGridViewCellStyle2 = new System.Windows.Forms.DataGridViewCellStyle();
            System.Windows.Forms.DataGridViewCellStyle dataGridViewCellStyle3 = new System.Windows.Forms.DataGridViewCellStyle();
            System.Windows.Forms.DataGridViewCellStyle dataGridViewCellStyle4 = new System.Windows.Forms.DataGridViewCellStyle();
            System.Windows.Forms.DataGridViewCellStyle dataGridViewCellStyle5 = new System.Windows.Forms.DataGridViewCellStyle();
            this.dashboardContextMenu = new System.Windows.Forms.ContextMenuStrip(this.components);
            this.tempAllowToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.allow2MinutesToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.allow5MinutesToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.allow15MinutesToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.allow1HourToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.allow3HoursToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.allow8HoursToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.toolStripSeparator3 = new System.Windows.Forms.ToolStripSeparator();
            this.permanentAllowToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.allowAndTrustPublisherToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.permanentBlockToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.ignoreToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.toolStripSeparator4 = new System.Windows.Forms.ToolStripSeparator();
            this.createWildcardRuleToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.toolStripSeparator5 = new System.Windows.Forms.ToolStripSeparator();
            this.createAdvancedRuleToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.toolStripSeparator7 = new System.Windows.Forms.ToolStripSeparator();
            this.openFileLocationToolStripMenuItem1 = new System.Windows.Forms.ToolStripMenuItem();
            this.toolStripSeparator8 = new System.Windows.Forms.ToolStripSeparator();
            this.showBlockingRuleInfoToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.toolStripSeparator6 = new System.Windows.Forms.ToolStripSeparator();
            this.copyDetailsToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.dashboardDataGridView = new System.Windows.Forms.DataGridView();
            this.dashIconColumn = new System.Windows.Forms.DataGridViewImageColumn();
            this.allowButtonColumn = new System.Windows.Forms.DataGridViewButtonColumn();
            this.blockButtonColumn = new System.Windows.Forms.DataGridViewButtonColumn();
            this.ignoreButtonColumn = new System.Windows.Forms.DataGridViewButtonColumn();
            this.dashAppColumn = new System.Windows.Forms.DataGridViewTextBoxColumn();
            this.dashServiceColumn = new System.Windows.Forms.DataGridViewTextBoxColumn();
            this.dashDirectionColumn = new System.Windows.Forms.DataGridViewTextBoxColumn();
            this.dashPathColumn = new System.Windows.Forms.DataGridViewTextBoxColumn();
            this.dashboardContextMenu.SuspendLayout();
            ((System.ComponentModel.ISupportInitialize)(this.dashboardDataGridView)).BeginInit();
            this.SuspendLayout();
            //
            // dashboardContextMenu
            //
            this.dashboardContextMenu.ImageScalingSize = new System.Drawing.Size(20, 20);
            this.dashboardContextMenu.Items.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.tempAllowToolStripMenuItem,
            this.toolStripSeparator3,
            this.permanentAllowToolStripMenuItem,
            this.allowAndTrustPublisherToolStripMenuItem,
            this.permanentBlockToolStripMenuItem,
            this.ignoreToolStripMenuItem,
            this.toolStripSeparator4,
            this.createWildcardRuleToolStripMenuItem,
            this.toolStripSeparator5,
            this.createAdvancedRuleToolStripMenuItem,
            this.toolStripSeparator7,
            this.openFileLocationToolStripMenuItem1,
            this.toolStripSeparator8,
            this.showBlockingRuleInfoToolStripMenuItem,
            this.toolStripSeparator6,
            this.copyDetailsToolStripMenuItem});
            this.dashboardContextMenu.Name = "dashboardContextMenu";
            this.dashboardContextMenu.Size = new System.Drawing.Size(228, 290);
            this.dashboardContextMenu.Opening += new System.ComponentModel.CancelEventHandler(this.ContextMenu_Opening);
            //
            // tempAllowToolStripMenuItem
            //
            this.tempAllowToolStripMenuItem.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.allow2MinutesToolStripMenuItem,
            this.allow5MinutesToolStripMenuItem,
            this.allow15MinutesToolStripMenuItem,
            this.allow1HourToolStripMenuItem,
            this.allow3HoursToolStripMenuItem,
            this.allow8HoursToolStripMenuItem});
            this.tempAllowToolStripMenuItem.Name = "tempAllowToolStripMenuItem";
            this.tempAllowToolStripMenuItem.Size = new System.Drawing.Size(227, 24);
            this.tempAllowToolStripMenuItem.Text = "Allow Temporarily";
            //
            // allow2MinutesToolStripMenuItem
            //
            this.allow2MinutesToolStripMenuItem.Name = "allow2MinutesToolStripMenuItem";
            this.allow2MinutesToolStripMenuItem.Size = new System.Drawing.Size(162, 26);
            this.allow2MinutesToolStripMenuItem.Tag = "2";
            this.allow2MinutesToolStripMenuItem.Text = "2 minutes";
            this.allow2MinutesToolStripMenuItem.Click += new System.EventHandler(this.TempAllowMenuItem_Click);
            //
            // allow5MinutesToolStripMenuItem
            //
            this.allow5MinutesToolStripMenuItem.Name = "allow5MinutesToolStripMenuItem";
            this.allow5MinutesToolStripMenuItem.Size = new System.Drawing.Size(162, 26);
            this.allow5MinutesToolStripMenuItem.Tag = "5";
            this.allow5MinutesToolStripMenuItem.Text = "5 minutes";
            this.allow5MinutesToolStripMenuItem.Click += new System.EventHandler(this.TempAllowMenuItem_Click);
            //
            // allow15MinutesToolStripMenuItem
            //
            this.allow15MinutesToolStripMenuItem.Name = "allow15MinutesToolStripMenuItem";
            this.allow15MinutesToolStripMenuItem.Size = new System.Drawing.Size(162, 26);
            this.allow15MinutesToolStripMenuItem.Tag = "15";
            this.allow15MinutesToolStripMenuItem.Text = "15 minutes";
            this.allow15MinutesToolStripMenuItem.Click += new System.EventHandler(this.TempAllowMenuItem_Click);
            //
            // allow1HourToolStripMenuItem
            //
            this.allow1HourToolStripMenuItem.Name = "allow1HourToolStripMenuItem";
            this.allow1HourToolStripMenuItem.Size = new System.Drawing.Size(162, 26);
            this.allow1HourToolStripMenuItem.Tag = "60";
            this.allow1HourToolStripMenuItem.Text = "1 hour";
            this.allow1HourToolStripMenuItem.Click += new System.EventHandler(this.TempAllowMenuItem_Click);
            //
            // allow3HoursToolStripMenuItem
            //
            this.allow3HoursToolStripMenuItem.Name = "allow3HoursToolStripMenuItem";
            this.allow3HoursToolStripMenuItem.Size = new System.Drawing.Size(162, 26);
            this.allow3HoursToolStripMenuItem.Tag = "180";
            this.allow3HoursToolStripMenuItem.Text = "3 hours";
            this.allow3HoursToolStripMenuItem.Click += new System.EventHandler(this.TempAllowMenuItem_Click);
            //
            // allow8HoursToolStripMenuItem
            //
            this.allow8HoursToolStripMenuItem.Name = "allow8HoursToolStripMenuItem";
            this.allow8HoursToolStripMenuItem.Size = new System.Drawing.Size(162, 26);
            this.allow8HoursToolStripMenuItem.Tag = "480";
            this.allow8HoursToolStripMenuItem.Text = "8 hours";
            this.allow8HoursToolStripMenuItem.Click += new System.EventHandler(this.TempAllowMenuItem_Click);
            //
            // toolStripSeparator3
            //
            this.toolStripSeparator3.Name = "toolStripSeparator3";
            this.toolStripSeparator3.Size = new System.Drawing.Size(224, 6);
            //
            // permanentAllowToolStripMenuItem
            //
            this.permanentAllowToolStripMenuItem.Name = "permanentAllowToolStripMenuItem";
            this.permanentAllowToolStripMenuItem.Size = new System.Drawing.Size(227, 24);
            this.permanentAllowToolStripMenuItem.Text = "Allow";
            this.permanentAllowToolStripMenuItem.Click += new System.EventHandler(this.PermanentAllowToolStripMenuItem_Click);
            //
            // allowAndTrustPublisherToolStripMenuItem
            //
            this.allowAndTrustPublisherToolStripMenuItem.Name = "allowAndTrustPublisherToolStripMenuItem";
            this.allowAndTrustPublisherToolStripMenuItem.Size = new System.Drawing.Size(227, 24);
            this.allowAndTrustPublisherToolStripMenuItem.Text = "Allow and Trust Publisher";
            this.allowAndTrustPublisherToolStripMenuItem.Click += new System.EventHandler(this.AllowAndTrustPublisherToolStripMenuItem_Click);
            //
            // permanentBlockToolStripMenuItem
            //
            this.permanentBlockToolStripMenuItem.Name = "permanentBlockToolStripMenuItem";
            this.permanentBlockToolStripMenuItem.Size = new System.Drawing.Size(227, 24);
            this.permanentBlockToolStripMenuItem.Text = "Block";
            this.permanentBlockToolStripMenuItem.Click += new System.EventHandler(this.PermanentBlockToolStripMenuItem_Click);
            //
            // ignoreToolStripMenuItem
            //
            this.ignoreToolStripMenuItem.Name = "ignoreToolStripMenuItem";
            this.ignoreToolStripMenuItem.Size = new System.Drawing.Size(227, 24);
            this.ignoreToolStripMenuItem.Text = "Ignore";
            this.ignoreToolStripMenuItem.Click += new System.EventHandler(this.IgnoreToolStripMenuItem_Click);
            //
            // toolStripSeparator4
            //
            this.toolStripSeparator4.Name = "toolStripSeparator4";
            this.toolStripSeparator4.Size = new System.Drawing.Size(224, 6);
            //
            // createWildcardRuleToolStripMenuItem
            //
            this.createWildcardRuleToolStripMenuItem.Name = "createWildcardRuleToolStripMenuItem";
            this.createWildcardRuleToolStripMenuItem.Size = new System.Drawing.Size(227, 24);
            this.createWildcardRuleToolStripMenuItem.Text = "Create Wildcard Rule...";
            this.createWildcardRuleToolStripMenuItem.Click += new System.EventHandler(this.createWildcardRuleToolStripMenuItem_Click);
            //
            // toolStripSeparator5
            //
            this.toolStripSeparator5.Name = "toolStripSeparator5";
            this.toolStripSeparator5.Size = new System.Drawing.Size(224, 6);
            //
            // createAdvancedRuleToolStripMenuItem
            //
            this.createAdvancedRuleToolStripMenuItem.Name = "createAdvancedRuleToolStripMenuItem";
            this.createAdvancedRuleToolStripMenuItem.Size = new System.Drawing.Size(227, 24);
            this.createAdvancedRuleToolStripMenuItem.Text = "Create Advanced Rule...";
            this.createAdvancedRuleToolStripMenuItem.Click += new System.EventHandler(this.createAdvancedRuleToolStripMenuItem_Click);
            //
            // toolStripSeparator7
            //
            this.toolStripSeparator7.Name = "toolStripSeparator7";
            this.toolStripSeparator7.Size = new System.Drawing.Size(224, 6);
            //
            // openFileLocationToolStripMenuItem1
            //
            this.openFileLocationToolStripMenuItem1.Name = "openFileLocationToolStripMenuItem1";
            this.openFileLocationToolStripMenuItem1.Size = new System.Drawing.Size(227, 24);
            this.openFileLocationToolStripMenuItem1.Text = "Open File Location";
            this.openFileLocationToolStripMenuItem1.Click += new System.EventHandler(this.openFileLocationToolStripMenuItem1_Click);
            //
            // toolStripSeparator8
            //
            this.toolStripSeparator8.Name = "toolStripSeparator8";
            this.toolStripSeparator8.Size = new System.Drawing.Size(224, 6);
            //
            // showBlockingRuleInfoToolStripMenuItem
            //
            this.showBlockingRuleInfoToolStripMenuItem.Name = "showBlockingRuleInfoToolStripMenuItem";
            this.showBlockingRuleInfoToolStripMenuItem.Size = new System.Drawing.Size(227, 24);
            this.showBlockingRuleInfoToolStripMenuItem.Text = "Show Blocking Rule Info";
            this.showBlockingRuleInfoToolStripMenuItem.Click += new System.EventHandler(this.showBlockingRuleInfoToolStripMenuItem_Click);
            //
            // toolStripSeparator6
            //
            this.toolStripSeparator6.Name = "toolStripSeparator6";
            this.toolStripSeparator6.Size = new System.Drawing.Size(224, 6);
            //
            // copyDetailsToolStripMenuItem
            //
            this.copyDetailsToolStripMenuItem.Name = "copyDetailsToolStripMenuItem";
            this.copyDetailsToolStripMenuItem.Size = new System.Drawing.Size(227, 24);
            this.copyDetailsToolStripMenuItem.Text = "Copy Details";
            this.copyDetailsToolStripMenuItem.Click += new System.EventHandler(this.copyDetailsToolStripMenuItem_Click);
            //
            // dashboardDataGridView
            //
            this.dashboardDataGridView.AllowUserToAddRows = false;
            this.dashboardDataGridView.AllowUserToDeleteRows = false;
            this.dashboardDataGridView.AllowUserToResizeRows = false;
            this.dashboardDataGridView.AutoSizeColumnsMode = System.Windows.Forms.DataGridViewAutoSizeColumnsMode.Fill;
            this.dashboardDataGridView.BackgroundColor = System.Drawing.SystemColors.Control;
            this.dashboardDataGridView.BorderStyle = System.Windows.Forms.BorderStyle.None;
            this.dashboardDataGridView.CellBorderStyle = System.Windows.Forms.DataGridViewCellBorderStyle.None;
            this.dashboardDataGridView.ColumnHeadersBorderStyle = System.Windows.Forms.DataGridViewHeaderBorderStyle.None;
            dataGridViewCellStyle1.Alignment = System.Windows.Forms.DataGridViewContentAlignment.MiddleLeft;
            dataGridViewCellStyle1.BackColor = System.Drawing.SystemColors.Control;
            dataGridViewCellStyle1.Font = new System.Drawing.Font("Segoe UI", 9F);
            dataGridViewCellStyle1.ForeColor = System.Drawing.SystemColors.WindowText;
            dataGridViewCellStyle1.SelectionBackColor = System.Drawing.SystemColors.Highlight;
            dataGridViewCellStyle1.SelectionForeColor = System.Drawing.SystemColors.HighlightText;
            dataGridViewCellStyle1.WrapMode = System.Windows.Forms.DataGridViewTriState.True;
            this.dashboardDataGridView.ColumnHeadersDefaultCellStyle = dataGridViewCellStyle1;
            this.dashboardDataGridView.ColumnHeadersHeightSizeMode = System.Windows.Forms.DataGridViewColumnHeadersHeightSizeMode.AutoSize;
            this.dashboardDataGridView.Columns.AddRange(new System.Windows.Forms.DataGridViewColumn[] {
            this.dashIconColumn,
            this.allowButtonColumn,
            this.blockButtonColumn,
            this.ignoreButtonColumn,
            this.dashAppColumn,
            this.dashServiceColumn,
            this.dashDirectionColumn,
            this.dashPathColumn});
            this.dashboardDataGridView.ContextMenuStrip = this.dashboardContextMenu;
            this.dashboardDataGridView.Dock = System.Windows.Forms.DockStyle.Fill;
            this.dashboardDataGridView.EnableHeadersVisualStyles = false;
            this.dashboardDataGridView.GridColor = System.Drawing.SystemColors.Control;
            this.dashboardDataGridView.Location = new System.Drawing.Point(0, 0);
            this.dashboardDataGridView.MultiSelect = false;
            this.dashboardDataGridView.Name = "dashboardDataGridView";
            this.dashboardDataGridView.ReadOnly = true;
            this.dashboardDataGridView.RowHeadersVisible = false;
            this.dashboardDataGridView.RowTemplate.Height = 32;
            this.dashboardDataGridView.SelectionMode = System.Windows.Forms.DataGridViewSelectionMode.FullRowSelect;
            this.dashboardDataGridView.Size = new System.Drawing.Size(800, 600);
            this.dashboardDataGridView.TabIndex = 2;
            this.dashboardDataGridView.CellContentClick += new System.Windows.Forms.DataGridViewCellEventHandler(this.dashboardDataGridView_CellContentClick);
            this.dashboardDataGridView.CellFormatting += new System.Windows.Forms.DataGridViewCellFormattingEventHandler(this.dashboardDataGridView_CellFormatting);
            this.dashboardDataGridView.CellMouseEnter += new System.Windows.Forms.DataGridViewCellEventHandler(this.dashboardDataGridView_CellMouseEnter);
            this.dashboardDataGridView.CellMouseLeave += new System.Windows.Forms.DataGridViewCellEventHandler(this.dashboardDataGridView_CellMouseLeave);
            this.dashboardDataGridView.RowPostPaint += new System.Windows.Forms.DataGridViewRowPostPaintEventHandler(this.dashboardDataGridView_RowPostPaint);
            //
            // dashIconColumn
            //
            this.dashIconColumn.AutoSizeMode = System.Windows.Forms.DataGridViewAutoSizeColumnMode.None;
            this.dashIconColumn.DataPropertyName = "AppPath";
            this.dashIconColumn.FillWeight = 10F;
            this.dashIconColumn.HeaderText = "";
            this.dashIconColumn.ImageLayout = System.Windows.Forms.DataGridViewImageCellLayout.Zoom;
            this.dashIconColumn.MinimumWidth = 32;
            this.dashIconColumn.Name = "dashIconColumn";
            this.dashIconColumn.ReadOnly = true;
            this.dashIconColumn.Resizable = System.Windows.Forms.DataGridViewTriState.False;
            this.dashIconColumn.Width = 32;
            //
            // allowButtonColumn
            //
            this.allowButtonColumn.AutoSizeMode = System.Windows.Forms.DataGridViewAutoSizeColumnMode.None;
            dataGridViewCellStyle2.Alignment = System.Windows.Forms.DataGridViewContentAlignment.MiddleCenter;
            dataGridViewCellStyle2.WrapMode = System.Windows.Forms.DataGridViewTriState.True;
            this.allowButtonColumn.DefaultCellStyle = dataGridViewCellStyle2;
            this.allowButtonColumn.FillWeight = 15F;
            this.allowButtonColumn.FlatStyle = System.Windows.Forms.FlatStyle.Flat;
            this.allowButtonColumn.HeaderText = "Action";
            this.allowButtonColumn.MinimumWidth = 70;
            this.allowButtonColumn.Name = "allowButtonColumn";
            this.allowButtonColumn.ReadOnly = true;
            this.allowButtonColumn.Text = "Allow";
            this.allowButtonColumn.UseColumnTextForButtonValue = true;
            this.allowButtonColumn.Width = 70;
            //
            // blockButtonColumn
            //
            this.blockButtonColumn.AutoSizeMode = System.Windows.Forms.DataGridViewAutoSizeColumnMode.None;
            dataGridViewCellStyle3.Alignment = System.Windows.Forms.DataGridViewContentAlignment.MiddleCenter;
            dataGridViewCellStyle3.WrapMode = System.Windows.Forms.DataGridViewTriState.True;
            this.blockButtonColumn.DefaultCellStyle = dataGridViewCellStyle3;
            this.blockButtonColumn.FillWeight = 15F;
            this.blockButtonColumn.FlatStyle = System.Windows.Forms.FlatStyle.Flat;
            this.blockButtonColumn.HeaderText = "";
            this.blockButtonColumn.MinimumWidth = 70;
            this.blockButtonColumn.Name = "blockButtonColumn";
            this.blockButtonColumn.ReadOnly = true;
            this.blockButtonColumn.Text = "Block";
            this.blockButtonColumn.UseColumnTextForButtonValue = true;
            this.blockButtonColumn.Width = 70;
            //
            // ignoreButtonColumn
            //
            this.ignoreButtonColumn.AutoSizeMode = System.Windows.Forms.DataGridViewAutoSizeColumnMode.None;
            dataGridViewCellStyle4.Alignment = System.Windows.Forms.DataGridViewContentAlignment.MiddleCenter;
            dataGridViewCellStyle4.WrapMode = System.Windows.Forms.DataGridViewTriState.True;
            this.ignoreButtonColumn.DefaultCellStyle = dataGridViewCellStyle4;
            this.ignoreButtonColumn.FillWeight = 15F;
            this.ignoreButtonColumn.FlatStyle = System.Windows.Forms.FlatStyle.Flat;
            this.ignoreButtonColumn.HeaderText = "";
            this.ignoreButtonColumn.MinimumWidth = 70;
            this.ignoreButtonColumn.Name = "ignoreButtonColumn";
            this.ignoreButtonColumn.ReadOnly = true;
            this.ignoreButtonColumn.Text = "Ignore";
            this.ignoreButtonColumn.UseColumnTextForButtonValue = true;
            this.ignoreButtonColumn.Width = 70;
            //
            // dashAppColumn
            //
            this.dashAppColumn.DataPropertyName = "FileName";
            this.dashAppColumn.FillWeight = 30F;
            this.dashAppColumn.HeaderText = "Application";
            this.dashAppColumn.Name = "dashAppColumn";
            this.dashAppColumn.ReadOnly = true;
            //
            // dashServiceColumn
            //
            this.dashServiceColumn.DataPropertyName = "ServiceName";
            this.dashServiceColumn.FillWeight = 30F;
            this.dashServiceColumn.HeaderText = "Service";
            this.dashServiceColumn.Name = "dashServiceColumn";
            this.dashServiceColumn.ReadOnly = true;
            //
            // dashDirectionColumn
            //
            this.dashDirectionColumn.DataPropertyName = "Direction";
            this.dashDirectionColumn.FillWeight = 20F;
            this.dashDirectionColumn.HeaderText = "Direction";
            this.dashDirectionColumn.Name = "dashDirectionColumn";
            this.dashDirectionColumn.ReadOnly = true;
            //
            // dashPathColumn
            //
            this.dashPathColumn.DataPropertyName = "AppPath";
            dataGridViewCellStyle5.Alignment = System.Windows.Forms.DataGridViewContentAlignment.MiddleLeft;
            this.dashPathColumn.DefaultCellStyle = dataGridViewCellStyle5;
            this.dashPathColumn.FillWeight = 50F;
            this.dashPathColumn.HeaderText = "Path";
            this.dashPathColumn.Name = "dashPathColumn";
            this.dashPathColumn.ReadOnly = true;
            //
            // DashboardControl
            //
            this.AutoScaleDimensions = new System.Drawing.SizeF(8F, 20F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.Controls.Add(this.dashboardDataGridView);
            this.Name = "DashboardControl";
            this.Size = new System.Drawing.Size(800, 600);
            this.dashboardContextMenu.ResumeLayout(false);
            ((System.ComponentModel.ISupportInitialize)(this.dashboardDataGridView)).EndInit();
            this.ResumeLayout(false);

        }
        #endregion
    }
}

--------------------------------------------------
// Full Path: C:/Users/anon/PROGRAMMING/C#/SimpleFirewall/VS Minimal Firewall/MinimalFirewall-NET8/Backups/v2.5.5 - ws/2.5.5.6 - security vulnerability fix 3/DataModels.cs
--------------------------------------------------------------------------------
using System.IO;
using System.ComponentModel;
using NetFwTypeLib;
using System.Text.Json.Serialization;
using MinimalFirewall.TypedObjects;

namespace MinimalFirewall
{
    public class ExportContainer
    {
        public DateTime ExportDate { get; set; }
        public List<AdvancedRuleViewModel> AdvancedRules { get; set; } = [];
        public List<WildcardRule> WildcardRules { get; set; } = [];
    }

    public enum SearchMode { Name, Path }
    public enum RuleType { Program, Service, UWP, Wildcard, Advanced }
    public enum ChangeType { New, Modified, Deleted }

    public class FirewallRuleChange
    {
        public ChangeType Type { get; set; }
        public AdvancedRuleViewModel Rule { get; set; } = new();

        public string Name => Rule.Name;
        public string Status => Rule.Status;
        public string ProtocolName => Rule.ProtocolName;
        public string LocalPorts => Rule.LocalPorts;
        public string RemotePorts => Rule.RemotePorts;
        public string LocalAddresses => Rule.LocalAddresses;
        public string RemoteAddresses => Rule.RemoteAddresses;
        public string ApplicationName => Rule.ApplicationName;
        public string ServiceName => Rule.ServiceName;
        public string Profiles => Rule.Profiles;
        public string Grouping => Rule.Grouping;
        public string Description => Rule.Description;
    }

    public class UnifiedRuleViewModel
    {
        public string Name { get; set; } = string.Empty;
        public string Path { get; set; } = string.Empty;
        public string Status { get; set; } = string.Empty;
        public RuleType Type { get; set; }

        [JsonIgnore]
        public string RuleTarget
        {
            get
            {
                return Type switch
                {
                    RuleType.Program => Path,
                    RuleType.Service => Name,
                    RuleType.UWP => UwpPackageFamilyName ?? string.Empty,
                    _ => string.Empty
                };
            }
        }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        public string? UwpPackageFamilyName { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        public WildcardRule? WildcardDefinition { get; set; }
    }

    public class AggregatedRuleViewModel : AdvancedRuleViewModel
    {
        public string InboundStatus { get; set; } = string.Empty;
        public string OutboundStatus { get; set; } = string.Empty;
        public List<AdvancedRuleViewModel> UnderlyingRules { get; set; } = [];
    }

    public class AdvancedRuleViewModel
    {
        public string Name { get; set; } = string.Empty;
        public string Status { get; set; } = string.Empty;
        public bool IsEnabled { get; set; }
        public Directions Direction { get; set; }
        public string LocalPorts { get; set; } = string.Empty;
        public string RemotePorts { get; set; } = string.Empty;
        public int Protocol { get; set; }
        public string ProtocolName { get; set; } = string.Empty;
        public string ApplicationName { get; set; } = string.Empty;
        public string ServiceName { get; set; } = string.Empty;
        public string LocalAddresses { get; set; } = string.Empty;
        public string RemoteAddresses { get; set; } = string.Empty;
        public string Profiles { get; set; } = string.Empty;
        public string Description { get; set; } = string.Empty;
        public string Grouping { get; set; } = string.Empty;
        public RuleType Type { get; set; }
        public WildcardRule? WildcardDefinition { get; set; }
        public string InterfaceTypes { get; set; } = string.Empty;
        public string IcmpTypesAndCodes { get; set; } = string.Empty;

        public bool HasSameSettings(AdvancedRuleViewModel? other)
        {
            if (other == null) return false;

            return
                this.Name == other.Name &&
                this.Description == other.Description &&
                this.IsEnabled == other.IsEnabled &&
                this.Status == other.Status &&
                this.Direction == other.Direction &&
                this.Protocol == other.Protocol &&
                this.ApplicationName == other.ApplicationName &&
                this.ServiceName == other.ServiceName &&
                this.LocalPorts == other.LocalPorts &&
                this.RemotePorts == other.RemotePorts &&
                this.LocalAddresses == other.LocalAddresses &&
                this.RemoteAddresses == other.RemoteAddresses &&
                this.Profiles == other.Profiles &&
                this.Grouping == other.Grouping &&
                this.InterfaceTypes == other.InterfaceTypes &&
                this.IcmpTypesAndCodes == other.IcmpTypesAndCodes;
        }
    }

    public class FirewallRuleHashModel
    {
        public string? Name { get; set; }
        public string? Description { get; set; }
        public string? ApplicationName { get; set; }
        public string? ServiceName { get; set; }
        public int Protocol { get; set; }
        public string? LocalPorts { get; set; }
        public string? RemotePorts { get; set; }
        public string? LocalAddresses { get; set; }
        public string? RemoteAddresses { get; set; }
        public NET_FW_RULE_DIRECTION_ Direction { get; set; }
        public NET_FW_ACTION_ Action { get; set; }
        public bool Enabled { get; set; }
    }

    public class ProgramViewModel
    {
        public string Name { get; set; } = string.Empty;
        public string ExePath { get; set; } = string.Empty;
    }

    public class RuleFilterViewModel : INotifyPropertyChanged
    {
        private bool _isEnabled = true;
        public string Name { get; set; } = string.Empty;
        public RuleType Type { get; set; }
        public bool IsEnabled
        {
            get => _isEnabled;
            set
            {
                _isEnabled = value;
                PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(nameof(IsEnabled)));
            }
        }
        public event PropertyChangedEventHandler? PropertyChanged;
    }

    public class PendingConnectionViewModel
    {
        public string AppPath { get; set; } = string.Empty;
        public string FileName => Path.GetFileName(AppPath);
        public string Direction { get; set; } = string.Empty;
        public string ServiceName { get; set; } = string.Empty;
        public string Protocol { get; set; } = string.Empty;
        public string RemotePort { get; set; } = string.Empty;
        public string RemoteAddress { get; set; } = string.Empty;
        public string FilterId { get; set; } = string.Empty;
        public string LayerId { get; set; } = string.Empty;
    }

    public class WildcardRule
    {
        public string FolderPath { get; set; } = string.Empty;
        public string ExeName { get; set; } = string.Empty;
        public string Action { get; set; } = string.Empty;
        public int Protocol { get; set; } = 256;
        public string LocalPorts { get; set; } = "*";
        public string RemotePorts { get; set; } = "*";
        public string RemoteAddresses { get; set; } = "*";
    }

    [JsonSerializable(typeof(List<WildcardRule>))]
    internal partial class WildcardRuleJsonContext : JsonSerializerContext { }
    [JsonSerializable(typeof(ExportContainer))]
    internal partial class ExportContainerJsonContext : JsonSerializerContext { }

    public class UwpApp
    {
        public string Name { get; set; } = string.Empty;
        public string PackageFamilyName { get; set; } = string.Empty;
        public string Publisher { get; set; } = string.Empty;
        public string Status { get; set; } = "Undefined";
    }

    [JsonSerializable(typeof(List<UwpApp>))]
    internal partial class UwpAppJsonContext : JsonSerializerContext { }

    public class ServiceViewModel
    {
        public string ServiceName { get; set; } = string.Empty;
        public string DisplayName { get; set; } = string.Empty;
        public string ExePath { get; set; } = string.Empty;
    }

    public class RuleCacheModel
    {
        public string? ProgramRules { get; set; }
        public string? AdvancedRules { get; set; }
    }

    [JsonSourceGenerationOptions(DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonSerializable(typeof(List<UnifiedRuleViewModel>))]
    [JsonSerializable(typeof(List<AdvancedRuleViewModel>))]
    [JsonSerializable(typeof(RuleCacheModel))]
    internal partial class CacheJsonContext : JsonSerializerContext { }

    public enum FirewallTaskType
    {
        ApplyApplicationRule,
        ApplyServiceRule,
        ApplyUwpRule,
        DeleteApplicationRules,
        DeleteUwpRules,
        DeleteAdvancedRules,
        DeleteGroup,
        DeleteWildcardRules,
        ProcessPendingConnection,
        AcceptForeignRule,
        DeleteForeignRule,
        AcceptAllForeignRules,
        CreateAdvancedRule,
        AddWildcardRule,
        SetGroupEnabledState,
        UpdateWildcardRule,
        RemoveWildcardRule,
        RemoveWildcardDefinitionOnly,
        DeleteAllMfwRules,
        ImportRules
    }

    public class FirewallTask
    {
        public FirewallTaskType TaskType { get; set; }
        public object Payload { get; set; }

        public FirewallTask(FirewallTaskType taskType, object payload)
        {
            TaskType = taskType;
            Payload = payload;
        }
    }

    public class ApplyApplicationRulePayload { public List<string> AppPaths { get; set; } = []; public string Action { get; set; } = ""; public string? WildcardSourcePath { get; set; } }
    public class ApplyServiceRulePayload { public string ServiceName { get; set; } = ""; public string Action { get; set; } = ""; public string? AppPath { get; set; } }
    public class ApplyUwpRulePayload { public List<UwpApp> UwpApps { get; set; } = []; public string Action { get; set; } = ""; }
    public class DeleteRulesPayload { public List<string> RuleIdentifiers { get; set; } = []; }
    public class DeleteWildcardRulePayload { public WildcardRule Wildcard { get; set; } = new(); }
    public class ProcessPendingConnectionPayload { public PendingConnectionViewModel PendingConnection { get; set; } = new(); public string Decision { get; set; } = ""; public TimeSpan Duration { get; set; } = default; public bool TrustPublisher { get; set; } = false; }
    public class ForeignRuleChangePayload { public FirewallRuleChange Change { get; set; } = new(); }
    public class AllForeignRuleChangesPayload { public List<FirewallRuleChange> Changes { get; set; } = []; }
    public class CreateAdvancedRulePayload { public AdvancedRuleViewModel ViewModel { get; set; } = new(); public string InterfaceTypes { get; set; } = ""; public string IcmpTypesAndCodes { get; set; } = ""; }
    public class SetGroupEnabledStatePayload { public string GroupName { get; set; } = string.Empty; public bool IsEnabled { get; set; } }
    public class UpdateWildcardRulePayload { public WildcardRule OldRule { get; set; } = new(); public WildcardRule NewRule { get; set; } = new(); }
    public class ImportRulesPayload { public string JsonContent { get; set; } = string.Empty; public bool Replace { get; set; } }
}
 

--------------------------------------------------
// Full Path: C:/Users/anon/PROGRAMMING/C#/SimpleFirewall/VS Minimal Firewall/MinimalFirewall-NET8/Backups/v2.5.5 - ws/2.5.5.6 - security vulnerability fix 3/FirewallActionService.cs
--------------------------------------------------------------------------------
using NetFwTypeLib;
using System.Data;
using System.IO;
using MinimalFirewall.TypedObjects;
using System.Collections.Generic;
using System.Linq;
using System.Windows.Forms;
using System.Threading.Tasks;
using System.Collections.Concurrent;
using System.Runtime.InteropServices;
using System.Diagnostics;
using System;
using System.Threading;
using System.Text.Json;

namespace MinimalFirewall
{
    public partial class FirewallActionsService
    {
        private readonly FirewallRuleService firewallService;
        private readonly UserActivityLogger activityLogger;
        private readonly FirewallEventListenerService eventListenerService;
        private readonly ForeignRuleTracker foreignRuleTracker;
        private readonly FirewallSentryService sentryService;
        private readonly PublisherWhitelistService _whitelistService;
        private readonly TemporaryRuleManager _temporaryRuleManager;
        private readonly WildcardRuleService _wildcardRuleService;
        private readonly FirewallDataService _dataService;
        private readonly ConcurrentDictionary<string, System.Threading.Timer> _temporaryRuleTimers = new();
        private const string CryptoRuleName = "Minimal Firewall System - Certificate Checks";
        private const string DhcpRuleName = "Minimal Firewall System - DHCP Client";

        public BackgroundFirewallTaskService? BackgroundTaskService { get; set; }

        public FirewallActionsService(FirewallRuleService firewallService, UserActivityLogger activityLogger, FirewallEventListenerService eventListenerService, ForeignRuleTracker foreignRuleTracker, FirewallSentryService sentryService, PublisherWhitelistService whitelistService, WildcardRuleService wildcardRuleService, FirewallDataService dataService)
        {
            this.firewallService = firewallService;
            this.activityLogger = activityLogger;
            this.eventListenerService = eventListenerService;
            this.foreignRuleTracker = foreignRuleTracker;
            this.sentryService = sentryService;
            this._whitelistService = whitelistService;
            this._wildcardRuleService = wildcardRuleService;
            _temporaryRuleManager = new TemporaryRuleManager();
            _dataService = dataService;
        }

        public void CleanupTemporaryRulesOnStartup()
        {
            var expiredRules = _temporaryRuleManager.GetExpiredRules();
            if (expiredRules.Any())
            {
                var ruleNamesToRemove = expiredRules.Keys.ToList();
                try
                {
                    firewallService.DeleteRulesByName(ruleNamesToRemove);
                    foreach (var ruleName in ruleNamesToRemove)
                    {
                        _temporaryRuleManager.Remove(ruleName);
                    }
                    activityLogger.LogDebug($"Cleaned up {ruleNamesToRemove.Count} expired temporary rules on startup.");
                }
                catch (COMException ex)
                {
                    activityLogger.LogException("CleanupTemporaryRulesOnStartup", ex);
                }
            }
        }

        private static bool IsMfwRule(INetFwRule2 rule)
        {
            if (string.IsNullOrEmpty(rule.Grouping)) return false;
            return rule.Grouping.EndsWith(MFWConstants.MfwRuleSuffix) ||
                   rule.Grouping == MFWConstants.MainRuleGroup ||
                   rule.Grouping == MFWConstants.WildcardRuleGroup;
        }

        private void FindAndQueueDeleteForGeneralBlockRule(string appPath)
        {
            string normalizedAppPath = PathResolver.NormalizePath(appPath);
            var rulesToDelete = new List<string>();
            var allRules = firewallService.GetAllRules();
            try
            {
                foreach (var rule in allRules)
                {
                    if (rule != null &&
                         IsMfwRule(rule) &&
                        rule.Action == NET_FW_ACTION_.NET_FW_ACTION_BLOCK &&
                        string.Equals(PathResolver.NormalizePath(rule.ApplicationName), normalizedAppPath, StringComparison.OrdinalIgnoreCase) &&
                        rule.Protocol == 256 &&
                        rule.LocalPorts == "*" &&
                        rule.RemotePorts == "*")
                    {
                        rulesToDelete.Add(rule.Name);
                    }
                }
            }
            finally
            {
                foreach (var rule in allRules)
                {
                    if (rule != null) Marshal.ReleaseComObject(rule);
                }
            }

            if (rulesToDelete.Any())
            {
                activityLogger.LogDebug($"Auto-deleting general block rule(s) for {appPath} to apply new Allow rule: {string.Join(", ", rulesToDelete)}");
                try
                {
                    firewallService.DeleteRulesByName(rulesToDelete);
                    foreach (var name in rulesToDelete)
                        activityLogger.LogChange("Rule Auto-Deleted", name);
                }
                catch (COMException ex)
                {
                    activityLogger.LogException($"Auto-deleting rules for {appPath}", ex);
                }
            }
        }

        public void ApplyApplicationRuleChange(List<string> appPaths, string action, string? wildcardSourcePath = null)
        {
            var normalizedAppPaths = appPaths.Select(PathResolver.NormalizePath).Where(p => !string.IsNullOrEmpty(p)).Distinct(StringComparer.OrdinalIgnoreCase).ToList();
            if (action.StartsWith("Allow", StringComparison.OrdinalIgnoreCase))
            {
                foreach (var appPath in normalizedAppPaths)
                {
                    FindAndQueueDeleteForGeneralBlockRule(appPath);
                }
            }

            foreach (var appPath in normalizedAppPaths)
            {
                if (!File.Exists(appPath))
                {
                    activityLogger.LogDebug($"[Validation] Skipped creating rule for non-existent path: {appPath}");
                    continue;
                }

                var rulesToRemove = new List<string>();
                if (string.IsNullOrEmpty(wildcardSourcePath))
                {
                    if (action.Contains("Inbound") || action.Contains("(All)"))
                    {
                        rulesToRemove.AddRange(firewallService.GetRuleNamesByPathAndDirection(appPath, NET_FW_RULE_DIRECTION_.NET_FW_RULE_DIR_IN));
                    }
                    if (action.Contains("Outbound") || action.Contains("(All)"))
                    {
                        rulesToRemove.AddRange(firewallService.GetRuleNamesByPathAndDirection(appPath, NET_FW_RULE_DIRECTION_.NET_FW_RULE_DIR_OUT));
                    }
                }

                string appName = Path.GetFileNameWithoutExtension(appPath);
                void createRule(string baseName, Directions dir, Actions act)
                {
                    string description = string.IsNullOrEmpty(wildcardSourcePath) ? "" : $"{MFWConstants.WildcardDescriptionPrefix}{wildcardSourcePath}]";
                    CreateApplicationRule(baseName, appPath, dir, act, ProtocolTypes.Any.Value, description);
                }

                ApplyRuleAction(appName, action, createRule);
                if (rulesToRemove.Any())
                {
                    firewallService.DeleteRulesByName(rulesToRemove);
                }

                activityLogger.LogChange("Rule Changed", action + " for " + appPath);
            }
        }

        public void ApplyServiceRuleChange(string serviceName, string action, string? appPath = null)
        {
            if (string.IsNullOrEmpty(serviceName)) return;

            if (!ParseActionString(action, out Actions parsedAction, out Directions parsedDirection))
            {
                return;
            }

            var rulesToRemove = new List<string>();
            if (parsedDirection.HasFlag(Directions.Incoming))
            {
                rulesToRemove.AddRange(firewallService.DeleteConflictingServiceRules(serviceName, (NET_FW_ACTION_)parsedAction, NET_FW_RULE_DIRECTION_.NET_FW_RULE_DIR_IN));
            }
            if (parsedDirection.HasFlag(Directions.Outgoing))
            {
                rulesToRemove.AddRange(firewallService.DeleteConflictingServiceRules(serviceName, (NET_FW_ACTION_)parsedAction, NET_FW_RULE_DIRECTION_.NET_FW_RULE_DIR_OUT));
            }

            var protocolsToCreate = new List<int> { 6, 17 };

            foreach (var protocol in protocolsToCreate)
            {
                string protocolSuffix = (protocol == 6) ? " - TCP" : " - UDP";
                string actionStr = parsedAction == Actions.Allow ? "" : "Block ";

                if (parsedDirection.HasFlag(Directions.Incoming))
                {
                    string inName = $"{serviceName} - {actionStr}In{protocolSuffix}";
                    CreateServiceRule(inName, serviceName, Directions.Incoming, parsedAction, protocol, appPath);
                }
                if (parsedDirection.HasFlag(Directions.Outgoing))
                {
                    string outName = $"{serviceName} - {actionStr}Out{protocolSuffix}";
                    CreateServiceRule(outName, serviceName, Directions.Outgoing, parsedAction, protocol, appPath);
                }
            }

            if (rulesToRemove.Any())
            {
                firewallService.DeleteRulesByName(rulesToRemove);
            }

            activityLogger.LogChange("Service Rule Changed", action + " for " + serviceName);
        }


        public void ApplyUwpRuleChange(List<UwpApp> uwpApps, string action)
        {
            var validApps = new List<UwpApp>();
            var cachedUwpApps = _dataService.LoadUwpAppsFromCache();
            var cachedPfnSet = new HashSet<string>(cachedUwpApps.Select(a => a.PackageFamilyName), StringComparer.OrdinalIgnoreCase);

            foreach (var app in uwpApps)
            {
                if (cachedPfnSet.Contains(app.PackageFamilyName))
                {
                    validApps.Add(app);
                }
                else
                {
                    activityLogger.LogDebug($"[Validation] Skipped creating rule for non-existent UWP app: {app.Name} ({app.PackageFamilyName})");
                }
            }

            if (validApps.Count == 0) return;

            var packageFamilyNames = validApps.Select(app => app.PackageFamilyName).ToList();
            var rulesToRemove = firewallService.DeleteUwpRules(packageFamilyNames);

            foreach (var app in validApps)
            {
                void createRule(string name, Directions dir, Actions act) => CreateUwpRule(name, app.PackageFamilyName, dir, act, ProtocolTypes.Any.Value);
                ApplyRuleAction(app.Name, action, createRule);
                activityLogger.LogChange("UWP Rule Changed", action + " for " + app.Name);
            }

            if (rulesToRemove.Any())
            {
                firewallService.DeleteRulesByName(rulesToRemove);
            }
        }

        public void DeleteApplicationRules(List<string> appPaths)
        {
            if (appPaths.Count == 0) return;
            try
            {
                firewallService.DeleteRulesByPath(appPaths);
                foreach (var path in appPaths) activityLogger.LogChange("Rule Deleted", path);
            }
            catch (COMException ex)
            {
                activityLogger.LogException($"DeleteApplicationRules for {string.Join(",", appPaths)}", ex);
            }
        }

        public void DeleteRulesForWildcard(WildcardRule wildcard)
        {
            if (wildcard == null) return;
            try
            {
                string descriptionTag = $"{MFWConstants.WildcardDescriptionPrefix}{wildcard.FolderPath}]";
                firewallService.DeleteRulesByDescription(descriptionTag);
                activityLogger.LogChange("Wildcard Rules Deleted", $"Deleted rules for folder {wildcard.FolderPath}");
            }
            catch (COMException ex)
            {
                activityLogger.LogException($"DeleteRulesForWildcard for {wildcard.FolderPath}", ex);
            }
        }

        public void DeleteUwpRules(List<string> packageFamilyNames)
        {
            if (packageFamilyNames.Count == 0) return;
            try
            {
                firewallService.DeleteUwpRules(packageFamilyNames);
                foreach (var pfn in packageFamilyNames) activityLogger.LogChange("UWP Rule Deleted", pfn);
            }
            catch (COMException ex)
            {
                activityLogger.LogException($"DeleteUwpRules for {string.Join(",", packageFamilyNames)}", ex);
            }
        }

        public void DeleteAdvancedRules(List<string> ruleNames)
        {
            if (ruleNames.Count == 0) return;
            try
            {
                firewallService.DeleteRulesByName(ruleNames);
                foreach (var name in ruleNames) activityLogger.LogChange("Advanced Rule Deleted", name);
            }
            catch (COMException ex)
            {
                activityLogger.LogException($"DeleteAdvancedRules for {string.Join(",", ruleNames)}", ex);
            }
        }


        private void ManageCryptoServiceRule(bool enable)
        {
            INetFwRule2? rule = null;
            try
            {
                rule = firewallService.GetRuleByName(CryptoRuleName);
                if (enable)
                {
                    if (rule == null)
                    {
                        var newRule = (INetFwRule2)Activator.CreateInstance(Type.GetTypeFromProgID("HNetCfg.FWRule")!)!;
                        newRule.WithName(CryptoRuleName)
                               .WithDescription("Allows Windows to check for certificate revocation online. Essential for the 'auto-allow trusted' feature in Lockdown Mode.")
                               .ForService("CryptSvc")
                               .WithDirection(Directions.Outgoing)
                               .WithAction(Actions.Allow)
                               .WithProtocol(ProtocolTypes.TCP.Value)
                               .WithRemotePorts("80,443")
                               .WithGrouping(MFWConstants.MainRuleGroup)
                                .IsEnabled();
                        firewallService.CreateRule(newRule);
                        activityLogger.LogDebug("Created system rule for certificate checks.");
                    }
                    else if (!rule.Enabled)
                    {
                        rule.Enabled = true;
                        activityLogger.LogDebug("Enabled system rule for certificate checks.");
                    }
                }
                else
                {
                    if (rule != null && rule.Enabled)
                    {
                        rule.Enabled = false;
                        activityLogger.LogDebug("Disabled system rule for certificate checks.");
                    }
                }
            }
            catch (COMException ex)
            {
                activityLogger.LogException($"ManageCryptoServiceRule (enable: {enable})", ex);
            }
            finally
            {
                if (rule != null) Marshal.ReleaseComObject(rule);
            }
        }

        private void ManageDhcpClientRule(bool enable)
        {
            INetFwRule2? rule = null;
            try
            {
                rule = firewallService.GetRuleByName(DhcpRuleName);
                if (enable)
                {
                    if (rule == null)
                    {
                        var newRule = (INetFwRule2)Activator.CreateInstance(Type.GetTypeFromProgID("HNetCfg.FWRule")!)!;
                        newRule.WithName(DhcpRuleName)
                               .WithDescription("Allows the DHCP Client (Dhcp) service to get an IP address from your router. Essential for network connectivity in Lockdown Mode.")
                               .ForService("Dhcp")
                               .WithDirection(Directions.Outgoing)
                               .WithAction(Actions.Allow)
                               .WithProtocol(ProtocolTypes.UDP.Value)
                               .WithLocalPorts("68")
                               .WithRemotePorts("67")
                               .WithGrouping(MFWConstants.MainRuleGroup)
                               .IsEnabled();
                        firewallService.CreateRule(newRule);
                        activityLogger.LogDebug("Created system rule for DHCP Client.");
                    }
                    else if (!rule.Enabled)
                    {
                        rule.Enabled = true;
                        activityLogger.LogDebug("Enabled system rule for DHCP Client.");
                    }
                }
                else
                {
                    if (rule != null)
                    {
                        firewallService.DeleteRulesByName(new List<string> { DhcpRuleName });
                        activityLogger.LogDebug("Disabled/Deleted system rule for DHCP Client.");
                    }
                }
            }
            catch (COMException ex)
            {
                activityLogger.LogException($"ManageDhcpClientRule (enable: {enable})", ex);
            }
            finally
            {
                if (rule != null) Marshal.ReleaseComObject(rule);
            }
        }

        public void ToggleLockdown()
        {
            var isCurrentlyLocked = firewallService.GetDefaultOutboundAction() == NET_FW_ACTION_.NET_FW_ACTION_BLOCK;
            bool newLockdownState = !isCurrentlyLocked;
            activityLogger.LogDebug($"Toggling Lockdown. Current state: {(isCurrentlyLocked ? "Locked" : "Unlocked")}. New state: {(newLockdownState ? "Locked" : "Unlocked")}.");
            try
            {
                AdminTaskService.SetAuditPolicy(newLockdownState);
            }
            catch (System.ComponentModel.Win32Exception ex)
            {
                activityLogger.LogException("SetAuditPolicy", ex);
            }

            ManageCryptoServiceRule(newLockdownState);
            ManageDhcpClientRule(newLockdownState);

            if (newLockdownState && !AdminTaskService.IsAuditPolicyEnabled())
            {
                MessageBox.Show(
                    "Failed to verify that Windows Security Auditing was enabled.\n\n" +
                     "The Lockdown dashboard will not be able to detect blocked connections.\n\n" +
                    "Potential Causes:\n" +
                    "1. A local or domain Group Policy is preventing this change.\n" +
                    "2. Other security software is blocking this action.\n\n" +
                    "The firewall's default policy will be set back to 'Allow' for safety.",
                     "Lockdown Mode Failed", MessageBoxButtons.OK, MessageBoxIcon.Error);
                try
                {
                    firewallService.SetDefaultOutboundAction(NET_FW_ACTION_.NET_FW_ACTION_ALLOW);
                }
                catch (COMException ex)
                {
                    activityLogger.LogException("SetDefaultOutboundAction(Allow) after audit failure", ex);
                }
                activityLogger.LogDebug("Lockdown Mode Failed: Could not enable audit policy.");
                return;
            }

            try
            {
                firewallService.SetDefaultOutboundAction(
                    newLockdownState ? NET_FW_ACTION_.NET_FW_ACTION_BLOCK : NET_FW_ACTION_.NET_FW_ACTION_ALLOW);
            }
            catch (COMException ex)
            {
                activityLogger.LogException("SetDefaultOutboundAction", ex);
                MessageBox.Show("Failed to change default outbound policy.\nCheck debug_log.txt for details.",
                    "Lockdown Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
                return;
            }

            if (newLockdownState)
            {
                eventListenerService.Start();
            }
            else
            {
                eventListenerService.Stop();
            }

            activityLogger.LogChange("Lockdown Mode", newLockdownState ? "Enabled" : "Disabled");
            if (!newLockdownState)
            {
                ReenableMfwRules();
                activityLogger.LogDebug("All MFW rules re-enabled upon disabling Lockdown mode.");
            }
        }


        public void ProcessPendingConnection(PendingConnectionViewModel pending, string decision, TimeSpan duration = default, bool trustPublisher = false)
        {
            activityLogger.LogDebug($"Processing Pending Connection for '{pending.AppPath}'. Decision: {decision}, Duration: {duration}, Trust Publisher: {trustPublisher}");
            TimeSpan shortSnoozeDuration = TimeSpan.FromSeconds(10);
            TimeSpan longSnoozeDuration = TimeSpan.FromMinutes(2);
            if (trustPublisher && SignatureValidationService.GetPublisherInfo(pending.AppPath, out var publisherName) && publisherName != null)
            {
                _whitelistService.Add(publisherName);
                activityLogger.LogChange("Publisher Whitelisted", $"Publisher '{publisherName}' was added to the whitelist.");
            }

            eventListenerService.ClearPendingNotification(pending.AppPath, pending.Direction);
            switch (decision)
            {
                case "Allow":
                case "Block":
                    eventListenerService.SnoozeNotificationsForApp(pending.AppPath, shortSnoozeDuration);
                    string action = (decision == "Allow" ? "Allow" : "Block") + " (" + pending.Direction + ")";
                    if (!string.IsNullOrEmpty(pending.ServiceName))
                    {
                        var serviceNames = pending.ServiceName.Split([',', ' '], StringSplitOptions.RemoveEmptyEntries);
                        foreach (var serviceName in serviceNames)
                        {
                            ApplyServiceRuleChange(serviceName, action, pending.AppPath);
                        }
                    }
                    else if (!string.IsNullOrEmpty(pending.AppPath))
                    {
                        ApplyApplicationRuleChange([pending.AppPath], action);
                    }
                    break;
                case "TemporaryAllow":
                    eventListenerService.SnoozeNotificationsForApp(pending.AppPath, shortSnoozeDuration);
                    CreateTemporaryAllowRule(pending.AppPath, pending.ServiceName, pending.Direction, duration);
                    break;

                case "Ignore":
                    eventListenerService.SnoozeNotificationsForApp(pending.AppPath, longSnoozeDuration);
                    activityLogger.LogDebug($"Ignored Connection: {pending.Direction} for {pending.AppPath}");
                    break;
            }
        }

        public void ReenableMfwRules()
        {
            var allRules = firewallService.GetAllRules();
            try
            {
                foreach (var rule in allRules)
                {
                    try
                    {
                        if (!string.IsNullOrEmpty(rule.Grouping) &&
                             (rule.Grouping.EndsWith(MFWConstants.MfwRuleSuffix) ||
                               rule.Grouping == "Minimal Firewall" ||
                               rule.Grouping == "Minimal Firewall (Wildcard)"))
                        {
                            if (!rule.Enabled)
                            {
                                rule.Enabled = true;
                            }
                        }
                    }
                    catch (COMException ex)
                    {
                        activityLogger.LogException($"Enable rule '{rule.Name}'", ex);
                    }
                }
            }
            finally
            {
                foreach (var rule in allRules)
                {
                    Marshal.ReleaseComObject(rule);
                }
            }
        }

        private void SetupRuleTimer(string ruleName, TimeSpan duration)
        {
            var timer = new System.Threading.Timer(_ =>
            {
                try
                {
                    firewallService.DeleteRulesByName([ruleName]);
                    _temporaryRuleManager.Remove(ruleName);
                    if (_temporaryRuleTimers.TryRemove(ruleName, out var t))
                    {
                        t.Dispose();
                    }
                    activityLogger.LogDebug($"Temporary rule {ruleName} expired and was removed.");
                }
                catch (COMException ex)
                {
                    activityLogger.LogException($"Deleting temporary rule {ruleName}", ex);
                }
            }, null, duration, Timeout.InfiniteTimeSpan);
            _temporaryRuleTimers[ruleName] = timer;
        }

        private void CreateTemporaryAllowRule(string appPath, string serviceName, string direction, TimeSpan duration)
        {
            if (!ParseActionString($"Allow ({direction})", out Actions parsedAction, out Directions parsedDirection)) return;
            string baseName = !string.IsNullOrEmpty(serviceName) ? serviceName.Split(',')[0].Trim() : Path.GetFileNameWithoutExtension(appPath);
            string guid = Guid.NewGuid().ToString();
            string description = "Temporarily allowed by Minimal Firewall.";
            DateTime expiry = DateTime.UtcNow.Add(duration);

            if (!string.IsNullOrEmpty(serviceName))
            {
                var protocolsToCreate = new List<int> { 6, 17 };

                foreach (var protocol in protocolsToCreate)
                {
                    string protocolSuffix = (protocol == 6) ? " - TCP" : " - UDP";
                    string actionStr = parsedAction == Actions.Allow ? "" : "Block ";

                    if (parsedDirection.HasFlag(Directions.Incoming))
                    {
                        string ruleName = $"Temp Allow - {baseName} - In - {guid}{protocolSuffix}";
                        CreateServiceRule(ruleName, serviceName, Directions.Incoming, parsedAction, protocol, appPath);
                        _temporaryRuleManager.Add(ruleName, expiry);
                        SetupRuleTimer(ruleName, duration);
                    }
                    if (parsedDirection.HasFlag(Directions.Outgoing))
                    {
                        string ruleName = $"Temp Allow - {baseName} - Out - {guid}{protocolSuffix}";
                        CreateServiceRule(ruleName, serviceName, Directions.Outgoing, parsedAction, protocol, appPath);
                        _temporaryRuleManager.Add(ruleName, expiry);
                        SetupRuleTimer(ruleName, duration);
                    }
                }
                activityLogger.LogChange("Temporary Rule Created", $"Allowed {baseName} (service) for {duration.TotalMinutes} minutes.");
            }
            else
            {
                string ruleName = $"Temp Allow - {baseName} - {direction} - {guid}";
                CreateApplicationRule(ruleName, appPath, parsedDirection, parsedAction, ProtocolTypes.Any.Value, description);

                _temporaryRuleManager.Add(ruleName, expiry);
                SetupRuleTimer(ruleName, duration);
                activityLogger.LogChange("Temporary Rule Created", $"Allowed {baseName} ({appPath}) for {duration.TotalMinutes} minutes.");
            }
        }

        public void AcceptForeignRule(FirewallRuleChange change)
        {
            if (change.Rule?.Name is not null)
            {
                foreignRuleTracker.AcknowledgeRules([change.Rule.Name]);
                activityLogger.LogChange("Foreign Rule Accepted", change.Rule.Name);
                activityLogger.LogDebug($"Sentry: Accepting foreign rule '{change.Rule.Name}'");
            }
        }

        public void DeleteForeignRule(FirewallRuleChange change)
        {
            if (change.Rule?.Name is not null)
            {
                activityLogger.LogDebug($"Sentry: Deleting foreign rule '{change.Rule.Name}'");
                DeleteAdvancedRules([change.Rule.Name]);
            }
        }

        public void SetGroupEnabledState(string groupName, bool isEnabled)
        {
            INetFwRules? comRules = null;
            var rulesInGroup = new List<INetFwRule2>();
            INetFwPolicy2? firewallPolicy = null;
            try
            {
                Type? policyType = Type.GetTypeFromProgID("HNetCfg.FwPolicy2");
                if (policyType == null) return;
                firewallPolicy = (INetFwPolicy2)Activator.CreateInstance(policyType)!;
                if (firewallPolicy == null) return;

                comRules = firewallPolicy.Rules;
                foreach (INetFwRule2 r in comRules)
                {
                    if (r != null && string.Equals(r.Grouping, groupName, StringComparison.OrdinalIgnoreCase))
                    {
                        rulesInGroup.Add(r);
                    }
                    else
                    {
                        if (r != null) Marshal.ReleaseComObject(r);
                    }
                }

                foreach (var rule in rulesInGroup)
                {
                    try
                    {
                        if (rule.Enabled != isEnabled)
                        {
                            rule.Enabled = isEnabled;
                        }
                    }
                    catch (COMException ex)
                    {
                        activityLogger.LogException($"SetGroupEnabledState for rule '{rule.Name}'", ex);
                    }
                }
                activityLogger.LogChange("Group State Changed", $"Group '{groupName}' {(isEnabled ? "Enabled" : "Disabled")}");
            }
            catch (COMException ex)
            {
                activityLogger.LogException($"SetGroupEnabledState for group '{groupName}'", ex);
            }
            finally
            {
                foreach (var rule in rulesInGroup)
                {
                    if (rule != null) Marshal.ReleaseComObject(rule);
                }
                if (comRules != null) Marshal.ReleaseComObject(comRules);
                if (firewallPolicy != null) Marshal.ReleaseComObject(firewallPolicy);
            }
        }

        public void AcceptAllForeignRules(List<FirewallRuleChange> changes)
        {
            if (changes == null || changes.Count == 0) return;
            var ruleNames = changes.Select(c => c.Rule?.Name).Where(n => n != null).Select(n => n!).ToList();
            if (ruleNames.Any())
            {
                foreignRuleTracker.AcknowledgeRules(ruleNames);
                activityLogger.LogChange("All Foreign Rules Accepted", $"{ruleNames.Count} rules accepted.");
                activityLogger.LogDebug($"Sentry: Accepted all {ruleNames.Count} foreign rules.");
            }
        }

        public void CreateAdvancedRule(AdvancedRuleViewModel vm, string interfaceTypes, string icmpTypesAndCodes)
        {
            if (!string.IsNullOrWhiteSpace(vm.ApplicationName))
            {
                vm.ApplicationName = PathResolver.NormalizePath(vm.ApplicationName);
                if (!File.Exists(vm.ApplicationName))
                {
                    activityLogger.LogDebug($"[Validation] Aborted creating advanced rule due to non-existent path: {vm.ApplicationName}");
                    return;
                }
            }

            if (vm.Status == "Allow" && !string.IsNullOrWhiteSpace(vm.ApplicationName))
            {
                FindAndQueueDeleteForGeneralBlockRule(vm.ApplicationName);
            }

            bool hasProgramOrService = !string.IsNullOrWhiteSpace(vm.ApplicationName) || !string.IsNullOrWhiteSpace(vm.ServiceName);
            bool isProtocolTcpUdpOrAny = vm.Protocol == ProtocolTypes.TCP.Value ||
                                     vm.Protocol == ProtocolTypes.UDP.Value ||
                                     vm.Protocol == ProtocolTypes.Any.Value;
            if (hasProgramOrService && !isProtocolTcpUdpOrAny)
            {
                MessageBox.Show(
                     "When specifying a program or service, the protocol must be TCP, UDP, or Any.",
                    "Invalid Rule", MessageBoxButtons.OK, MessageBoxIcon.Error);
                return;
            }

            var directionsToCreate = new List<Directions>(2);
            if (vm.Direction.HasFlag(Directions.Incoming)) directionsToCreate.Add(Directions.Incoming);
            if (vm.Direction.HasFlag(Directions.Outgoing)) directionsToCreate.Add(Directions.Outgoing);

            var protocolsToCreate = new List<int>();
            if (hasProgramOrService && vm.Protocol == ProtocolTypes.Any.Value)
            {
                protocolsToCreate.Add(ProtocolTypes.TCP.Value);
                protocolsToCreate.Add(ProtocolTypes.UDP.Value);
            }
            else
            {
                protocolsToCreate.Add(vm.Protocol);
            }

            foreach (var direction in directionsToCreate)
            {
                foreach (var protocol in protocolsToCreate)
                {
                    var ruleVm = new AdvancedRuleViewModel
                    {
                        Name = vm.Name,
                        Status = vm.Status,
                        IsEnabled = vm.IsEnabled,
                        Description = vm.Description,
                        Grouping = vm.Grouping,
                        ApplicationName = vm.ApplicationName,
                        ServiceName = vm.ServiceName,
                        LocalPorts = vm.LocalPorts,
                        RemotePorts = vm.RemotePorts,
                        LocalAddresses = vm.LocalAddresses,
                        RemoteAddresses = vm.RemoteAddresses,
                        Profiles = vm.Profiles,
                        Type = vm.Type,
                        Direction = direction,
                        Protocol = (short)protocol
                    };
                    string nameSuffix = "";
                    if (directionsToCreate.Count > 1)
                    {
                        nameSuffix += $" - {direction}";
                    }
                    if (protocolsToCreate.Count > 1)
                    {
                        nameSuffix += (protocol == ProtocolTypes.TCP.Value) ?
                            " - TCP" : " - UDP";
                    }
                    ruleVm.Name = vm.Name + nameSuffix;
                    CreateSingleAdvancedRule(ruleVm, interfaceTypes, icmpTypesAndCodes);
                }
            }
        }

        private void CreateSingleAdvancedRule(AdvancedRuleViewModel vm, string interfaceTypes, string icmpTypesAndCodes)
        {
            var firewallRule = (INetFwRule2)Activator.CreateInstance(Type.GetTypeFromProgID("HNetCfg.FWRule")!)!;
            try
            {
                firewallRule.Name = vm.Name;
                firewallRule.Description = vm.Description;
                firewallRule.Enabled = vm.IsEnabled;
                firewallRule.Grouping = vm.Grouping;
                firewallRule.Action = vm.Status == "Allow" ?
                    NET_FW_ACTION_.NET_FW_ACTION_ALLOW : NET_FW_ACTION_.NET_FW_ACTION_BLOCK;
                firewallRule.Direction = (NET_FW_RULE_DIRECTION_)vm.Direction;
                firewallRule.Protocol = vm.Protocol;

                if (!string.IsNullOrWhiteSpace(vm.ServiceName))
                {
                    firewallRule.serviceName = vm.ServiceName;
                }

                if (!string.IsNullOrWhiteSpace(vm.ApplicationName))
                {
                    firewallRule.ApplicationName = vm.ApplicationName;
                }
                else
                {
                    firewallRule.ApplicationName = null;
                }

                if (vm.Protocol != ProtocolTypes.TCP.Value && vm.Protocol != ProtocolTypes.UDP.Value)
                {
                    firewallRule.LocalPorts = "*";
                    firewallRule.RemotePorts = "*";
                }
                else
                {
                    firewallRule.LocalPorts = !string.IsNullOrEmpty(vm.LocalPorts) ?
                        vm.LocalPorts : "*";
                    firewallRule.RemotePorts = !string.IsNullOrEmpty(vm.RemotePorts) ? vm.RemotePorts : "*";
                }

                firewallRule.LocalAddresses = !string.IsNullOrEmpty(vm.LocalAddresses) ? vm.LocalAddresses : "*";
                firewallRule.RemoteAddresses = !string.IsNullOrEmpty(vm.RemoteAddresses) ? vm.RemoteAddresses : "*";

                NET_FW_PROFILE_TYPE2_ profiles = 0;
                if (vm.Profiles.Contains("Domain")) profiles |= NET_FW_PROFILE_TYPE2_.NET_FW_PROFILE2_DOMAIN;
                if (vm.Profiles.Contains("Private")) profiles |= NET_FW_PROFILE_TYPE2_.NET_FW_PROFILE2_PRIVATE;
                if (vm.Profiles.Contains("Public")) profiles |= NET_FW_PROFILE_TYPE2_.NET_FW_PROFILE2_PUBLIC;
                if (profiles == 0) profiles = NET_FW_PROFILE_TYPE2_.NET_FW_PROFILE2_ALL;
                firewallRule.Profiles = (int)profiles;
                firewallRule.InterfaceTypes = interfaceTypes;
                if (vm.Protocol == ProtocolTypes.ICMPv4.Value || vm.Protocol == ProtocolTypes.ICMPv6.Value)
                {
                    if (!string.IsNullOrWhiteSpace(icmpTypesAndCodes))
                    {
                        firewallRule.IcmpTypesAndCodes = icmpTypesAndCodes;
                    }
                }

                firewallService.CreateRule(firewallRule);
                activityLogger.LogChange("Advanced Rule Created", vm.Name);
                activityLogger.LogDebug($"Created Advanced Rule: '{vm.Name}'");
            }
            finally
            {
                if (firewallRule != null) Marshal.ReleaseComObject(firewallRule);
            }
        }

        public static bool ParseActionString(string action, out Actions parsedAction, out Directions parsedDirection)
        {
            parsedAction = Actions.Allow;
            parsedDirection = 0;
            if (string.IsNullOrEmpty(action)) return false;

            parsedAction = action.StartsWith("Allow", StringComparison.OrdinalIgnoreCase) ? Actions.Allow : Actions.Block;
            if (action.Contains("(All)"))
            {
                parsedDirection = Directions.Incoming |
                    Directions.Outgoing;
            }
            else
            {
                if (action.Contains("Inbound") || action.Contains("Incoming"))
                {
                    parsedDirection |= Directions.Incoming;
                }
                if (action.Contains("Outbound") || action.Contains("Outgoing"))
                {
                    parsedDirection |= Directions.Outgoing;
                }
            }

            if (parsedDirection == 0)
            {
                parsedDirection = Directions.Outgoing;
            }

            return true;
        }

        private static void ApplyRuleAction(string appName, string action, Action<string, Directions, Actions> createRule)
        {
            if (!ParseActionString(action, out Actions parsedAction, out Directions parsedDirection))
            {
                return;
            }

            string actionStr = parsedAction == Actions.Allow ?
                "" : "Block ";
            string inName = $"{appName} - {actionStr}In";
            string outName = $"{appName} - {actionStr}Out";
            if (parsedDirection.HasFlag(Directions.Incoming))
            {
                createRule(inName, Directions.Incoming, parsedAction);
            }
            if (parsedDirection.HasFlag(Directions.Outgoing))
            {
                createRule(outName, Directions.Outgoing, parsedAction);
            }
        }

        private static INetFwRule2 CreateRuleObject(string name, string appPath, Directions direction, Actions action, int protocol, string description = "")
        {
            var firewallRule = (INetFwRule2)Activator.CreateInstance(Type.GetTypeFromProgID("HNetCfg.FWRule")!)!;
            firewallRule.Name = name;
            firewallRule.ApplicationName = appPath;
            firewallRule.Direction = (NET_FW_RULE_DIRECTION_)direction;
            firewallRule.Action = (NET_FW_ACTION_)action;
            firewallRule.Enabled = true;
            firewallRule.Protocol = protocol;
            if (!string.IsNullOrEmpty(description) && description.StartsWith(MFWConstants.WildcardDescriptionPrefix))
            {
                firewallRule.Grouping = MFWConstants.WildcardRuleGroup;
                firewallRule.Description = description;
            }
            else
            {
                firewallRule.Grouping = MFWConstants.MainRuleGroup;
            }
            return firewallRule;
        }

        private void CreateApplicationRule(string name, string appPath, Directions direction, Actions action, int protocol, string description)
        {
            activityLogger.LogDebug($"Creating Application Rule: '{name}' for '{appPath}'");
            var firewallRule = CreateRuleObject(name, appPath, direction, action, protocol, description);
            firewallService.CreateRule(firewallRule);
        }

        private void CreateServiceRule(string name, string serviceName, Directions direction, Actions action, int protocol, string? appPath = null)
        {
            activityLogger.LogDebug($"Creating Service Rule: '{name}' for service '{serviceName}' with AppPath: '{appPath ?? "null"}'");
            var firewallRule = (INetFwRule2)Activator.CreateInstance(Type.GetTypeFromProgID("HNetCfg.FWRule")!)!;
            try
            {
                firewallRule.Name = name;
                firewallRule.serviceName = serviceName;
                firewallRule.ApplicationName = string.IsNullOrEmpty(appPath) ? null : appPath;
                firewallRule.Direction = (NET_FW_RULE_DIRECTION_)direction;
                firewallRule.Action = (NET_FW_ACTION_)action;
                firewallRule.Protocol = protocol;
                firewallRule.Grouping = MFWConstants.MainRuleGroup;
                firewallRule.Enabled = true;
                firewallService.CreateRule(firewallRule);
            }
            finally
            {
                if (firewallRule != null) Marshal.ReleaseComObject(firewallRule);
            }
        }

        private void CreateUwpRule(string name, string packageFamilyName, Directions direction, Actions action, int protocol)
        {
            activityLogger.LogDebug($"Creating UWP Rule: '{name}' for PFN '{packageFamilyName}'");
            var firewallRule = (INetFwRule2)Activator.CreateInstance(Type.GetTypeFromProgID("HNetCfg.FWRule")!)!;
            try
            {
                firewallRule.Name = name;
                firewallRule.Description = MFWConstants.UwpDescriptionPrefix + packageFamilyName;
                firewallRule.Direction = (NET_FW_RULE_DIRECTION_)direction;
                firewallRule.Action = (NET_FW_ACTION_)action;
                firewallRule.Protocol = protocol;
                firewallRule.Grouping = MFWConstants.MainRuleGroup;
                firewallRule.Enabled = true;
                firewallService.CreateRule(firewallRule);
            }
            finally
            {
                if (firewallRule != null) Marshal.ReleaseComObject(firewallRule);
            }
        }

        public async Task DeleteGroupAsync(string groupName)
        {
            await Task.Run(() =>
            {
                try
                {
                    activityLogger.LogDebug($"Deleting all rules in group: {groupName}");
                    firewallService.DeleteRulesByGroup(groupName);
                }
                catch (COMException ex)
                {
                    activityLogger.LogException($"DeleteGroupAsync for {groupName}", ex);
                }
            });
        }

        public void DeleteAllMfwRules()
        {
            try
            {
                firewallService.DeleteAllMfwRules();
                _wildcardRuleService.ClearRules();
                activityLogger.LogChange("Bulk Delete", "All Minimal Firewall rules deleted by user.");
            }
            catch (COMException ex)
            {
                activityLogger.LogException("DeleteAllMfwRules", ex);
            }
        }

        public void UpdateWildcardRule(WildcardRule oldRule, WildcardRule newRule)
        {
            _wildcardRuleService.UpdateRule(oldRule, newRule);
            DeleteRulesForWildcard(oldRule);
            activityLogger.LogChange("Wildcard Rule Updated", newRule.FolderPath);
        }

        public void RemoveWildcardRule(WildcardRule rule)
        {
            _wildcardRuleService.RemoveRule(rule);
            DeleteRulesForWildcard(rule);
            activityLogger.LogChange("Wildcard Rule Removed", rule.FolderPath);
        }

        public void RemoveWildcardDefinitionOnly(WildcardRule rule)
        {
            _wildcardRuleService.RemoveRule(rule);
            activityLogger.LogChange("Wildcard Definition Removed", rule.FolderPath);
        }

        public void ApplyWildcardMatch(string appPath, string serviceName, WildcardRule rule)
        {
            if (!ParseActionString(rule.Action, out Actions parsedAction, out Directions parsedDirection))
            {
                activityLogger.LogDebug($"[ApplyWildcardMatch] Invalid action string in wildcard rule for {rule.FolderPath}: {rule.Action}");
                return;
            }

            void createRule(string baseName, Directions dir, Actions act, int protocol, string? serviceNameToUse)
            {
                if (!ValidationUtility.ValidatePortString(rule.LocalPorts, out string localPortError))
                {
                    activityLogger.LogDebug($"[ApplyWildcardMatch] Invalid LocalPorts '{rule.LocalPorts}' in wildcard for {rule.FolderPath}. Rule '{baseName}' not created. Error: {localPortError}");
                    return;
                }
                if (!ValidationUtility.ValidatePortString(rule.RemotePorts, out string remotePortError))
                {
                    activityLogger.LogDebug($"[ApplyWildcardMatch] Invalid RemotePorts '{rule.RemotePorts}' in wildcard for {rule.FolderPath}. Rule '{baseName}' not created. Error: {remotePortError}");
                    return;
                }
                if (!ValidationUtility.ValidateAddressString(rule.RemoteAddresses, out string remoteAddressError))
                {
                    activityLogger.LogDebug($"[ApplyWildcardMatch] Invalid RemoteAddresses '{rule.RemoteAddresses}' in wildcard for {rule.FolderPath}. Rule '{baseName}' not created. Error: {remoteAddressError}");
                    return;
                }

                var firewallRule = (INetFwRule2)Activator.CreateInstance(Type.GetTypeFromProgID("HNetCfg.FWRule")!)!;
                string? valueWithError = null;
                bool ruleCreationSkipped = false;
                try
                {
                    firewallRule.Name = baseName;

                    if (!string.IsNullOrEmpty(serviceNameToUse))
                    {
                        firewallRule.serviceName = serviceNameToUse;
                        firewallRule.ApplicationName = appPath;
                    }
                    else
                    {
                        firewallRule.ApplicationName = appPath;
                        firewallRule.serviceName = null;
                    }

                    firewallRule.Direction = (NET_FW_RULE_DIRECTION_)dir;
                    firewallRule.Action = (NET_FW_ACTION_)act;
                    firewallRule.Enabled = true;
                    firewallRule.Grouping = MFWConstants.WildcardRuleGroup;
                    firewallRule.Description = $"{MFWConstants.WildcardDescriptionPrefix}{rule.FolderPath}]";
                    firewallRule.Protocol = protocol;

                    try
                    {
                        valueWithError = rule.LocalPorts;
                        if (protocol != 6 && protocol != 17) valueWithError = "*";
                        else if (string.IsNullOrEmpty(valueWithError)) valueWithError = "*";
                        activityLogger.LogDebug($"[ApplyWildcardMatch] Setting LocalPorts to: '{valueWithError}' for rule '{baseName}'");
                        firewallRule.LocalPorts = valueWithError;
                    }
                    catch (ArgumentException portEx)
                    {
                        activityLogger.LogException($"ApplyWildcardMatch-SetLocalPorts-{baseName}", portEx);
                        activityLogger.LogDebug($"[ApplyWildcardMatch] Falling back setting LocalPorts to '*' for rule '{baseName}' due to error: {portEx.Message}");
                        try { firewallRule.LocalPorts = "*"; }
                        catch (Exception fbEx)
                        {
                            activityLogger.LogException($"ApplyWildcardMatch-FallbackLocalPorts-{baseName}", fbEx);
                            ruleCreationSkipped = true;
                        }
                    }

                    if (ruleCreationSkipped) return;

                    try
                    {
                        valueWithError = rule.RemotePorts;
                        if (protocol != 6 && protocol != 17) valueWithError = "*";
                        else if (string.IsNullOrEmpty(valueWithError)) valueWithError = "*";
                        activityLogger.LogDebug($"[ApplyWildcardMatch] Setting RemotePorts to: '{valueWithError}' for rule '{baseName}'");
                        firewallRule.RemotePorts = valueWithError;
                    }
                    catch (ArgumentException portEx)
                    {
                        activityLogger.LogException($"ApplyWildcardMatch-SetRemotePorts-{baseName}", portEx);
                        activityLogger.LogDebug($"[ApplyWildcardMatch] Falling back setting RemotePorts to '*' for rule '{baseName}' due to error: {portEx.Message}");
                        try { firewallRule.RemotePorts = "*"; }
                        catch (Exception fbEx)
                        {
                            activityLogger.LogException($"ApplyWildcardMatch-FallbackRemotePorts-{baseName}", fbEx);
                            ruleCreationSkipped = true;
                        }
                    }

                    if (ruleCreationSkipped) return;

                    try
                    {
                        valueWithError = rule.RemoteAddresses;
                        activityLogger.LogDebug($"[ApplyWildcardMatch] Setting RemoteAddresses to: '{valueWithError}' for rule '{baseName}'");
                        firewallRule.RemoteAddresses = valueWithError;
                    }
                    catch (ArgumentException addrEx)
                    {
                        activityLogger.LogException($"ApplyWildcardMatch-SetRemoteAddr-{baseName}", addrEx);
                        activityLogger.LogDebug($"[ApplyWildcardMatch] Falling back setting RemoteAddresses to '*' for rule '{baseName}' due to error: {addrEx.Message}");
                        try { firewallRule.RemoteAddresses = "*"; }
                        catch (Exception fbEx)
                        {
                            activityLogger.LogException($"ApplyWildcardMatch-FallbackRemoteAddr-{baseName}", fbEx);
                            ruleCreationSkipped = true;
                        }
                    }

                    if (ruleCreationSkipped) return;

                    firewallService.CreateRule(firewallRule);
                    activityLogger.LogDebug($"[ApplyWildcardMatch] Successfully created rule '{baseName}' from wildcard match.");
                }
                catch (COMException comEx)
                {
                    activityLogger.LogException($"ApplyWildcardMatch-CreateRuleCOM-{baseName}", comEx);
                }
                catch (Exception ex)
                {
                    activityLogger.LogException($"ApplyWildcardMatch-CreateRuleGeneral-{baseName}", ex);
                }
                finally
                {
                    if (firewallRule != null) Marshal.ReleaseComObject(firewallRule);
                }
            }

            var serviceNames = serviceName.Split([',', ' '], StringSplitOptions.RemoveEmptyEntries);
            bool isSvcHost = Path.GetFileName(appPath).Equals("svchost.exe", StringComparison.OrdinalIgnoreCase);
            string appNameBase = Path.GetFileNameWithoutExtension(appPath);

            List<string?> servicesToCreateRulesFor;

            if (serviceNames.Length > 0)
            {
                servicesToCreateRulesFor = new List<string?>(serviceNames);
            }
            else if (isSvcHost)
            {
                servicesToCreateRulesFor = ["*"];
            }
            else
            {
                servicesToCreateRulesFor = [null]; 
            }

            foreach (var sName in servicesToCreateRulesFor)
            {
                string ruleNameBase = string.IsNullOrEmpty(sName) ? appNameBase : (sName == "*" ? appNameBase : sName);

                if (rule.Protocol == ProtocolTypes.Any.Value)
                {
                    string actionStr = parsedAction == Actions.Allow ? "" : "Block ";
                    var protocolsToCreate = new List<int> { 6, 17 };

                    foreach (var protocol in protocolsToCreate)
                    {
                        string protocolSuffix = (protocol == 6) ? " - TCP" : " - UDP";
                        if (parsedDirection.HasFlag(Directions.Incoming))
                        {
                            createRule($"{ruleNameBase} - {actionStr}In{protocolSuffix}", Directions.Incoming, parsedAction, protocol, sName);
                        }
                        if (parsedDirection.HasFlag(Directions.Outgoing))
                        {
                            createRule($"{ruleNameBase} - {actionStr}Out{protocolSuffix}", Directions.Outgoing, parsedAction, protocol, sName);
                        }
                    }
                }
                else
                {
                    ApplyRuleAction(ruleNameBase, rule.Action, (name, dir, act) => createRule(name, dir, act, rule.Protocol, sName));
                }
            }

            activityLogger.LogChange("Wildcard Rule Applied", rule.Action + " for " + appPath);
        }


        public async Task<List<string>> CleanUpOrphanedRulesAsync(CancellationToken token, IProgress<int>? progress = null)
        {
            var orphanedRuleNames = new List<string>();
            var mfwRules = new List<INetFwRule2>();
            var allRules = firewallService.GetAllRules();

            try
            {
                foreach (var rule in allRules)
                {
                    if (IsMfwRule(rule))
                    {
                        mfwRules.Add(rule);
                    }
                    else
                    {
                        if (rule != null) Marshal.ReleaseComObject(rule);
                    }
                }

                int total = mfwRules.Count;
                if (total == 0)
                {
                    progress?.Report(100);
                    return orphanedRuleNames;
                }

                int processed = 0;
                await Task.Run(() =>
                {
                    foreach (var rule in mfwRules)
                    {
                        if (token.IsCancellationRequested)
                        {
                            break;
                        }

                        string appPath = rule.ApplicationName;

                        if (!string.IsNullOrEmpty(appPath) && appPath != "*" && !appPath.StartsWith("@"))
                        {
                            string expandedPath = Environment.ExpandEnvironmentVariables(appPath);
                            if (!File.Exists(expandedPath))
                            {
                                orphanedRuleNames.Add(rule.Name);
                                activityLogger.LogDebug($"Found orphaned rule '{rule.Name}' for path: {expandedPath}");
                            }
                        }

                        processed++;
                        progress?.Report((processed * 100) / total);
                    }
                }, token);

                if (token.IsCancellationRequested)
                {
                    return new List<string>();
                }

                if (orphanedRuleNames.Any())
                {
                    activityLogger.LogDebug($"Deleting {orphanedRuleNames.Count} orphaned rules.");
                    try
                    {
                        firewallService.DeleteRulesByName(orphanedRuleNames);
                        activityLogger.LogChange("Orphaned Rules Cleaned", $"{orphanedRuleNames.Count} rules deleted.");
                    }
                    catch (COMException ex)
                    {
                        activityLogger.LogException("CleanUpOrphanedRulesAsync (Deletion)", ex);
                    }
                }
                else
                {
                    activityLogger.LogDebug("No orphaned rules found.");
                }
            }
            finally
            {
                foreach (var rule in mfwRules)
                {
                    if (rule != null) Marshal.ReleaseComObject(rule);
                }
            }

            return orphanedRuleNames;
        }

        public async Task<string> ExportAllMfwRulesAsync()
        {
            var advancedRules = await _dataService.GetAggregatedRulesAsync(CancellationToken.None);
            var portableAdvancedRules = advancedRules.SelectMany(ar => ar.UnderlyingRules)
                .Select(r =>
                {
                    r.ApplicationName = PathResolver.ConvertToEnvironmentPath(r.ApplicationName);
                    return r;
                }).ToList();

            var wildcardRules = _wildcardRuleService.GetRules()
                .Select(r =>
                {
                    r.FolderPath = PathResolver.ConvertToEnvironmentPath(r.FolderPath);
                    return r;
                }).ToList();

            var container = new ExportContainer
            {
                ExportDate = DateTime.UtcNow,
                AdvancedRules = portableAdvancedRules,
                WildcardRules = wildcardRules
            };

            return JsonSerializer.Serialize(container, ExportContainerJsonContext.Default.ExportContainer);
        }

        public async Task ImportRulesAsync(string jsonContent, bool replace)
        {
            if (BackgroundTaskService == null)
            {
                activityLogger.LogDebug("[Import] BackgroundTaskService is not available.");
                return;
            }

            try
            {
                var container = JsonSerializer.Deserialize(jsonContent, ExportContainerJsonContext.Default.ExportContainer);
                if (container == null)
                {
                    activityLogger.LogDebug("[Import] Failed to deserialize JSON content.");
                    return;
                }

                if (replace)
                {
                    BackgroundTaskService.EnqueueTask(new FirewallTask(FirewallTaskType.DeleteAllMfwRules, new object()));
                    await Task.Delay(1000);
                }

                foreach (var ruleVm in container.AdvancedRules)
                {
                    ruleVm.ApplicationName = PathResolver.ConvertFromEnvironmentPath(ruleVm.ApplicationName);
                    var payload = new CreateAdvancedRulePayload { ViewModel = ruleVm, InterfaceTypes = ruleVm.InterfaceTypes, IcmpTypesAndCodes = ruleVm.IcmpTypesAndCodes };
                    BackgroundTaskService.EnqueueTask(new FirewallTask(FirewallTaskType.CreateAdvancedRule, payload));
                }

                foreach (var wildcardRule in container.WildcardRules)
                {
                    wildcardRule.FolderPath = PathResolver.ConvertFromEnvironmentPath(wildcardRule.FolderPath);
                    BackgroundTaskService.EnqueueTask(new FirewallTask(FirewallTaskType.AddWildcardRule, wildcardRule));
                }

                activityLogger.LogChange("Rules Imported", $"Imported {container.AdvancedRules.Count} advanced rules and {container.WildcardRules.Count} wildcard rules. Replace: {replace}");
            }
            catch (JsonException ex)
            {
                activityLogger.LogException("ImportRules", ex);
            }
        }
    }
}


--------------------------------------------------
// Full Path: C:/Users/anon/PROGRAMMING/C#/SimpleFirewall/VS Minimal Firewall/MinimalFirewall-NET8/Backups/v2.5.5 - ws/2.5.5.6 - security vulnerability fix 3/FirewallDataService.cs
--------------------------------------------------------------------------------
using NetFwTypeLib;
using System.IO;
using System.Linq;
using MinimalFirewall.TypedObjects;
using System.Collections.Generic;
using Microsoft.Extensions.Caching.Memory;
using System.Runtime.InteropServices;
using System.Threading;
using System.Threading.Tasks;
using System.Diagnostics;

namespace MinimalFirewall
{
    public enum MfwRuleStatus { None, MfwAllow, MfwBlock }

    public class FirewallDataService
    {
        private readonly FirewallRuleService _firewallRuleService;
        private readonly WildcardRuleService _wildcardRuleService;
        private readonly UwpService _uwpService;
        private readonly MemoryCache _localCache;
        private const string ServicesCacheKey = "ServicesList";
        private const string MfwRulesCacheKey = "MfwRulesList";
        private const string AggregatedRulesCacheKey = "AggregatedRulesList";

        public FirewallDataService(FirewallRuleService firewallRuleService, WildcardRuleService wildcardRuleService, UwpService uwpService)
        {
            _firewallRuleService = firewallRuleService;
            _wildcardRuleService = wildcardRuleService;
            _uwpService = uwpService;
            _localCache = new MemoryCache(new MemoryCacheOptions());
        }

        public void ClearAggregatedRulesCache()
        {
            _localCache.Remove(AggregatedRulesCacheKey);
        }

        public void InvalidateRuleCache()
        {
            _localCache.Remove(MfwRulesCacheKey);
            _localCache.Remove(AggregatedRulesCacheKey);
        }

        public List<ServiceViewModel> GetCachedServicesWithExePaths()
        {
            if (_localCache.TryGetValue(ServicesCacheKey, out List<ServiceViewModel>? services) && services != null)
            {
                return services;
            }

            services = SystemDiscoveryService.GetServicesWithExePaths();
            var cacheOptions = new MemoryCacheEntryOptions()
                .SetSlidingExpiration(TimeSpan.FromMinutes(10));
            _localCache.Set(ServicesCacheKey, services, cacheOptions);
            return services;
        }

        public List<UwpApp> LoadUwpAppsFromCache()
        {
            return _uwpService.LoadUwpAppsFromCache();
        }

        private Task<List<AdvancedRuleViewModel>> FetchAllMfwRulesAsync(CancellationToken token)
        {
            return Task.Run(() =>
            {
                var allRules = _firewallRuleService.GetAllRules();
                try
                {
                    var mfwRules = allRules
                        .Where(rule =>
                            !string.IsNullOrEmpty(rule.Grouping) &&
                            (rule.Grouping == MFWConstants.MainRuleGroup || rule.Grouping == MFWConstants.WildcardRuleGroup || rule.Grouping.EndsWith(MFWConstants.MfwRuleSuffix))
                        )
                        .Select(CreateAdvancedRuleViewModel)
                        .ToList();

                    if (token.IsCancellationRequested)
                    {
                        return new List<AdvancedRuleViewModel>();
                    }
                    return mfwRules;
                }
                finally
                {
                    foreach (var rule in allRules)
                    {
                        if (rule != null) Marshal.ReleaseComObject(rule);
                    }
                }
            }, token);
        }

        public Task<List<AdvancedRuleViewModel>> GetMfwRulesAsync(CancellationToken token)
        {
            return _localCache.GetOrCreateAsync(MfwRulesCacheKey, async entry =>
            {
                entry.SlidingExpiration = TimeSpan.FromMinutes(10);
                return await FetchAllMfwRulesAsync(token);
            }) ?? Task.FromResult(new List<AdvancedRuleViewModel>());
        }

        public async Task<List<AggregatedRuleViewModel>> GetAggregatedRulesAsync(CancellationToken token, IProgress<int>? progress = null)
        {
            if (_localCache.TryGetValue(AggregatedRulesCacheKey, out List<AggregatedRuleViewModel>? cachedRules) && cachedRules != null)
            {
                progress?.Report(100);
                return cachedRules;
            }

            var allMfwRules = await GetMfwRulesAsync(token);
            if (token.IsCancellationRequested) return new List<AggregatedRuleViewModel>();

            var aggregatedRules = await Task.Run(() =>
            {
                try
                {
                    int totalRules = allMfwRules.Count;
                    if (totalRules == 0)
                    {
                        progress?.Report(100);
                        return new List<AggregatedRuleViewModel>();
                    }

                    var groupedByGroupingAndProtocol = allMfwRules
                        .Where(r => r.IsEnabled)
                        .GroupBy(r => $"{r.Grouping}|{r.ApplicationName}|{r.ServiceName}|{r.Protocol}")
                        .ToList();

                    var aggRules = new List<AggregatedRuleViewModel>();
                    int processedCount = 0;

                    foreach (var group in groupedByGroupingAndProtocol)
                    {
                        if (token.IsCancellationRequested) return new List<AggregatedRuleViewModel>();
                        var groupList = group.ToList();
                        aggRules.Add(CreateAggregatedViewModelForRuleGroup(groupList));
                        processedCount += groupList.Count;
                        progress?.Report((processedCount * 100) / totalRules);
                    }

                    progress?.Report(100);
                    return aggRules.OrderBy(r => r.Name).ToList();
                }
                finally
                {

                }
            }, token);

            if (token.IsCancellationRequested) return new List<AggregatedRuleViewModel>();

            var cacheEntryOptions = new MemoryCacheEntryOptions().SetSlidingExpiration(TimeSpan.FromMinutes(5));
            _localCache.Set(AggregatedRulesCacheKey, aggregatedRules, cacheEntryOptions);

            return aggregatedRules;
        }

        private AggregatedRuleViewModel CreateAggregatedViewModelForRuleGroup(List<AdvancedRuleViewModel> group)
        {
            var firstRule = group.First();

            var commonName = GetCommonName(group);
            if (string.IsNullOrEmpty(commonName) || commonName.StartsWith("@"))
            {
                commonName = firstRule.Grouping ?? string.Empty;
            }

            var aggRule = new AggregatedRuleViewModel
            {
                Name = commonName,
                ApplicationName = firstRule.ApplicationName ?? string.Empty,
                ServiceName = firstRule.ServiceName ?? string.Empty,
                Protocol = firstRule.Protocol,
                ProtocolName = GetProtocolName(firstRule.Protocol),
                Type = DetermineRuleType(firstRule),
                UnderlyingRules = group.Select(r => r).ToList(),
                IsEnabled = group.All(r => r.IsEnabled),
                Profiles = firstRule.Profiles,
                Grouping = firstRule.Grouping ?? "",
                Description = firstRule.Description ?? ""
            };

            bool hasInAllow = group.Any(r => r.Status == "Allow" && r.Direction.HasFlag(Directions.Incoming));
            bool hasOutAllow = group.Any(r => r.Status == "Allow" && r.Direction.HasFlag(Directions.Outgoing));
            bool hasInBlock = group.Any(r => r.Status == "Block" && r.Direction.HasFlag(Directions.Incoming));
            bool hasOutBlock = group.Any(r => r.Status == "Block" && r.Direction.HasFlag(Directions.Outgoing));

            aggRule.InboundStatus = hasInAllow ? "Allow" : (hasInBlock ? "Block" : "N/A");
            if (hasInAllow && hasInBlock) aggRule.InboundStatus = "Allow, Block";

            aggRule.OutboundStatus = hasOutAllow ? "Allow" : (hasOutBlock ? "Block" : "N/A");
            if (hasOutAllow && hasOutBlock) aggRule.OutboundStatus = "Allow, Block";

            var localPorts = group.Select(r => r.LocalPorts).Where(p => !string.IsNullOrEmpty(p) && p != "*").Distinct().ToList();
            aggRule.LocalPorts = localPorts.Any() ? string.Join(", ", localPorts) : "*";
            var remotePorts = group.Select(r => r.RemotePorts).Where(p => !string.IsNullOrEmpty(p) && p != "*").Distinct().ToList();
            aggRule.RemotePorts = remotePorts.Any() ? string.Join(", ", remotePorts) : "*";

            var localAddresses = group.Select(r => r.LocalAddresses).Where(p => !string.IsNullOrEmpty(p) && p != "*").Distinct().ToList();
            aggRule.LocalAddresses = localAddresses.Any() ? string.Join(", ", localAddresses) : "*";

            var remoteAddresses = group.Select(r => r.RemoteAddresses).Where(p => !string.IsNullOrEmpty(p) && p != "*").Distinct().ToList();
            aggRule.RemoteAddresses = remoteAddresses.Any() ? string.Join(", ", remoteAddresses) : "*";

            return aggRule;
        }

        private string GetCommonName(List<AdvancedRuleViewModel> group)
        {
            if (group.Count == 0) return string.Empty;
            if (group.Count == 1) return group[0].Name ?? string.Empty;

            var names = group.Select(r => r.Name ?? string.Empty).ToList();
            string first = names[0];
            int commonPrefixLength = first.Length;

            foreach (string name in names.Skip(1))
            {
                commonPrefixLength = Math.Min(commonPrefixLength, name.Length);
                for (int i = 0; i < commonPrefixLength; i++)
                {
                    if (first[i] != name[i])
                    {
                        commonPrefixLength = i;
                        break;
                    }
                }
            }

            string commonPrefix = first.Substring(0, commonPrefixLength).Trim();
            if (commonPrefix.EndsWith("-") || commonPrefix.EndsWith("("))
            {
                commonPrefix = commonPrefix.Substring(0, commonPrefix.Length - 1).Trim();
            }

            return string.IsNullOrEmpty(commonPrefix) ? (group[0].Grouping ?? string.Empty) : commonPrefix;
        }


        private RuleType DetermineRuleType(AdvancedRuleViewModel rule)
        {
            if ((rule.Description != null && rule.Description.StartsWith(MFWConstants.UwpDescriptionPrefix, StringComparison.Ordinal)) ||
                 (rule.ApplicationName != null && rule.ApplicationName.StartsWith("@", StringComparison.Ordinal)) ||
                (rule.Name != null && rule.Name.StartsWith("@", StringComparison.Ordinal)))
            {
                return RuleType.UWP;
            }

            if (!string.IsNullOrEmpty(rule.ServiceName) && rule.ServiceName != "*")
                return RuleType.Service;

            if (!string.IsNullOrEmpty(rule.ApplicationName) && rule.ApplicationName != "*")
            {
                bool hasSpecifics = (!string.IsNullOrEmpty(rule.LocalPorts) && rule.LocalPorts != "*") ||
                                     (!string.IsNullOrEmpty(rule.RemotePorts) && rule.RemotePorts != "*") ||
                                     (!string.IsNullOrEmpty(rule.LocalAddresses) && rule.LocalAddresses != "*") ||
                                     (!string.IsNullOrEmpty(rule.RemoteAddresses) && rule.RemoteAddresses != "*");
                return hasSpecifics ? RuleType.Advanced : RuleType.Program;
            }
            return RuleType.Advanced;
        }

        public async Task<MfwRuleStatus> CheckMfwRuleStatusAsync(string appPath, string serviceName, string direction)
        {
            if (!Enum.TryParse<Directions>(direction, true, out var dirEnum))
            {
                return MfwRuleStatus.None;
            }

            string normalizedAppPath = string.IsNullOrEmpty(appPath) ? string.Empty : PathResolver.NormalizePath(appPath);
            var serviceNamesSet = string.IsNullOrEmpty(serviceName)
                 ? null
                : new HashSet<string>(serviceName.Split(new[] { ',', ' ' }, StringSplitOptions.RemoveEmptyEntries), StringComparer.OrdinalIgnoreCase);

            var mfwRules = await GetMfwRulesAsync(CancellationToken.None);

            if (mfwRules == null)
            {
                Debug.WriteLine("[ERROR] CheckMfwRuleStatus: GetMfwRulesAsync() returned null unexpectedly.");
                return MfwRuleStatus.None;
            }

            bool foundAllow = false;
            bool foundBlock = false;

            bool eventHasService = serviceNamesSet != null && serviceNamesSet.Count > 0;
            bool eventHasApp = !string.IsNullOrEmpty(normalizedAppPath);

            foreach (var rule in mfwRules)
            {
                if (rule == null) continue;
                if (!rule.Direction.HasFlag(dirEnum)) continue;

                bool ruleHasService = !string.IsNullOrEmpty(rule.ServiceName) && rule.ServiceName != "*";
                bool ruleHasApp = !string.IsNullOrEmpty(rule.ApplicationName) && rule.ApplicationName != "*";

                bool match = false;

                if (eventHasService)
                {
                    if (ruleHasService && serviceNamesSet!.Contains(rule.ServiceName))
                    {
                        if (ruleHasApp)
                        {
                            if (eventHasApp && string.Equals(PathResolver.NormalizePath(rule.ApplicationName), normalizedAppPath, StringComparison.OrdinalIgnoreCase))
                            {
                                match = true;
                            }
                        }
                        else
                        {
                            match = true;
                        }
                    }
                }
                else
                {
                    if (!ruleHasService && ruleHasApp && eventHasApp)
                    {
                        if (string.Equals(PathResolver.NormalizePath(rule.ApplicationName), normalizedAppPath, StringComparison.OrdinalIgnoreCase))
                        {
                            match = true;
                        }
                    }
                }

                if (match)
                {
                    if (rule.Status == "Allow")
                    {
                        foundAllow = true;
                    }
                    else if (rule.Status == "Block")
                    {
                        foundBlock = true;
                    }

                    if (foundBlock) break;
                }
            }

            if (foundBlock) return MfwRuleStatus.MfwBlock;
            if (foundAllow) return MfwRuleStatus.MfwAllow;
            return MfwRuleStatus.None;
        }

        public void ClearCaches()
        {
            _localCache.Remove(ServicesCacheKey);
            InvalidateRuleCache();
        }

        public static AdvancedRuleViewModel CreateAdvancedRuleViewModel(INetFwRule2 rule)
        {
            var appName = rule.ApplicationName ?? string.Empty;
            return new AdvancedRuleViewModel
            {
                Name = rule.Name ?? "Unnamed Rule",
                Description = rule.Description ?? "N/A",
                IsEnabled = rule.Enabled,
                Status = rule.Action == NET_FW_ACTION_.NET_FW_ACTION_ALLOW ? "Allow" : "Block",
                Direction = (Directions)rule.Direction,
                ApplicationName = appName == "*" ? "*" : PathResolver.NormalizePath(appName),
                LocalPorts = string.IsNullOrEmpty(rule.LocalPorts) ? "*" : rule.LocalPorts,
                RemotePorts = string.IsNullOrEmpty(rule.RemotePorts) ? "*" : rule.RemotePorts,
                Protocol = (int)rule.Protocol,
                ProtocolName = GetProtocolName(rule.Protocol),
                ServiceName = (string.IsNullOrEmpty(rule.serviceName) || rule.serviceName == "*") ? string.Empty : rule.serviceName,
                LocalAddresses = string.IsNullOrEmpty(rule.LocalAddresses) ? "*" : rule.LocalAddresses,
                RemoteAddresses = string.IsNullOrEmpty(rule.RemoteAddresses) ? "*" : rule.RemoteAddresses,
                Profiles = GetProfileString(rule.Profiles),
                Grouping = rule.Grouping ?? string.Empty,
                InterfaceTypes = rule.InterfaceTypes ?? "All",
                IcmpTypesAndCodes = rule.IcmpTypesAndCodes ?? ""
            };
        }

        private static string GetProtocolName(int protocolValue)
        {
            return protocolValue switch
            {
                6 => "TCP",
                17 => "UDP",
                1 => "ICMPv4",
                58 => "ICMPv6",
                2 => "IGMP",
                256 => "Any",
                _ => protocolValue.ToString(),
            };
        }

        private static string GetProfileString(int profiles)
        {
            if (profiles == (int)NET_FW_PROFILE_TYPE2_.NET_FW_PROFILE2_ALL) return "All";
            var profileNames = new List<string>(3);
            if ((profiles & (int)NET_FW_PROFILE_TYPE2_.NET_FW_PROFILE2_DOMAIN) != 0) profileNames.Add("Domain");
            if ((profiles & (int)NET_FW_PROFILE_TYPE2_.NET_FW_PROFILE2_PRIVATE) != 0) profileNames.Add("Private");
            if ((profiles & (int)NET_FW_PROFILE_TYPE2_.NET_FW_PROFILE2_PUBLIC) != 0) profileNames.Add("Public");
            return string.Join(", ", profileNames);
        }
    }
}

--------------------------------------------------
// Full Path: C:/Users/anon/PROGRAMMING/C#/SimpleFirewall/VS Minimal Firewall/MinimalFirewall-NET8/Backups/v2.5.5 - ws/2.5.5.6 - security vulnerability fix 3/FirewallEventListenerService.cs
--------------------------------------------------------------------------------
// File: FirewallEventListenerService.cs
using System.Diagnostics;
using System.Diagnostics.Eventing.Reader;
using System.IO;
using System.Xml;
using System.Collections.Concurrent;
using MinimalFirewall.TypedObjects;
using System.Collections.Generic;

namespace MinimalFirewall
{
    public partial class FirewallEventListenerService : IDisposable
    {
        private readonly FirewallDataService _dataService;
        private readonly WildcardRuleService _wildcardRuleService;
        private readonly Func<bool> _isLockdownEnabled;
        private readonly AppSettings _appSettings;
        private readonly PublisherWhitelistService _whitelistService;
        private readonly ConcurrentDictionary<string, DateTime> _snoozedApps = new(StringComparer.OrdinalIgnoreCase);
        private readonly ConcurrentDictionary<string, bool> _pendingNotifications = new(StringComparer.OrdinalIgnoreCase);
        private EventLogWatcher? _eventWatcher;
        private readonly Action<string> _logAction;
        private readonly BackgroundFirewallTaskService _backgroundTaskService;

        public FirewallActionsService? ActionsService { get; set; }

        public event Action<PendingConnectionViewModel>? PendingConnectionDetected;

        public FirewallEventListenerService(FirewallDataService dataService, WildcardRuleService wildcardRuleService, Func<bool> isLockdownEnabled, Action<string> logAction, AppSettings appSettings, PublisherWhitelistService whitelistService, BackgroundFirewallTaskService backgroundTaskService)
        {
            _dataService = dataService;
            _wildcardRuleService = wildcardRuleService;
            _isLockdownEnabled = isLockdownEnabled;
            _logAction = logAction;
            _appSettings = appSettings;
            _whitelistService = whitelistService;
            _backgroundTaskService = backgroundTaskService;
        }

        public void Start()
        {
            if (_eventWatcher != null)
            {
                if (!_eventWatcher.Enabled)
                {
                    _eventWatcher.Enabled = true;
                    _logAction("[EventListener] Event watcher re-enabled.");
                }
                return;
            }

            try
            {
                var query = new EventLogQuery("Security", PathType.LogName, "*[System[EventID=5157]]");
                _eventWatcher = new EventLogWatcher(query);
                _eventWatcher.EventRecordWritten += OnEventRecordWritten;
                _eventWatcher.Enabled = true;
                _logAction("[EventListener] Event watcher started successfully.");
            }
            catch (EventLogException ex)
            {
                _logAction($"[EventListener ERROR] You may not have permission to read the Security event log: {ex.Message}");
                MessageBox.Show("Could not start firewall event listener. Please run as Administrator.", "Permission Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
            }
        }

        public void Stop()
        {
            if (_eventWatcher != null)
            {
                _eventWatcher.Enabled = false;
                _eventWatcher.EventRecordWritten -= OnEventRecordWritten;
                _eventWatcher.Dispose();
                _eventWatcher = null;
                _logAction("[EventListener] Event watcher stopped and disposed.");
            }
        }

        private void OnEventRecordWritten(object? sender, EventRecordWrittenEventArgs e)
        {
            if (e.EventRecord == null)
            {
                return;
            }

            try
            {
                string xmlContent = e.EventRecord.ToXml();
                Task.Run(async () => await OnFirewallBlockEvent(xmlContent));
            }
            catch (EventLogException)
            {

            }
        }

        private async Task OnFirewallBlockEvent(string xmlContent)
        {
            string rawAppPathForClear = GetValueFromXml(xmlContent, "Application");
            string appPathForClear = PathResolver.NormalizePath(PathResolver.ConvertDevicePathToDrivePath(rawAppPathForClear));
            string directionForClear = ParseDirection(GetValueFromXml(xmlContent, "Direction"));
            string remoteAddressForClear = GetValueFromXml(xmlContent, "RemoteAddress");
            string remotePortForClear = GetValueFromXml(xmlContent, "RemotePort");
            string protocolForClear = GetValueFromXml(xmlContent, "Protocol");

            try
            {
                string rawAppPath = GetValueFromXml(xmlContent, "Application");
                string protocol = GetValueFromXml(xmlContent, "Protocol");
                string remotePort = GetValueFromXml(xmlContent, "RemotePort");
                string remoteAddress = GetValueFromXml(xmlContent, "RemoteAddress");
                string eventDirection = ParseDirection(GetValueFromXml(xmlContent, "Direction"));
                string filterId = GetValueFromXml(xmlContent, "FilterId");
                string layerId = GetValueFromXml(xmlContent, "LayerId");

                string xmlServiceName = GetValueFromXml(xmlContent, "ServiceName");
                string serviceName = (xmlServiceName == "N/A" || string.IsNullOrEmpty(xmlServiceName)) ? string.Empty : xmlServiceName;

                _logAction($"[EventListener] Block event received for raw path: '{rawAppPath}', Service: '{serviceName}', Direction: '{eventDirection}', Protocol: {protocol}, Remote: {remoteAddress}:{remotePort}, FilterId: {filterId}, LayerId: {layerId}");

                string appPath = PathResolver.ConvertDevicePathToDrivePath(rawAppPath);
                if (string.IsNullOrEmpty(appPath) || appPath.Equals("System", StringComparison.OrdinalIgnoreCase))
                {
                    _logAction($"[EventListener] Ignoring event for System or empty path: '{appPath}'");
                    return;
                }
                appPath = PathResolver.NormalizePath(appPath);
                _logAction($"[EventListener] Normalized path: '{appPath}', Direction: '{eventDirection}'");

                string notificationKey = $"{appPath}|{eventDirection}|{remoteAddress}|{remotePort}|{protocol}";
                if (!_pendingNotifications.TryAdd(notificationKey, true))
                {
                    _logAction($"[EventListener] Notification already pending for '{notificationKey}'. Ignoring duplicate event.");
                    return;
                }

                if (!ShouldProcessEvent(appPath))
                {
                    ClearPendingNotification(appPath, eventDirection, remoteAddress, remotePort, protocol);
                    return;
                }

                if (Path.GetFileName(appPath).Equals("svchost.exe", StringComparison.OrdinalIgnoreCase))
                {
                    if (string.IsNullOrEmpty(serviceName))
                    {
                        string processId = GetValueFromXml(xmlContent, "ProcessID");
                        if (!string.IsNullOrEmpty(processId) && processId != "0")
                        {
                            serviceName = SystemDiscoveryService.GetServicesByPID(processId);
                            _logAction($"[EventListener] svchost.exe detected. XML ServiceName was empty. PID: {processId}, Resolved Service(s): '{serviceName}'");
                        }
                    }
                    else
                    {
                        _logAction($"[EventListener] svchost.exe detected. ServiceName from XML: '{serviceName}'");
                    }
                }

                if (!string.IsNullOrEmpty(serviceName) &&
                    (serviceName.Equals("Dhcp", StringComparison.OrdinalIgnoreCase) ||
                     serviceName.Equals("Dnscache", StringComparison.OrdinalIgnoreCase)))
                {
                    _logAction($"[EventListener] Ignoring event for '{serviceName}' service (managed by system).");
                    ClearPendingNotification(appPath, eventDirection, remoteAddress, remotePort, protocol);
                    return;
                }

                MfwRuleStatus existingRuleStatus = await _dataService.CheckMfwRuleStatusAsync(appPath, serviceName, eventDirection);
                _logAction($"[EventListener] CheckMfwRuleStatus result for '{appPath}' (Service: '{serviceName}', Direction: '{eventDirection}') is: {existingRuleStatus}");

                if (existingRuleStatus == MfwRuleStatus.MfwBlock)
                {
                    _logAction($"[EventListener] An MFW Block rule already exists. Ignoring event.");
                    ClearPendingNotification(appPath, eventDirection, remoteAddress, remotePort, protocol);
                    return;
                }
                else if (existingRuleStatus == MfwRuleStatus.MfwAllow)
                {
                    if (filterId == "0")
                    {
                        _logAction($"[EventListener] Race condition detected: An MFW Allow rule exists, but a block event (FilterId 0) was received. Invalidating cache and snoozing to allow network to stabilize.");
                        _dataService.InvalidateRuleCache();
                        SnoozeNotificationsForApp(appPath, TimeSpan.FromSeconds(10));
                        ClearPendingNotification(appPath, eventDirection, remoteAddress, remotePort, protocol);
                        return;
                    }

                    _logAction($"[EventListener] An MFW Allow rule exists for this connection. Ignoring block event (FilterId: {filterId}).");
                    ClearPendingNotification(appPath, eventDirection, remoteAddress, remotePort, protocol);
                    return;
                }

                var matchingRule = _wildcardRuleService.Match(appPath);
                if (matchingRule != null)
                {
                    _logAction($"[EventListener] Wildcard rule matched for '{appPath}'. Action: '{matchingRule.Action}'.");
                    if (matchingRule.Action.StartsWith("Allow", StringComparison.OrdinalIgnoreCase) && ActionsService != null)
                    {
                        ActionsService.ApplyWildcardMatch(appPath, serviceName, matchingRule);
                        _logAction($"[EventListener] Applying Allow action from matched wildcard rule.");
                    }
                    else
                    {
                        _logAction($"[EventListener] Matched wildcard rule action is '{matchingRule.Action}'. Ignoring block event.");
                    }
                    ClearPendingNotification(appPath, eventDirection, remoteAddress, remotePort, protocol);
                    return;
                }

                if (_appSettings.AutoAllowSystemTrusted)
                {
                    if (SignatureValidationService.IsSignatureTrusted(appPath, out var trustedPublisherName) && trustedPublisherName != null)
                    {
                        _logAction($"[EventListener] Auto-allowing trusted application '{appPath}' by publisher '{trustedPublisherName}'.");
                        string allowAction = $"Allow ({eventDirection})";

                        if (_backgroundTaskService != null && !string.IsNullOrEmpty(appPath))
                        {
                            var appPayload = new ApplyApplicationRulePayload { AppPaths = new List<string> { appPath }, Action = allowAction };
                            _backgroundTaskService.EnqueueTask(new FirewallTask(FirewallTaskType.ApplyApplicationRule, appPayload));
                        }
                        else
                        {
                            _logAction($"[EventListener ERROR] Cannot auto-allow. BackgroundTaskService is null or appPath is invalid.");
                        }

                        ClearPendingNotification(appPath, eventDirection, remoteAddress, remotePort, protocol);
                        return;
                    }
                    else
                    {
                        _logAction($"[EventListener] App '{appPath}' not trusted or signature check failed. Not auto-allowing.");
                    }
                }

                var pendingVm = new PendingConnectionViewModel
                {
                    AppPath = appPath,
                    Direction = eventDirection,
                    ServiceName = serviceName,
                    Protocol = protocol,
                    RemotePort = remotePort,
                    RemoteAddress = remoteAddress,
                    FilterId = filterId,
                    LayerId = layerId
                };
                _logAction($"[EventListener] Queuing pending connection for user decision: '{appPath}' (Service: '{serviceName}', Direction: '{eventDirection}', FilterId: {filterId})");
                PendingConnectionDetected?.Invoke(pendingVm);

            }
            catch (Exception ex)
            {
                _logAction($"[FATAL ERROR IN EVENT HANDLER] {ex}");
                ClearPendingNotification(appPathForClear, directionForClear, remoteAddressForClear, remotePortForClear, protocolForClear);
            }
        }

        public void ClearPendingNotification(string appPath, string direction, string remoteAddress, string remotePort, string protocol)
        {
            if (string.IsNullOrEmpty(appPath) || string.IsNullOrEmpty(direction)) return;
            string key = $"{appPath}|{direction}|{remoteAddress}|{remotePort}|{protocol}";
            if (_pendingNotifications.TryRemove(key, out _))
            {
                _logAction($"[EventListener] Cleared specific pending notification flag for '{key}'.");
            }
        }

        public void ClearPendingNotification(string appPath, string direction)
        {
            if (string.IsNullOrEmpty(appPath) || string.IsNullOrEmpty(direction)) return;
            string keyPrefix = $"{appPath}|{direction}|";

            var matchingKeys = _pendingNotifications.Keys.Where(k => k.StartsWith(keyPrefix)).ToList();
            foreach (var k in matchingKeys)
            {
                if (_pendingNotifications.TryRemove(k, out _))
                {
                    _logAction($"[EventListener] Cleared pending notification flag for '{k}' (fallback match).");
                }
            }
        }

        public void SnoozeNotificationsForApp(string appPath, TimeSpan duration)
        {
            _snoozedApps[appPath] = DateTime.UtcNow.Add(duration);
            _logAction($"[EventListener] Snoozing notifications for '{appPath}' for {duration}.");
        }

        public void ClearAllSnoozes()
        {
            _snoozedApps.Clear();
            _logAction($"[EventListener] Cleared all snoozes.");
        }

        private bool ShouldProcessEvent(string appPath)
        {
            if (string.IsNullOrEmpty(appPath) || appPath.Equals("System", StringComparison.OrdinalIgnoreCase))
            {
                _logAction($"[EventListener] ShouldProcessEvent=false (System or empty path)");
                return false;
            }

            if (_snoozedApps.TryGetValue(appPath, out DateTime snoozeUntil) && DateTime.UtcNow < snoozeUntil)
            {
                _logAction($"[EventListener] Event for '{appPath}' is snoozed. Ignoring.");
                return false;
            }

            bool lockdown = _isLockdownEnabled();
            if (!lockdown)
            {
                _logAction($"[EventListener] ShouldProcessEvent=false (Lockdown not enabled)");
            }
            return lockdown;
        }

        private static string ParseDirection(string rawDirection)
        {
            return rawDirection switch
            {
                "%%14592" => "Incoming",
                "%%14593" => "Outgoing",
                _ => rawDirection,
            };
        }

        private static string GetValueFromXml(string xml, string elementName)
        {
            try
            {
                using var stringReader = new StringReader(xml);
                using var xmlReader = XmlReader.Create(stringReader, new XmlReaderSettings { ConformanceLevel = ConformanceLevel.Fragment });

                while (xmlReader.Read())
                {
                    if (xmlReader.NodeType == XmlNodeType.Element && xmlReader.Name == "Data")
                    {
                        if (xmlReader.GetAttribute("Name") == elementName)
                        {
                            if (xmlReader.IsEmptyElement)
                            {
                                return string.Empty;
                            }
                            xmlReader.Read();
                            if (xmlReader.NodeType == XmlNodeType.Text)
                            {
                                return xmlReader.Value;
                            }
                            return string.Empty;
                        }
                    }
                }
            }
            catch (XmlException ex)
            {
                Debug.WriteLine($"[XML PARSE ERROR] Failed to parse event XML for element '{elementName}': {ex.Message}\nXML: {xml}");
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"[UNEXPECTED XML PARSE ERROR] for element '{elementName}': {ex.Message}\nXML: {xml}");
            }
            return string.Empty;
        }

        public void Dispose()
        {
            Stop();
            GC.SuppressFinalize(this);
        }
    }
}

--------------------------------------------------
// Full Path: C:/Users/anon/PROGRAMMING/C#/SimpleFirewall/VS Minimal Firewall/MinimalFirewall-NET8/Backups/v2.5.5 - ws/2.5.5.6 - security vulnerability fix 3/FirewallGroups.cs
--------------------------------------------------------------------------------
using NetFwTypeLib;
using System.ComponentModel;
using System.Linq;
using System.Runtime.InteropServices;
namespace MinimalFirewall.Groups
{
    public class FirewallGroup : INotifyPropertyChanged
    {
        public string Name { get; }
        public int RuleCount { get; }

        public event PropertyChangedEventHandler? PropertyChanged;
        public FirewallGroup(string name, List<INetFwRule2> groupRules)
        {
            Name = name;
            RuleCount = groupRules.Count;
            IsEnabled = groupRules.Count > 0 && groupRules.All(r => r.Enabled);
        }

        public bool IsEnabled { get; private set; }

        public void SetEnabledState(bool isEnabled)
        {
            if (IsEnabled != isEnabled)
            {
                IsEnabled = isEnabled;
                PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(nameof(IsEnabled)));
            }
        }
    }

    public class FirewallGroupManager
    {
        public FirewallGroupManager() { }

        private INetFwPolicy2 GetFirewallPolicy()
        {
            try
            {
                Type? policyType = Type.GetTypeFromProgID("HNetCfg.FwPolicy2");
                if (policyType == null)
                {
                    throw new InvalidOperationException("Firewall policy type could not be retrieved.");
                }
                return (INetFwPolicy2)Activator.CreateInstance(policyType)!;
            }
            catch (COMException ex)
            {
                throw new InvalidOperationException("Failed to create firewall policy instance.", ex);
            }
        }

        public List<FirewallGroup> GetAllGroups()
        {
            var groupsData = new Dictionary<string, List<INetFwRule2>>(System.StringComparer.OrdinalIgnoreCase);
            INetFwPolicy2? policy = null;
            INetFwRules? comRules = null;
            try
            {
                policy = GetFirewallPolicy();
                comRules = policy.Rules;
                foreach (INetFwRule2 rule in comRules)
                {
                    if (rule?.Grouping is { Length: > 0 } && rule.Grouping.EndsWith(MFWConstants.MfwRuleSuffix))
                    {
                        if (!groupsData.TryGetValue(rule.Grouping, out var ruleList))
                        {
                            ruleList = new List<INetFwRule2>();
                            groupsData[rule.Grouping] = ruleList;
                        }
                        ruleList.Add(rule);
                    }
                    else
                    {
                        if (rule != null) Marshal.ReleaseComObject(rule);
                    }
                }
            }
            finally
            {
                if (comRules != null) Marshal.ReleaseComObject(comRules);
                if (policy != null) Marshal.ReleaseComObject(policy);
            }

            var list = new List<FirewallGroup>(groupsData.Count);
            foreach (var group in groupsData)
            {
                list.Add(new FirewallGroup(group.Key, group.Value));
            }

            foreach (var ruleList in groupsData.Values)
            {
                foreach (var rule in ruleList)
                {
                    Marshal.ReleaseComObject(rule);
                }
            }

            return list.OrderBy(g => g.Name).ToList();
        }
    }
}



--------------------------------------------------
// Full Path: C:/Users/anon/PROGRAMMING/C#/SimpleFirewall/VS Minimal Firewall/MinimalFirewall-NET8/Backups/v2.5.5 - ws/2.5.5.6 - security vulnerability fix 3/FirewallRuleBuilderExtensions.cs
--------------------------------------------------------------------------------
// FirewallRuleBuilderExtensions.cs
using MinimalFirewall.TypedObjects;
using NetFwTypeLib;

namespace MinimalFirewall
{
    public static class FirewallRuleBuilderExtensions
    {
        public static INetFwRule2 WithName(this INetFwRule2 rule, string name)
        {
            rule.Name = name;
            return rule;
        }

        public static INetFwRule2 WithDescription(this INetFwRule2 rule, string description)
        {
            rule.Description = description;
            return rule;
        }

        public static INetFwRule2 WithDirection(this INetFwRule2 rule, Directions direction)
        {
            rule.Direction = (NET_FW_RULE_DIRECTION_)direction;
            return rule;
        }

        public static INetFwRule2 WithAction(this INetFwRule2 rule, Actions action)
        {
            rule.Action = (NET_FW_ACTION_)action;
            return rule;
        }

        public static INetFwRule2 WithProtocol(this INetFwRule2 rule, int protocol)
        {
            rule.Protocol = protocol;
            return rule;
        }

        public static INetFwRule2 WithLocalPorts(this INetFwRule2 rule, string ports)
        {
            rule.LocalPorts = ports;
            return rule;
        }

        public static INetFwRule2 WithRemotePorts(this INetFwRule2 rule, string ports)
        {
            rule.RemotePorts = ports;
            return rule;
        }

        public static INetFwRule2 ForApplication(this INetFwRule2 rule, string applicationPath)
        {
            rule.ApplicationName = applicationPath;
            return rule;
        }

        public static INetFwRule2 ForService(this INetFwRule2 rule, string serviceName)
        {
            rule.serviceName = serviceName;
            return rule;
        }

        public static INetFwRule2 WithGrouping(this INetFwRule2 rule, string group)
        {
            rule.Grouping = group;
            return rule;
        }

        public static INetFwRule2 IsEnabled(this INetFwRule2 rule, bool enabled = true)
        {
            rule.Enabled = enabled;
            return rule;
        }
    }
}

--------------------------------------------------
// Full Path: C:/Users/anon/PROGRAMMING/C#/SimpleFirewall/VS Minimal Firewall/MinimalFirewall-NET8/Backups/v2.5.5 - ws/2.5.5.6 - security vulnerability fix 3/FirewallRuleService.cs
--------------------------------------------------------------------------------
using NetFwTypeLib;
using System.Diagnostics;
using System.Runtime.InteropServices;

namespace MinimalFirewall
{
    public class FirewallRuleService
    {
        private const int E_ACCESSDENIED = unchecked((int)0x80070005);
        private const int HRESULT_FROM_WIN32_ERROR_FILE_NOT_FOUND = unchecked((int)0x80070002);
        private const int HRESULT_FROM_WIN32_ERROR_ALREADY_EXISTS = unchecked((int)0x800700B7);

        public FirewallRuleService()
        {
        }

        private INetFwPolicy2 GetLocalPolicy()
        {
            Type? policyType = Type.GetTypeFromProgID("HNetCfg.FwPolicy2");
            if (policyType == null)
            {
                throw new InvalidOperationException("Firewall policy type could not be retrieved.");
            }
            return (INetFwPolicy2)Activator.CreateInstance(policyType)!;
        }


        public List<INetFwRule2> GetAllRules()
        {
            INetFwPolicy2 firewallPolicy = GetLocalPolicy();
            if (firewallPolicy?.Rules == null) return [];
            var rulesList = new List<INetFwRule2>();
            var comRules = firewallPolicy.Rules;
            try
            {
                foreach (INetFwRule2 rule in comRules)
                {
                    rulesList.Add(rule);
                }
                return rulesList;
            }
            catch (COMException ex)
            {
                Debug.WriteLine($"[ERROR] GetAllRules: Failed to retrieve firewall rules. HResult: 0x{ex.HResult:X8}. Message: {ex.Message}");
                foreach (var rule in rulesList)
                {
                    Marshal.ReleaseComObject(rule);
                }
                return [];
            }
            finally
            {
                if (comRules != null) Marshal.ReleaseComObject(comRules);
                if (firewallPolicy != null) Marshal.ReleaseComObject(firewallPolicy);
            }
        }


        public INetFwRule2?
        GetRuleByName(string name)
        {
            INetFwPolicy2 firewallPolicy = GetLocalPolicy();
            if (firewallPolicy == null) return null;
            try
            {
                return firewallPolicy.Rules.Item(name) as INetFwRule2;
            }
            catch (FileNotFoundException)
            {
                return null;
            }
            catch (COMException ex)
            {
                Debug.WriteLine($"[ERROR] GetRuleByName ('{name}'): COM error. HResult: 0x{ex.HResult:X8}. Message: {ex.Message}");
                return null;
            }
            finally
            {
                if (firewallPolicy != null) Marshal.ReleaseComObject(firewallPolicy);
            }
        }

        public void SetDefaultOutboundAction(NET_FW_ACTION_ action)
        {
            INetFwPolicy2 firewallPolicy = GetLocalPolicy();
            if (firewallPolicy == null) return;
            foreach (NET_FW_PROFILE_TYPE2_ profile in new[]
            {
                NET_FW_PROFILE_TYPE2_.NET_FW_PROFILE2_DOMAIN,
                NET_FW_PROFILE_TYPE2_.NET_FW_PROFILE2_PRIVATE,
                NET_FW_PROFILE_TYPE2_.NET_FW_PROFILE2_PUBLIC
            })
            {
                try
                {
                    firewallPolicy.set_DefaultOutboundAction(profile, action);
                }
                catch (COMException ex)
                {
                    Debug.WriteLine($"[ERROR] SetDefaultOutboundAction ({profile}): Failed. HResult: 0x{ex.HResult:X8}. Message: {ex.Message}");
                    if (ex.HResult == E_ACCESSDENIED)
                    {
                        Debug.WriteLine("[ERROR] SetDefaultOutboundAction: Access Denied. Ensure the application is running with administrator privileges.");
                    }
                }
            }
            if (firewallPolicy != null) Marshal.ReleaseComObject(firewallPolicy);
        }


        public List<string> GetRuleNamesByPathAndDirection(string appPath, NET_FW_RULE_DIRECTION_ direction)
        {
            var rules = GetRulesByPathAndDirection(appPath, direction);
            var names = rules.Select(r => r.Name).ToList();
            foreach (var rule in rules)
            {
                Marshal.ReleaseComObject(rule);
            }
            return names;
        }

        public List<INetFwRule2> GetRulesByPathAndDirection(string appPath, NET_FW_RULE_DIRECTION_ direction)
        {
            if (string.IsNullOrEmpty(appPath)) return [];
            string normalizedAppPath = PathResolver.NormalizePath(appPath);
            var matchingRules = new List<INetFwRule2>();
            var allRules = GetAllRules();
            var rulesToRelease = new List<INetFwRule2>();

            try
            {
                foreach (var rule in allRules)
                {
                    if (rule != null &&
                        !string.IsNullOrEmpty(rule.ApplicationName) &&
                         string.Equals(PathResolver.NormalizePath(rule.ApplicationName), normalizedAppPath, StringComparison.OrdinalIgnoreCase) &&
                         rule.Direction == direction)
                    {
                        matchingRules.Add(rule);
                    }
                    else if (rule != null)
                    {
                        rulesToRelease.Add(rule);
                    }
                }
            }
            finally
            {
                foreach (var rule in rulesToRelease)
                {
                    Marshal.ReleaseComObject(rule);
                }
            }
            return matchingRules;
        }


        public NET_FW_ACTION_ GetDefaultOutboundAction()
        {
            INetFwPolicy2 firewallPolicy = GetLocalPolicy();
            if (firewallPolicy == null) return NET_FW_ACTION_.NET_FW_ACTION_ALLOW;
            try
            {
                var currentProfileTypes = (NET_FW_PROFILE_TYPE2_)firewallPolicy.CurrentProfileTypes;
                if ((currentProfileTypes & NET_FW_PROFILE_TYPE2_.NET_FW_PROFILE2_PUBLIC) != 0)
                {
                    return firewallPolicy.DefaultOutboundAction[NET_FW_PROFILE_TYPE2_.NET_FW_PROFILE2_PUBLIC];
                }
                if ((currentProfileTypes & NET_FW_PROFILE_TYPE2_.NET_FW_PROFILE2_PRIVATE) != 0)
                {
                    return firewallPolicy.DefaultOutboundAction[NET_FW_PROFILE_TYPE2_.NET_FW_PROFILE2_PRIVATE];
                }
                if ((currentProfileTypes & NET_FW_PROFILE_TYPE2_.NET_FW_PROFILE2_DOMAIN) != 0)
                {
                    return firewallPolicy.DefaultOutboundAction[NET_FW_PROFILE_TYPE2_.NET_FW_PROFILE2_DOMAIN];
                }
                Debug.WriteLine("[WARN] GetDefaultOutboundAction: No specific profile type identified as active. Falling back to Public.");
                return firewallPolicy.DefaultOutboundAction[NET_FW_PROFILE_TYPE2_.NET_FW_PROFILE2_PUBLIC];
            }
            catch (COMException ex)
            {
                Debug.WriteLine($"[ERROR] GetDefaultOutboundAction: Failed. HResult: 0x{ex.HResult:X8}. Message: {ex.Message}");
                return NET_FW_ACTION_.NET_FW_ACTION_ALLOW;
            }
            finally
            {
                if (firewallPolicy != null) Marshal.ReleaseComObject(firewallPolicy);
            }
        }


        public List<string> DeleteRulesByPath(List<string> appPaths)
        {
            if (appPaths.Count == 0) return [];

            var pathSet = new HashSet<string>(appPaths.Select(PathResolver.NormalizePath), StringComparer.OrdinalIgnoreCase);
            var rulesToRemove = new List<string>();
            var allRules = GetAllRules();
            var rulesToRelease = new List<INetFwRule2>();
            var rulesToKeepForRelease = new List<INetFwRule2>();

            try
            {
                foreach (var rule in allRules)
                {
                    if (rule != null && !string.IsNullOrEmpty(rule.ApplicationName) && pathSet.Contains(PathResolver.NormalizePath(rule.ApplicationName)))
                    {
                        rulesToRemove.Add(rule.Name);
                        rulesToKeepForRelease.Add(rule);
                    }
                    else if (rule != null)
                    {
                        rulesToRelease.Add(rule);
                    }
                }
            }
            finally
            {
                foreach (var rule in rulesToRelease)
                {
                    Marshal.ReleaseComObject(rule);
                }
                foreach (var rule in rulesToKeepForRelease)
                {
                    Marshal.ReleaseComObject(rule);
                }
            }

            DeleteRulesByName(rulesToRemove);
            return rulesToRemove;
        }


        public List<string> DeleteRulesByServiceName(string serviceName)
        {
            if (string.IsNullOrEmpty(serviceName)) return [];

            var rulesToRemove = new List<string>();
            var allRules = GetAllRules();
            var rulesToRelease = new List<INetFwRule2>();
            var rulesToKeepForRelease = new List<INetFwRule2>();

            try
            {
                foreach (var rule in allRules)
                {
                    if (rule is INetFwRule2 rule2 && rule2 != null && string.Equals(rule2.serviceName, serviceName, StringComparison.OrdinalIgnoreCase))
                    {
                        rulesToRemove.Add(rule2.Name);
                        rulesToKeepForRelease.Add(rule2);
                    }
                    else if (rule != null)
                    {
                        rulesToRelease.Add(rule);
                    }
                }
            }
            finally
            {
                foreach (var rule in rulesToRelease)
                {
                    Marshal.ReleaseComObject(rule);
                }
                foreach (var rule in rulesToKeepForRelease)
                {
                    Marshal.ReleaseComObject(rule);
                }
            }

            DeleteRulesByName(rulesToRemove);
            return rulesToRemove;
        }

        public List<string> DeleteConflictingServiceRules(string serviceName, NET_FW_ACTION_ newAction, NET_FW_RULE_DIRECTION_ newDirection)
        {
            if (string.IsNullOrEmpty(serviceName)) return [];

            var rulesToRemove = new List<string>();
            var allRules = GetAllRules();
            var rulesToRelease = new List<INetFwRule2>();
            var rulesToKeepForRelease = new List<INetFwRule2>();

            NET_FW_ACTION_ conflictingAction = (newAction == NET_FW_ACTION_.NET_FW_ACTION_ALLOW) ? NET_FW_ACTION_.NET_FW_ACTION_BLOCK : NET_FW_ACTION_.NET_FW_ACTION_ALLOW;

            try
            {
                foreach (var rule in allRules)
                {
                    if (rule is INetFwRule2 rule2 && rule2 != null &&
                        string.Equals(rule2.serviceName, serviceName, StringComparison.OrdinalIgnoreCase) &&
                        (rule2.Direction == newDirection || rule2.Direction == NET_FW_RULE_DIRECTION_.NET_FW_RULE_DIR_MAX) &&
                        rule2.Action == conflictingAction)
                    {
                        rulesToRemove.Add(rule2.Name);
                        rulesToKeepForRelease.Add(rule2);
                    }
                    else if (rule != null)
                    {
                        rulesToRelease.Add(rule);
                    }
                }
            }
            finally
            {
                foreach (var rule in rulesToRelease)
                {
                    if (rule != null) Marshal.ReleaseComObject(rule);
                }
                foreach (var rule in rulesToKeepForRelease)
                {
                    if (rule != null) Marshal.ReleaseComObject(rule);
                }
            }

            return rulesToRemove;
        }


        public List<string> DeleteUwpRules(List<string> packageFamilyNames)
        {
            if (packageFamilyNames.Count == 0) return [];

            var pfnSet = new HashSet<string>(packageFamilyNames, StringComparer.OrdinalIgnoreCase);
            var rulesToRemove = new List<string>();
            var allRules = GetAllRules();
            var rulesToRelease = new List<INetFwRule2>();
            var rulesToKeepForRelease = new List<INetFwRule2>();


            try
            {
                foreach (var rule in allRules)
                {
                    if (rule != null && rule.Description?.StartsWith(MFWConstants.UwpDescriptionPrefix, StringComparison.Ordinal) == true)
                    {
                        string pfnInRule = rule.Description[MFWConstants.UwpDescriptionPrefix.Length..];
                        if (pfnSet.Contains(pfnInRule))
                        {
                            rulesToRemove.Add(rule.Name);
                            rulesToKeepForRelease.Add(rule);
                        }
                        else
                        {
                            rulesToRelease.Add(rule);
                        }
                    }
                    else if (rule != null)
                    {
                        rulesToRelease.Add(rule);
                    }
                }
            }
            finally
            {
                foreach (var rule in rulesToRelease)
                {
                    Marshal.ReleaseComObject(rule);
                }
                foreach (var rule in rulesToKeepForRelease)
                {
                    Marshal.ReleaseComObject(rule);
                }
            }

            DeleteRulesByName(rulesToRemove);
            return rulesToRemove;
        }

        public void DeleteRulesByName(List<string> ruleNames)
        {
            if (ruleNames.Count == 0) return;
            INetFwPolicy2 firewallPolicy = GetLocalPolicy();
            if (firewallPolicy?.Rules == null) return;

            var rulesCollection = firewallPolicy.Rules;
            try
            {
                foreach (var name in ruleNames)
                {
                    try
                    {
                        rulesCollection.Remove(name);
                        Debug.WriteLine($"[INFO] DeleteRulesByName: Successfully requested removal of rule '{name}'.");
                    }
                    catch (FileNotFoundException)
                    {
                        Debug.WriteLine($"[WARN] DeleteRulesByName: Rule '{name}' not found for removal.");
                    }
                    catch (COMException ex)
                    {
                        Debug.WriteLine($"[ERROR] DeleteRulesByName ('{name}'): Failed. HResult: 0x{ex.HResult:X8}. Message: {ex.Message}");
                        if (ex.HResult == E_ACCESSDENIED)
                        {
                            Debug.WriteLine($"[ERROR] DeleteRulesByName ('{name}'): Access Denied.");
                        }
                        else if (ex.HResult == HRESULT_FROM_WIN32_ERROR_FILE_NOT_FOUND)
                        {
                            Debug.WriteLine($"[WARN] DeleteRulesByName: Rule '{name}' not found (reported via COMException HResult).");
                        }
                    }
                    catch (Exception ex)
                    {
                        Debug.WriteLine($"[ERROR] DeleteRulesByName ('{name}'): Unexpected error during removal. Type: {ex.GetType().Name}. Message: {ex.Message}");
                    }
                }
            }
            finally
            {
                if (rulesCollection != null) Marshal.ReleaseComObject(rulesCollection);
                if (firewallPolicy != null) Marshal.ReleaseComObject(firewallPolicy);
            }
        }


        public void CreateRule(INetFwRule2 rule)
        {
            INetFwPolicy2 firewallPolicy = GetLocalPolicy();
            INetFwRules? rulesCollection = null;
            try
            {
                if (firewallPolicy?.Rules == null)
                {
                    Debug.WriteLine("[ERROR] CreateRule: Firewall policy or rules collection is null.");
                    return;
                }
                rulesCollection = firewallPolicy.Rules;
                rulesCollection.Add(rule);
                Debug.WriteLine($"[INFO] CreateRule: Successfully requested addition of rule '{rule.Name}'.");
            }
            catch (COMException ex)
            {
                Debug.WriteLine($"[ERROR] CreateRule ('{rule?.Name ?? "null"}'): Failed. HResult: 0x{ex.HResult:X8}. Message: {ex.Message}");
                if (ex.HResult == E_ACCESSDENIED)
                {
                    Debug.WriteLine($"[ERROR] CreateRule ('{rule?.Name ?? "null"}'): Access Denied. Ensure administrator privileges.");
                    MessageBox.Show($"Access Denied: Could not create rule '{rule?.Name}'. Ensure the application is run as Administrator.", "Permission Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
                }
                else if (ex.HResult == HRESULT_FROM_WIN32_ERROR_ALREADY_EXISTS)
                {
                    Debug.WriteLine($"[WARN] CreateRule: Rule '{rule?.Name}' already exists.");
                }
                else
                {
                    MessageBox.Show($"Failed to create firewall rule '{rule?.Name}'.\n\nError: {ex.Message}\n(HResult: 0x{ex.HResult:X8})", "Rule Creation Failed", MessageBoxButtons.OK, MessageBoxIcon.Error);
                }
            }
            catch (ArgumentException ex)
            {
                Debug.WriteLine($"[ERROR] CreateRule ('{rule?.Name ?? "null"}'): Invalid argument. Message: {ex.Message}");
                MessageBox.Show($"Failed to create rule '{rule?.Name}'. One or more rule properties might be invalid.\n\nError: {ex.Message}", "Invalid Rule Parameter", MessageBoxButtons.OK, MessageBoxIcon.Error);
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"[ERROR] CreateRule ('{rule?.Name ?? "null"}'): Unexpected error. Type: {ex.GetType().Name}. Message: {ex.Message}");
                MessageBox.Show($"An unexpected error occurred while creating rule '{rule?.Name}'.\n\nError: {ex.Message}", "Rule Creation Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
            }
            finally
            {
                if (rule != null) Marshal.ReleaseComObject(rule);
                if (rulesCollection != null) Marshal.ReleaseComObject(rulesCollection);
                if (firewallPolicy != null) Marshal.ReleaseComObject(firewallPolicy);
            }
        }


        public List<string> DeleteRulesByDescription(string description)
        {
            if (string.IsNullOrEmpty(description)) return [];

            var rulesToRemove = new List<string>();
            var allRules = GetAllRules();
            var rulesToRelease = new List<INetFwRule2>();
            var rulesToKeepForRelease = new List<INetFwRule2>();

            try
            {
                foreach (var rule in allRules)
                {
                    if (rule != null && string.Equals(rule.Description, description, StringComparison.OrdinalIgnoreCase))
                    {
                        rulesToRemove.Add(rule.Name);
                        rulesToKeepForRelease.Add(rule);
                    }
                    else if (rule != null)
                    {
                        rulesToRelease.Add(rule);
                    }
                }
            }
            finally
            {
                foreach (var rule in rulesToRelease)
                {
                    Marshal.ReleaseComObject(rule);
                }
                foreach (var rule in rulesToKeepForRelease)
                {
                    Marshal.ReleaseComObject(rule);
                }
            }

            DeleteRulesByName(rulesToRemove);
            return rulesToRemove;
        }

        public List<string> DeleteRulesByGroup(string groupName)
        {
            if (string.IsNullOrEmpty(groupName)) return [];

            var rulesToRemove = new List<string>();
            var allRules = GetAllRules();
            var rulesToRelease = new List<INetFwRule2>();
            var rulesToKeepForRelease = new List<INetFwRule2>();

            try
            {
                foreach (var rule in allRules)
                {
                    if (rule != null && string.Equals(rule.Grouping, groupName, StringComparison.OrdinalIgnoreCase))
                    {
                        rulesToRemove.Add(rule.Name);
                        rulesToKeepForRelease.Add(rule);
                    }
                    else if (rule != null)
                    {
                        rulesToRelease.Add(rule);
                    }
                }
            }
            finally
            {
                foreach (var rule in rulesToRelease)
                {
                    Marshal.ReleaseComObject(rule);
                }
                foreach (var rule in rulesToKeepForRelease)
                {
                    Marshal.ReleaseComObject(rule);
                }
            }

            DeleteRulesByName(rulesToRemove);
            return rulesToRemove;
        }


        public void DeleteAllMfwRules()
        {
            var rulesToRemove = new List<string>();
            var allRules = GetAllRules();
            var rulesToRelease = new List<INetFwRule2>();
            var rulesToKeepForRelease = new List<INetFwRule2>();


            try
            {
                foreach (var rule in allRules)
                {
                    if (rule != null && !string.IsNullOrEmpty(rule.Grouping) &&
                        (rule.Grouping.EndsWith(MFWConstants.MfwRuleSuffix) ||
                         rule.Grouping == MFWConstants.MainRuleGroup ||
                         rule.Grouping == MFWConstants.WildcardRuleGroup))
                    {
                        rulesToRemove.Add(rule.Name);
                        rulesToKeepForRelease.Add(rule);
                    }
                    else if (rule != null)
                    {
                        rulesToRelease.Add(rule);
                    }
                }
                Debug.WriteLine($"[INFO] DeleteAllMfwRules: Identified {rulesToRemove.Count} MFW rules for deletion.");
            }
            finally
            {
                foreach (var rule in rulesToRelease)
                {
                    Marshal.ReleaseComObject(rule);
                }
                foreach (var rule in rulesToKeepForRelease)
                {
                    Marshal.ReleaseComObject(rule);
                }
            }

            if (rulesToRemove.Any())
            {
                DeleteRulesByName(rulesToRemove);
                Debug.WriteLine($"[INFO] DeleteAllMfwRules: Requested deletion of {rulesToRemove.Count} MFW rules.");
            }
            else
            {
                Debug.WriteLine("[INFO] DeleteAllMfwRules: No MFW rules found to delete.");
            }
        }

    }
}


--------------------------------------------------
// Full Path: C:/Users/anon/PROGRAMMING/C#/SimpleFirewall/VS Minimal Firewall/MinimalFirewall-NET8/Backups/v2.5.5 - ws/2.5.5.6 - security vulnerability fix 3/FirewallSentryService.cs
--------------------------------------------------------------------------------
// File: FirewallSentryService.cs
using System.Management;
using System.Runtime.InteropServices;

namespace MinimalFirewall
{
    public partial class FirewallSentryService : IDisposable
    {
        private readonly FirewallRuleService firewallService;
        private ManagementEventWatcher? _watcher;
        private bool _isStarted = false;
        public event Action? RuleSetChanged;
        public FirewallSentryService(FirewallRuleService firewallService)
        {
            this.firewallService = firewallService;
        }

        public void Start()
        {
            if (_isStarted)
            {
                return;
            }

            try
            {
                var scope = new ManagementScope(@"root\StandardCimv2");
                var query = new WqlEventQuery(
                    "SELECT * FROM __InstanceOperationEvent WITHIN 1 " +
                    "WHERE TargetInstance ISA 'MSFT_NetFirewallRule'");
                _watcher = new ManagementEventWatcher(scope, query);
                _watcher.EventArrived += OnFirewallRuleChangeEvent;
                _watcher.Start();
                _isStarted = true;
            }
            catch (ManagementException ex)
            {
                System.Diagnostics.Debug.WriteLine($"[SENTRY ERROR] Failed to start WMI watcher: {ex.Message}");
            }
        }

        public void Stop()
        {
            if (!_isStarted)
            {
                return;
            }

            try
            {
                _watcher?.Stop();
                _watcher?.Dispose();
                _watcher = null;
                _isStarted = false;
            }
            catch (ManagementException ex)
            {
                System.Diagnostics.Debug.WriteLine($"[SENTRY ERROR] Failed to stop WMI watcher: {ex.Message}");
            }
        }

        private void OnFirewallRuleChangeEvent(object sender, EventArrivedEventArgs e)
        {
            RuleSetChanged?.Invoke();
        }

        public List<FirewallRuleChange> CheckForChanges(ForeignRuleTracker acknowledgedTracker, IProgress<int>? progress = null, CancellationToken token = default)
        {
            var changes = new List<FirewallRuleChange>();
            var allRules = firewallService.GetAllRules();
            try
            {
                int totalRules = allRules.Count;
                if (totalRules == 0)
                {
                    progress?.Report(100);
                    return changes;
                }
                int processedRules = 0;
                foreach (var rule in allRules)
                {
                    if (token.IsCancellationRequested) return new List<FirewallRuleChange>();
                    processedRules++;
                    progress?.Report((processedRules * 100) / totalRules);

                    if (rule == null || string.IsNullOrEmpty(rule.Name)) continue;
                    if (IsMfwRule(rule) || acknowledgedTracker.IsAcknowledged(rule.Name))
                    {
                        continue;
                    }

                    changes.Add(new FirewallRuleChange { Type = ChangeType.New, Rule = FirewallDataService.CreateAdvancedRuleViewModel(rule) });
                }
            }
            finally
            {
                foreach (var rule in allRules)
                {
                    if (rule != null) Marshal.ReleaseComObject(rule);
                }
            }
            return changes;
        }

        private static bool IsMfwRule(NetFwTypeLib.INetFwRule2 rule)
        {
            if (string.IsNullOrEmpty(rule.Grouping)) return false;
            return rule.Grouping.EndsWith(MFWConstants.MfwRuleSuffix) ||
                   rule.Grouping == MFWConstants.MainRuleGroup ||
                   rule.Grouping == MFWConstants.WildcardRuleGroup;
        }

        public void Dispose()
        {
            Stop();
            GC.SuppressFinalize(this);
        }
    }
}

--------------------------------------------------
// Full Path: C:/Users/anon/PROGRAMMING/C#/SimpleFirewall/VS Minimal Firewall/MinimalFirewall-NET8/Backups/v2.5.5 - ws/2.5.5.6 - security vulnerability fix 3/FirewallTraffic.cs
--------------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Diagnostics;
using System.Net;
using System.Runtime.InteropServices;
using System.Threading;
using System.Threading.Tasks;
using System.Windows.Forms;
using System.Windows.Input;
using System.Linq;
using MinimalFirewall;
using MinimalFirewall.TypedObjects;

namespace Firewall.Traffic
{
    public static partial class TcpTrafficTracker
    {
        private const uint AF_INET = 2;
        private const uint AF_INET6 = 23;
        private const uint ERROR_INSUFFICIENT_BUFFER = 122;

        [LibraryImport("iphlpapi.dll", SetLastError = true)]
        private static partial uint GetExtendedTcpTable(IntPtr pTcpTable, ref uint pdwSize, [MarshalAs(UnmanagedType.Bool)] bool bOrder, uint ulAf, int TableClass, uint Reserved);
        public static List<TcpTrafficRow> GetConnections()
        {
            var connections = new List<TcpTrafficRow>();
            connections.AddRange(GetConnectionsForFamily(AF_INET));
            connections.AddRange(GetConnectionsForFamily(AF_INET6));
            return connections;
        }

        public static string GetStateString(uint state)
        {
            return state switch
            {
                1 => "Closed",
                2 => "Listen",
                3 => "Syn-Sent",
                4 => "Syn-Rcvd",
                5 => "Established",
                6 => "Fin-Wait-1",
                7 => "Fin-Wait-2",
                8 => "Close-Wait",
                9 => "Closing",
                10 => "Last-Ack",
                11 => "Time-Wait",
                12 => "Delete-Tcb",
                _ => "Unknown",
            };
        }

        private static List<TcpTrafficRow> GetConnectionsForFamily(uint family)
        {
            IntPtr pTcpTable = IntPtr.Zero;
            uint pdwSize = 0;
            uint retVal = GetExtendedTcpTable(pTcpTable, ref pdwSize, true, family, 5, 0);

            if (retVal != 0 && retVal != ERROR_INSUFFICIENT_BUFFER)
            {
                int error = Marshal.GetLastWin32Error();
                Debug.WriteLine($"[ERROR] GetExtendedTcpTable failed on initial call with error code: {retVal}, Win32 Error: {error}");
                return [];
            }

            pTcpTable = Marshal.AllocHGlobal((int)pdwSize);
            try
            {
                retVal = GetExtendedTcpTable(pTcpTable, ref pdwSize, true, family, 5, 0);
                if (retVal == 0)
                {
                    int rowCount = Marshal.ReadInt32(pTcpTable);
                    var connections = new List<TcpTrafficRow>(rowCount);
                    IntPtr rowPtr = pTcpTable + Marshal.SizeOf<int>();

                    for (int i = 0; i < rowCount; i++)
                    {
                        if (family == AF_INET)
                        {
                            var rowStructure = Marshal.PtrToStructure<MIB_TCPROW_OWNER_PID>(rowPtr);
                            connections.Add(new TcpTrafficRow(rowStructure));
                            rowPtr += Marshal.SizeOf<MIB_TCPROW_OWNER_PID>();
                        }
                        else
                        {
                            var rowStructure = Marshal.PtrToStructure<MIB_TCP6ROW_OWNER_PID>(rowPtr);
                            connections.Add(new TcpTrafficRow(rowStructure));
                            rowPtr += Marshal.SizeOf<MIB_TCP6ROW_OWNER_PID>();
                        }
                    }
                    return connections;
                }
                else
                {
                    int error = Marshal.GetLastWin32Error();
                    Debug.WriteLine($"[ERROR] GetExtendedTcpTable failed on second call with error code: {retVal}, Win32 Error: {error}");
                }
            }
            finally
            {
                if (pTcpTable != IntPtr.Zero)
                {
                    Marshal.FreeHGlobal(pTcpTable);
                }
            }
            return [];
        }

        #region Native Structures
        public readonly struct TcpTrafficRow : IEquatable<TcpTrafficRow>
        {
            public readonly IPEndPoint LocalEndPoint;
            public readonly IPEndPoint RemoteEndPoint;
            public readonly uint ProcessId;
            public readonly uint State;

            public TcpTrafficRow(MIB_TCPROW_OWNER_PID row)
            {
                LocalEndPoint = new IPEndPoint(row.localAddr, (ushort)IPAddress.NetworkToHostOrder((short)row.localPort));
                RemoteEndPoint = new IPEndPoint(row.remoteAddr, (ushort)IPAddress.NetworkToHostOrder((short)row.remotePort));
                ProcessId = row.owningPid;
                State = row.state;
            }

            public TcpTrafficRow(MIB_TCP6ROW_OWNER_PID row)
            {
                LocalEndPoint = new IPEndPoint(new IPAddress(row.localAddr, row.localScopeId), (ushort)IPAddress.NetworkToHostOrder((short)row.localPort));
                RemoteEndPoint = new IPEndPoint(new IPAddress(row.remoteAddr, row.remoteScopeId), (ushort)IPAddress.NetworkToHostOrder((short)row.remotePort));
                ProcessId = row.owningPid;
                State = row.state;
            }

            public bool Equals(TcpTrafficRow other)
            {
                return LocalEndPoint.Equals(other.LocalEndPoint) &&
                       RemoteEndPoint.Equals(other.RemoteEndPoint) &&
                       ProcessId == other.ProcessId &&
                       State == other.State;
            }

            public override bool Equals(object? obj)
            {
                return obj is TcpTrafficRow other && Equals(other);
            }

            public override int GetHashCode()
            {
                return HashCode.Combine(LocalEndPoint, RemoteEndPoint, ProcessId, State);
            }
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct MIB_TCPROW_OWNER_PID
        {
            public uint state;
            public uint localAddr;
            public uint localPort;
            public uint remoteAddr;
            public uint remotePort;
            public uint owningPid;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct MIB_TCP6ROW_OWNER_PID
        {
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 16)]
            public byte[] localAddr;
            public uint localScopeId;
            public uint localPort;
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 16)]
            public byte[] remoteAddr;
            public uint remoteScopeId;
            public uint remotePort;
            public uint state;
            public uint owningPid;
        }
        #endregion
    }
}

namespace Firewall.Traffic.ViewModels
{
    public class TcpConnectionViewModel : INotifyPropertyChanged
    {
        private readonly BackgroundFirewallTaskService _backgroundTaskService;
        public TcpTrafficTracker.TcpTrafficRow Connection { get; }
        public string ProcessName { get; private set; }
        public string ProcessPath { get; private set; }
        public string ServiceName { get; private set; }

        public string DisplayName => string.IsNullOrEmpty(ServiceName) ? ProcessName : $"{ProcessName} ({ServiceName})";
        public string LocalAddress => Connection.LocalEndPoint.Address.ToString();
        public int LocalPort => Connection.LocalEndPoint.Port;
        public string RemoteAddress => Connection.RemoteEndPoint.Address.ToString();
        public int RemotePort => Connection.RemoteEndPoint.Port;
        public string State => TcpTrafficTracker.GetStateString(Connection.State);

        public ICommand KillProcessCommand { get; }
        public ICommand BlockRemoteIpCommand { get; }

        public TcpConnectionViewModel(TcpTrafficTracker.TcpTrafficRow connection, (string Name, string Path, string ServiceName) processInfo, BackgroundFirewallTaskService backgroundTaskService)
        {
            Connection = connection;
            ProcessName = processInfo.Name;
            ProcessPath = processInfo.Path;
            ServiceName = processInfo.ServiceName;
            _backgroundTaskService = backgroundTaskService;
            KillProcessCommand = new RelayCommand(KillProcess, CanKillProcess);
            BlockRemoteIpCommand = new RelayCommand(BlockIp, () => true);
        }

        private void KillProcess()
        {
            try
            {
                var process = Process.GetProcessById((int)Connection.ProcessId);
                process.Kill();
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Failed to kill process: {ex.Message}", "Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
            }
        }

        private bool CanKillProcess() => !ProcessName.Equals("System", StringComparison.OrdinalIgnoreCase);

        private void BlockIp()
        {
            if (_backgroundTaskService == null) return;

            var rule = new AdvancedRuleViewModel
            {
                Name = $"Block Remote IP - {RemoteAddress}",
                Description = $"Blocked remote IP {RemoteAddress} initiated from '{DisplayName}' via Live Connections.",
                IsEnabled = true,
                Grouping = MFWConstants.MainRuleGroup,
                Status = "Block",
                Direction = Directions.Incoming | Directions.Outgoing,
                Protocol = (int)MinimalFirewall.TypedObjects.ProtocolTypes.Any.Value,
                LocalPorts = "*",
                RemotePorts = "*",
                LocalAddresses = "*",
                RemoteAddresses = RemoteAddress,
                Profiles = "All",
                Type = RuleType.Advanced,
                InterfaceTypes = "All",
                IcmpTypesAndCodes = "*"
            };

            var payload = new CreateAdvancedRulePayload { ViewModel = rule, InterfaceTypes = rule.InterfaceTypes, IcmpTypesAndCodes = rule.IcmpTypesAndCodes };
            _backgroundTaskService.EnqueueTask(new FirewallTask(FirewallTaskType.CreateAdvancedRule, payload));

            MessageBox.Show($"Firewall rule queued to block all traffic to/from {RemoteAddress}.", "Rule Queued", MessageBoxButtons.OK, MessageBoxIcon.Information);
        }

        public event PropertyChangedEventHandler? PropertyChanged;
        private void OnPropertyChanged(string name) => PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(name));
    }

    public class TrafficMonitorViewModel
    {
        public ObservableCollection<TcpConnectionViewModel> ActiveConnections { get; } = new ObservableCollection<TcpConnectionViewModel>();

        public void StopMonitoring()
        {
            ActiveConnections.Clear();
        }
    }

    public class RelayCommand : ICommand
    {
        private readonly Action _execute;
        private readonly Func<bool> _canExecute;

        public event EventHandler? CanExecuteChanged;

        public RelayCommand(Action execute, Func<bool> canExecute)
        {
            _execute = execute ?? throw new ArgumentNullException(nameof(execute));
            _canExecute = canExecute ?? throw new ArgumentNullException(nameof(canExecute));
        }

        public bool CanExecute(object? parameter) => _canExecute();
        public void Execute(object? parameter) => _execute();

        public void RaiseCanExecuteChanged()
        {
            CanExecuteChanged?.Invoke(this, EventArgs.Empty);
        }
    }
}

--------------------------------------------------
// Full Path: C:/Users/anon/PROGRAMMING/C#/SimpleFirewall/VS Minimal Firewall/MinimalFirewall-NET8/Backups/v2.5.5 - ws/2.5.5.6 - security vulnerability fix 3/FlatComboBox.cs
--------------------------------------------------------------------------------
// File: FlatComboBox.cs
using System;
using System.ComponentModel;
using System.Drawing;
using System.Runtime.InteropServices;
using System.Windows.Forms;

namespace DarkModeForms
{

    public class FlatComboBox : ComboBox
    {
        private Color borderColor = Color.Gray;
        [DefaultValue(typeof(Color), "Gray")]
        public Color BorderColor
        {
            get { return borderColor; }
            set
            {
                if (borderColor != value)
                {
                    borderColor = value;
                    Invalidate();
                }
            }
        }

        private Color buttonColor = Color.LightGray;
        [DefaultValue(typeof(Color), "LightGray")]
        public Color ButtonColor
        {
            get { return buttonColor; }
            set
            {
                if (buttonColor != value)
                {
                    buttonColor = value;
                    Invalidate();
                }
            }
        }

        private int Scale(int value, Graphics g) => (int)(value * (g.DpiX / 96f));
        protected override void WndProc(ref Message m)
        {
            if (m.Msg == WM_PAINT && DropDownStyle != ComboBoxStyle.Simple)
            {
                var clientRect = ClientRectangle;
                var dropDownButtonWidth = SystemInformation.HorizontalScrollBarArrowWidth;
                var outerBorder = new Rectangle(clientRect.Location,
                    new Size(clientRect.Width - 1, clientRect.Height - 1));
                var innerBorder = new Rectangle(outerBorder.X + 1, outerBorder.Y + 1,
                    outerBorder.Width - dropDownButtonWidth - 2, outerBorder.Height - 2);
                var innerInnerBorder = new Rectangle(innerBorder.X + 1, innerBorder.Y + 1,
                    innerBorder.Width - 2, innerBorder.Height - 2);
                var dropDownRect = new Rectangle(innerBorder.Right + 1, innerBorder.Y - 1,
                    dropDownButtonWidth, innerBorder.Height + 2);
                if (RightToLeft == RightToLeft.Yes)
                {
                    innerBorder.X = clientRect.Width - innerBorder.Right;
                    innerInnerBorder.X = clientRect.Width - innerInnerBorder.Right;
                    dropDownRect.X = clientRect.Width - dropDownRect.Right;
                    dropDownRect.Width += 1;
                }
                var innerBorderColor = Enabled ? BackColor : SystemColors.Control;
                var outerBorderColor = Enabled ? BorderColor : SystemColors.ControlDark;
                var buttonColor1 = Enabled ? ButtonColor : SystemColors.Control;
                var middle = new Point(dropDownRect.Left + dropDownRect.Width / 2,
                    dropDownRect.Top + dropDownRect.Height / 2);
                var arrow = new Point[]
                {
            new Point(middle.X - 3, middle.Y - 2),
            new Point(middle.X + 4, middle.Y - 2),
            new Point(middle.X, middle.Y + 2)
                };
                var ps = new PAINTSTRUCT();
                bool shoulEndPaint = false;
                IntPtr dc;
                if (m.WParam == IntPtr.Zero)
                {
                    dc = BeginPaint(Handle, ref ps);
                    m.WParam = dc;
                    shoulEndPaint = true;
                }
                else
                {
                    dc = m.WParam;
                }
                var rgn = CreateRectRgn(innerInnerBorder.Left, innerInnerBorder.Top,
                    innerInnerBorder.Right, innerInnerBorder.Bottom);
                SelectClipRgn(dc, rgn);
                DefWndProc(ref m);
                DeleteObject(rgn);
                rgn = CreateRectRgn(clientRect.Left, clientRect.Top,
                    clientRect.Right, clientRect.Bottom);
                SelectClipRgn(dc, rgn);

                using (var g = Graphics.FromHdc(dc))
                {
                    g.InterpolationMode = System.Drawing.Drawing2D.InterpolationMode.HighQualityBilinear;
                    g.CompositingQuality = System.Drawing.Drawing2D.CompositingQuality.HighQuality;
                    g.SmoothingMode = System.Drawing.Drawing2D.SmoothingMode.AntiAlias;

                    #region DropDown Button

                    using (var b = new SolidBrush(buttonColor1))
                    {
                        g.FillRectangle(b, dropDownRect);
                    }

                    #endregion DropDown Button

                    #region Chevron

                    Size cSize = new Size(Scale(8, g), Scale(4, g));
                    var chevron = new Point[]
                    {
                        new Point(middle.X - (cSize.Width / 2), middle.Y - (cSize.Height / 2)),
                        new Point(middle.X + (cSize.Width / 2), middle.Y - (cSize.Height / 2)),
                        new Point(middle.X, middle.Y + (cSize.Height / 2))
                    };
                    using (var chevronPen = new Pen(BorderColor, 2.5f))
                    {
                        g.DrawLine(chevronPen, chevron[0], chevron[2]);
                        g.DrawLine(chevronPen, chevron[1], chevron[2]);
                    }

                    #endregion Chevron

                    #region Borders

                    using (var p = new Pen(innerBorderColor))
                    {
                        g.DrawRectangle(p, innerBorder);
                        g.DrawRectangle(p, innerInnerBorder);
                    }
                    using (var p = new Pen(outerBorderColor))
                    {
                        g.DrawRectangle(p, outerBorder);
                    }

                    #endregion Borders
                }
                if (shoulEndPaint)
                    EndPaint(Handle, ref ps);
                DeleteObject(rgn);
            }
            else
                base.WndProc(ref m);
        }

        private const int WM_PAINT = 0xF;
        [StructLayout(LayoutKind.Sequential)]
        public struct RECT
        {
            public int L, T, R, B;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct PAINTSTRUCT
        {
            public IntPtr hdc;
            public bool fErase;
            public int rcPaint_left;
            public int rcPaint_top;
            public int rcPaint_right;
            public int rcPaint_bottom;
            public bool fRestore;
            public bool fIncUpdate;
            public int reserved1;
            public int reserved2;
            public int reserved3;
            public int reserved4;
            public int reserved5;
            public int reserved6;
            public int reserved7;
            public int reserved8;
        }

        [DllImport("user32.dll")]
        private static extern IntPtr BeginPaint(IntPtr hWnd,
            [In, Out] ref PAINTSTRUCT lpPaint);
        [DllImport("user32.dll")]
        private static extern bool EndPaint(IntPtr hWnd, ref PAINTSTRUCT lpPaint);
        [DllImport("gdi32.dll")]
        public static extern int SelectClipRgn(IntPtr hDC, IntPtr hRgn);
        [DllImport("user32.dll")]
        public static extern int GetUpdateRgn(IntPtr hwnd, IntPtr hrgn, bool fErase);
        public enum RegionFlags
        {
            ERROR = 0,
            NULLREGION = 1,
            SIMPLEREGION = 2,
            COMPLEXREGION = 3,
        }

        [DllImport("gdi32.dll")]
        internal static extern bool DeleteObject(IntPtr hObject);
        [DllImport("gdi32.dll")]
        private static extern IntPtr CreateRectRgn(int x1, int y1, int x2, int y2);
    }
}

--------------------------------------------------
// Full Path: C:/Users/anon/PROGRAMMING/C#/SimpleFirewall/VS Minimal Firewall/MinimalFirewall-NET8/Backups/v2.5.5 - ws/2.5.5.6 - security vulnerability fix 3/FlatProgressBar.cs
--------------------------------------------------------------------------------
// File: FlatProgressBar.cs
using System;
using System.Drawing;
using System.Windows.Forms;
using Timer = System.Windows.Forms.Timer;

namespace DarkModeForms
{
    public class FlatProgressBar : ProgressBar
    {
        private Timer marqueeTimer;
        private int marqueePosition = 0;
        private ProgressBarStyle style = ProgressBarStyle.Blocks;
        public new ProgressBarStyle Style
        {
            get { return style; }
            set
            {
                style = value;
                if (style == ProgressBarStyle.Marquee)
                {
                    marqueeTimer.Start();
                }
                else
                {
                    marqueeTimer.Stop();
                }
                this.Invalidate();
            }
        }

        public FlatProgressBar()
        {
            this.SetStyle(ControlStyles.UserPaint, true);
            this.SetStyle(ControlStyles.OptimizedDoubleBuffer, true);
            marqueeTimer = new Timer();
            marqueeTimer.Interval = 30;
            marqueeTimer.Tick += MarqueeTimer_Tick;
        }

        private void MarqueeTimer_Tick(object? sender, EventArgs e)
        {
            marqueePosition += 5;
            if (marqueePosition > this.Width)
            {
                marqueePosition = -100;
            }
            this.Invalidate();
        }

        protected override void OnPaintBackground(PaintEventArgs pevent)
        {
        }

        int min = 0;
        int max = 100;
        int val = 0;
        Color BarColor = Color.Green;
        protected override void OnResize(EventArgs e)
        {
            this.Invalidate();
        }

        protected override void OnPaint(PaintEventArgs e)
        {
            Graphics g = e.Graphics;
            using (SolidBrush brush = new SolidBrush(BarColor))
            using (Brush BackBrush = new SolidBrush(this.BackColor))
            {
                g.FillRectangle(BackBrush, this.ClientRectangle);
                if (Style == ProgressBarStyle.Marquee)
                {
                    int marqueeWidth = this.Width / 4;
                    Rectangle marqueeRect = new Rectangle(marqueePosition, 0, marqueeWidth, this.Height);
                    g.FillRectangle(brush, marqueeRect);
                }
                else
                {
                    float percent = (float)(val - min) / (float)(max - min);
                    Rectangle rect = this.ClientRectangle;
                    rect.Width = (int)((float)rect.Width * percent);
                    g.FillRectangle(brush, rect);
                }

                Draw3DBorder(g);
            }
        }

        public new int Minimum
        {
            get
            {
                return min;
            }

            set
            {
                if (value < 0)
                {
                    value = 0;
                }

                if (value > max)
                {
                    max = value;
                }

                min = value;
                if (val < min)
                {
                    val = min;
                }

                this.Invalidate();
            }
        }

        public new int Maximum
        {
            get
            {
                return max;
            }

            set
            {
                if (value < min)
                {
                    min = value;
                }

                max = value;
                if (val > max)
                {
                    val = max;
                }

                this.Invalidate();
            }
        }

        public new int Value
        {
            get
            {
                return val;
            }

            set
            {
                int oldValue = val;
                if (value < min)
                {
                    val = min;
                }
                else if (value > max)
                {
                    val = max;
                }
                else
                {
                    val = value;
                }

                float percent;
                Rectangle newValueRect = this.ClientRectangle;
                Rectangle oldValueRect = this.ClientRectangle;

                percent = (float)(val - min) / (float)(max - min);
                newValueRect.Width = (int)((float)newValueRect.Width * percent);

                percent = (float)(oldValue - min) / (float)(max - min);
                oldValueRect.Width = (int)((float)oldValueRect.Width * percent);
                Rectangle updateRect = new Rectangle();

                if (newValueRect.Width > oldValueRect.Width)
                {
                    updateRect.X = oldValueRect.Size.Width;
                    updateRect.Width = newValueRect.Width - oldValueRect.Width;
                }
                else
                {
                    updateRect.X = newValueRect.Size.Width;
                    updateRect.Width = oldValueRect.Width - newValueRect.Width;
                }

                updateRect.Height = this.Height;
                this.Invalidate(updateRect);
            }
        }

        public Color ProgressBarColor
        {
            get
            {
                return BarColor;
            }

            set
            {
                BarColor = value;
                this.Invalidate();
            }
        }

        private void Draw3DBorder(Graphics g)
        {
            int PenWidth = (int)Pens.White.Width;
            g.DrawLine(Pens.DarkGray,
                new Point(this.ClientRectangle.Left, this.ClientRectangle.Top),
                new Point(this.ClientRectangle.Width - PenWidth, this.ClientRectangle.Top));
            g.DrawLine(Pens.DarkGray,
                new Point(this.ClientRectangle.Left, this.ClientRectangle.Top),
                new Point(this.ClientRectangle.Left, this.ClientRectangle.Height - PenWidth));
            g.DrawLine(Pens.DarkGray,
                new Point(this.ClientRectangle.Left, this.ClientRectangle.Height - PenWidth),
                new Point(this.ClientRectangle.Width - PenWidth, this.ClientRectangle.Height - PenWidth));
            g.DrawLine(Pens.DarkGray,
                new Point(this.ClientRectangle.Width - PenWidth, this.ClientRectangle.Top),
                new Point(this.ClientRectangle.Width - PenWidth, this.ClientRectangle.Height - PenWidth));
        }

        protected override void Dispose(bool disposing)
        {
            if (disposing)
            {
                marqueeTimer?.Dispose();
            }
            base.Dispose(disposing);
        }
    }
}

--------------------------------------------------
// Full Path: C:/Users/anon/PROGRAMMING/C#/SimpleFirewall/VS Minimal Firewall/MinimalFirewall-NET8/Backups/v2.5.5 - ws/2.5.5.6 - security vulnerability fix 3/FlatTabControl.cs
--------------------------------------------------------------------------------
// File: FlatTabControl.cs
using System.ComponentModel;
using System.Drawing;
using System.Windows.Forms;
using System.Drawing.Drawing2D;

namespace DarkModeForms
{
    public class FlatTabControl : TabControl
    {
        [Description("Color for a decorative line"), Category("Appearance")]
        public Color LineColor { get; set; } = SystemColors.Highlight;

        [Description("Color for all Borders"), Category("Appearance")]
        public Color BorderColor { get; set; } = SystemColors.ControlDark;

        [Description("Back color for selected Tab"), Category("Appearance")]
        public Color SelectTabColor { get; set; } = SystemColors.ControlLight;

        [Description("Fore Color for Selected Tab"), Category("Appearance")]
        public Color SelectedForeColor { get; set; } = SystemColors.HighlightText;

        [Description("Back Color for un-selected tabs"), Category("Appearance")]
        public Color TabColor { get; set; } = SystemColors.ControlLight;

        [Description("Background color for the whole control"), Category("Appearance"), Browsable(true)]
        public override Color BackColor { get; set; } = SystemColors.Control;

        [Description("Fore Color for all Texts"), Category("Appearance")]
        public override Color ForeColor { get; set; } = SystemColors.ControlText;

        public FlatTabControl()
        {
            try
            {
                this.DrawMode = TabDrawMode.OwnerDrawFixed;
            }
            catch { }
        }

        private int Scale(int value, Graphics g) => (int)(value * (g.DpiX / 96f));
        protected override void OnPaint(PaintEventArgs e)
        {
            base.OnPaint(e);
            DrawControl(e.Graphics);
        }

        internal void DrawControl(Graphics g)
        {
            try
            {
                if (!Visible)
                {
                    return;
                }

                using (Brush bBackColor = new SolidBrush(this.BackColor))
                {
                    g.FillRectangle(bBackColor, this.ClientRectangle);
                }

                for (int i = 0; i < this.TabCount; i++)
                {
                    DrawTab(g, this.TabPages[i], i);
                }
            }
            catch { }
        }

        internal void DrawTab(Graphics g, TabPage customTabPage, int nIndex)
        {
            Rectangle tabRect = this.GetTabRect(nIndex);
            bool isSelected = (this.SelectedIndex == nIndex);

            g.SmoothingMode = SmoothingMode.AntiAlias;

            if (this.Alignment == TabAlignment.Left)
            {
                Color tabBackColor = isSelected ? SelectTabColor : this.TabColor;

                using (Brush b = new SolidBrush(tabBackColor))
                {
                    g.FillRectangle(b, tabRect);
                }
                using (Pen p = new Pen(this.BorderColor))
                {
                    g.DrawRectangle(p, tabRect.X, tabRect.Y, tabRect.Width, tabRect.Height - Scale(1, g));
                }

                if (this.ImageList != null && customTabPage.ImageIndex >= 0 && customTabPage.ImageIndex < this.ImageList.Images.Count)
                {
                    Image? icon = this.ImageList.Images[customTabPage.ImageIndex];
                    if (icon != null)
                    {
                        int iconHeight = this.ImageList.ImageSize.Height;
                        int iconWidth = this.ImageList.ImageSize.Width;
                        int iconX = tabRect.X + (tabRect.Width - iconWidth) / 2;
                        int iconY = tabRect.Y + (tabRect.Height - iconHeight) / 2;
                        g.DrawImage(icon, new Rectangle(iconX, iconY, iconWidth, iconHeight));
                    }
                }

                if (isSelected)
                {
                    using (Pen p = new Pen(this.LineColor, Scale(2, g)))
                    {
                        g.DrawLine(p, tabRect.Right - Scale(1, g), tabRect.Top, tabRect.Right - Scale(1, g), tabRect.Bottom - Scale(1, g));
                    }
                }
            }
            else
            {
                int scaled3 = Scale(3, g);
                Point[] points;
                points = new[]
                {
                    new Point(tabRect.Left, tabRect.Bottom),
                    new Point(tabRect.Left, tabRect.Top + scaled3),
                    new Point(tabRect.Left + scaled3, tabRect.Top),
                    new Point(tabRect.Right - scaled3, tabRect.Top),
                    new Point(tabRect.Right, tabRect.Top + scaled3),
                    new Point(tabRect.Right, tabRect.Bottom),
                    new Point(tabRect.Left, tabRect.Bottom)
                };
                using (Brush brush = new SolidBrush(isSelected ? SelectTabColor : this.TabColor))
                {
                    g.FillPolygon(brush, points);
                    using (Pen borderPen = new Pen(this.BorderColor))
                    {
                        g.DrawPolygon(borderPen, points);
                    }
                }

                if (isSelected)
                {
                    g.DrawLine(new Pen(SelectTabColor, Scale(2, g)), new Point(tabRect.Left, tabRect.Bottom), new Point(tabRect.Right, tabRect.Bottom));
                }

                TextRenderer.DrawText(g, customTabPage.Text, Font, tabRect, isSelected ? SelectedForeColor : ForeColor, TextFormatFlags.HorizontalCenter | TextFormatFlags.VerticalCenter);
            }
        }
    }
}

--------------------------------------------------
// Full Path: C:/Users/anon/PROGRAMMING/C#/SimpleFirewall/VS Minimal Firewall/MinimalFirewall-NET8/Backups/v2.5.5 - ws/2.5.5.6 - security vulnerability fix 3/ForeignRuleTracker.cs
--------------------------------------------------------------------------------
// File: ForeignRuleTracker.cs
using System.IO;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.Diagnostics;

namespace MinimalFirewall
{
    public class ForeignRuleTracker
    {
        private readonly string _baselinePath;
        private HashSet<string> _acknowledgedRuleNames = new(StringComparer.OrdinalIgnoreCase);

        public ForeignRuleTracker()
        {
            _baselinePath = ConfigPathManager.GetConfigPath("foreign_rules_baseline.json");
            LoadAcknowledgedRules();
        }

        private void LoadAcknowledgedRules()
        {
            try
            {
                if (File.Exists(_baselinePath))
                {
                    string json = File.ReadAllText(_baselinePath);
                    _acknowledgedRuleNames = JsonSerializer.Deserialize(json, ForeignRuleTrackerJsonContext.Default.HashSetString) ?? new HashSet<string>(StringComparer.OrdinalIgnoreCase);
                }
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"[ERROR] Failed to load foreign rule baseline: {ex.Message}");
                _acknowledgedRuleNames = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
            }
        }

        private void Save()
        {
            try
            {
                string json = JsonSerializer.Serialize(_acknowledgedRuleNames, ForeignRuleTrackerJsonContext.Default.HashSetString);
                File.WriteAllText(_baselinePath, json);
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"[ERROR] Failed to save foreign rule baseline: {ex.Message}");
            }
        }

        public void Clear()
        {
            _acknowledgedRuleNames.Clear();
            Save();
        }

        public bool IsAcknowledged(string ruleName)
        {
            return _acknowledgedRuleNames.Contains(ruleName);
        }

        public void AcknowledgeRules(IEnumerable<string> ruleNames)
        {
            foreach (var name in ruleNames)
            {
                _acknowledgedRuleNames.Add(name);
            }
            Save();
        }
    }

    [JsonSourceGenerationOptions(WriteIndented = true)]
    [JsonSerializable(typeof(HashSet<string>))]
    internal partial class ForeignRuleTrackerJsonContext : JsonSerializerContext { }
}

--------------------------------------------------
// Full Path: C:/Users/anon/PROGRAMMING/C#/SimpleFirewall/VS Minimal Firewall/MinimalFirewall-NET8/Backups/v2.5.5 - ws/2.5.5.6 - security vulnerability fix 3/GroupsControl.cs
--------------------------------------------------------------------------------
// File: GroupsControl.cs
using DarkModeForms;
using MinimalFirewall.Groups;
using System.Windows.Forms;
using System.Threading.Tasks;
using System.Linq;
using System.ComponentModel;
using System.Collections.Generic;
using System;
using System.Drawing;

namespace MinimalFirewall
{
    public partial class GroupsControl : UserControl
    {
        private FirewallGroupManager?
        _groupManager;
        private BackgroundFirewallTaskService? _backgroundTaskService;
        private DarkModeCS? _dm;
        private BindingSource _bindingSource;
        public GroupsControl()
        {
            InitializeComponent();
            this.DoubleBuffered = true;
        }

        public void Initialize(FirewallGroupManager groupManager, BackgroundFirewallTaskService backgroundTaskService, DarkModeCS dm)
        {
            _groupManager = groupManager;
            _backgroundTaskService = backgroundTaskService;
            _dm = dm;

            groupsDataGridView.AutoGenerateColumns = false;
            _bindingSource = new BindingSource();
            groupsDataGridView.DataSource = _bindingSource;
        }

        public void ClearGroups()
        {
            _bindingSource.DataSource = null;
        }

        public async Task OnTabSelectedAsync()
        {
            await DisplayGroupsAsync();
        }

        private async Task DisplayGroupsAsync()
        {
            if (groupsDataGridView is null || _groupManager is null) return;
            var groups = await Task.Run(() => _groupManager.GetAllGroups());
            _bindingSource.DataSource = new SortableBindingList<FirewallGroup>(groups);
            groupsDataGridView.Refresh();
        }

        private void deleteGroupToolStripMenuItem_Click(object sender, EventArgs e)
        {
            if (groupsDataGridView.SelectedRows.Count > 0 && _backgroundTaskService != null)
            {
                var result = MessageBox.Show("Are you sure you want to delete the \nselected group(s) and all associated rules?", "Confirm Deletion", MessageBoxButtons.YesNo, MessageBoxIcon.Warning);
                if (result == DialogResult.Yes)
                {
                    var rowsToDelete = new List<DataGridViewRow>();
                    foreach (DataGridViewRow row in groupsDataGridView.SelectedRows)
                    {
                        if (row.DataBoundItem is FirewallGroup group)

                        {
                            _backgroundTaskService.EnqueueTask(new FirewallTask(FirewallTaskType.DeleteGroup, group.Name));
                            rowsToDelete.Add(row);
                        }
                    }

                    foreach (var row in rowsToDelete)
                    {
                        groupsDataGridView.Rows.Remove(row);
                    }
                }
            }
        }

        private void groupsDataGridView_CellContentClick(object sender, DataGridViewCellEventArgs e)
        {
            if (e.RowIndex >= 0 && e.ColumnIndex == groupsDataGridView.Columns["groupEnabledColumn"].Index)
            {
                if (groupsDataGridView.Rows[e.RowIndex].DataBoundItem is FirewallGroup group && _backgroundTaskService != null)

                {
                    bool newState = !group.IsEnabled;
                    group.SetEnabledState(newState);

                    var payload = new SetGroupEnabledStatePayload { GroupName = group.Name, IsEnabled = newState };
                    _backgroundTaskService.EnqueueTask(new FirewallTask(FirewallTaskType.SetGroupEnabledState, payload));

                    groupsDataGridView.InvalidateCell(e.ColumnIndex, e.RowIndex);
                }
            }
        }

        private void groupsDataGridView_CellPainting(object sender, DataGridViewCellPaintingEventArgs e)
        {
            if (e.RowIndex >= 0 && e.ColumnIndex == groupsDataGridView.Columns["groupEnabledColumn"].Index)
            {
                e.PaintBackground(e.CellBounds, true);
                if (groupsDataGridView.Rows[e.RowIndex].DataBoundItem is FirewallGroup group)
                {
                    DrawToggleSwitch(e.Graphics, e.CellBounds, group.IsEnabled);
                }

                e.Handled = true;
            }
        }

        private void DrawToggleSwitch(Graphics g, Rectangle bounds, bool isChecked)
        {
            if (_dm == null) return;
            int switchWidth = (int)(50 * (g.DpiY / 96f));
            int switchHeight = (int)(25 * (g.DpiY / 96f));
            int thumbSize = (int)(21 * (g.DpiY / 96f));
            int padding = (int)(10 * (g.DpiY / 96f));
            Rectangle switchRect = new Rectangle(
                bounds.X + (bounds.Width - switchWidth) / 2, // Centered
                bounds.Y + (bounds.Height - switchHeight) / 2,
                switchWidth,
                switchHeight);
            g.SmoothingMode = System.Drawing.Drawing2D.SmoothingMode.AntiAlias;

            Color backColor = isChecked ? Color.FromArgb(0, 192, 0) : Color.FromArgb(200, 0, 0);
            using (var path = new System.Drawing.Drawing2D.GraphicsPath())
            {
                path.AddArc(switchRect.X, switchRect.Y, switchRect.Height, switchRect.Height, 90, 180);
                path.AddArc(switchRect.Right - switchRect.Height, switchRect.Y, switchRect.Height, switchRect.Height, 270, 180);
                path.CloseFigure();
                g.FillPath(new SolidBrush(backColor), path);
            }

            int thumbX = isChecked ?
                switchRect.Right - thumbSize - (int)(2 * (g.DpiY / 96f)) : switchRect.X + (int)(2 * (g.DpiY / 96f));
            Rectangle thumbRect = new Rectangle(
                thumbX,
                switchRect.Y + (switchRect.Height - thumbSize) / 2,
                thumbSize,
                thumbSize);
            using (var thumbBrush = new SolidBrush(_dm.OScolors.TextActive))
            {
                g.FillEllipse(thumbBrush, thumbRect);
            }
        }

        private void groupsDataGridView_ColumnHeaderMouseClick(object sender, DataGridViewCellMouseEventArgs e)
        {
            var column = groupsDataGridView.Columns[e.ColumnIndex];
            string propertyName = column.DataPropertyName;

            if (string.IsNullOrEmpty(propertyName)) return;

            var sortDirection = ListSortDirection.Ascending;
            if (groupsDataGridView.SortedColumn?.Name == column.Name && groupsDataGridView.SortOrder == SortOrder.Ascending)
            {
                sortDirection = ListSortDirection.Descending;
            }

            if (_bindingSource.DataSource is SortableBindingList<FirewallGroup> list)
            {
                list.Sort(propertyName, sortDirection);
            }

            groupsDataGridView.Sort(column, sortDirection);
        }

        private void groupsDataGridView_CellMouseDown(object sender, DataGridViewCellMouseEventArgs e)
        {
            if (e.Button == MouseButtons.Right && e.RowIndex >= 0)
            {
                var grid = (DataGridView)sender;
                var clickedRow = grid.Rows[e.RowIndex];

                if (!clickedRow.Selected)
                {
                    grid.ClearSelection();
                    clickedRow.Selected = true;
                }
            }
        }
    }
}

--------------------------------------------------
// Full Path: C:/Users/anon/PROGRAMMING/C#/SimpleFirewall/VS Minimal Firewall/MinimalFirewall-NET8/Backups/v2.5.5 - ws/2.5.5.6 - security vulnerability fix 3/GroupsControl.Designer.cs
--------------------------------------------------------------------------------
// File: GroupsControl.Designer.cs
namespace MinimalFirewall
{
    partial class GroupsControl
    {
        private System.ComponentModel.IContainer components = null;
        private System.Windows.Forms.ContextMenuStrip groupsContextMenu;
        private System.Windows.Forms.ToolStripMenuItem deleteGroupToolStripMenuItem;
        private System.Windows.Forms.DataGridView groupsDataGridView;
        private System.Windows.Forms.DataGridViewTextBoxColumn groupNameColumn;
        private System.Windows.Forms.DataGridViewTextBoxColumn groupEnabledColumn;
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Component Designer generated code
        private void InitializeComponent()
        {
            this.components = new System.ComponentModel.Container();
            System.Windows.Forms.DataGridViewCellStyle dataGridViewCellStyle1 = new System.Windows.Forms.DataGridViewCellStyle();
            this.groupsContextMenu = new System.Windows.Forms.ContextMenuStrip(this.components);
            this.deleteGroupToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.groupsDataGridView = new System.Windows.Forms.DataGridView();
            this.groupNameColumn = new System.Windows.Forms.DataGridViewTextBoxColumn();
            this.groupEnabledColumn = new System.Windows.Forms.DataGridViewTextBoxColumn();
            this.groupsContextMenu.SuspendLayout();
            ((System.ComponentModel.ISupportInitialize)(this.groupsDataGridView)).BeginInit();
            this.SuspendLayout();
            // 
            // groupsContextMenu
            // 
            this.groupsContextMenu.ImageScalingSize = new System.Drawing.Size(20, 20);
            this.groupsContextMenu.Items.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.deleteGroupToolStripMenuItem});
            this.groupsContextMenu.Name = "groupsContextMenu";
            this.groupsContextMenu.Size = new System.Drawing.Size(177, 28);
            // 
            // deleteGroupToolStripMenuItem
            // 
            this.deleteGroupToolStripMenuItem.Name = "deleteGroupToolStripMenuItem";
            this.deleteGroupToolStripMenuItem.Size = new System.Drawing.Size(176, 24);
            this.deleteGroupToolStripMenuItem.Text = "Delete Group...";
            this.deleteGroupToolStripMenuItem.Click += new System.EventHandler(this.deleteGroupToolStripMenuItem_Click);
            // 
            // groupsDataGridView
            // 
            this.groupsDataGridView.AllowUserToAddRows = false;
            this.groupsDataGridView.AllowUserToDeleteRows = false;
            this.groupsDataGridView.AllowUserToResizeRows = false;
            this.groupsDataGridView.AutoSizeColumnsMode = System.Windows.Forms.DataGridViewAutoSizeColumnsMode.Fill;
            this.groupsDataGridView.BackgroundColor = System.Drawing.SystemColors.Control;
            this.groupsDataGridView.BorderStyle = System.Windows.Forms.BorderStyle.None;
            this.groupsDataGridView.CellBorderStyle = System.Windows.Forms.DataGridViewCellBorderStyle.None;
            this.groupsDataGridView.ColumnHeadersBorderStyle = System.Windows.Forms.DataGridViewHeaderBorderStyle.None;
            dataGridViewCellStyle1.Alignment = System.Windows.Forms.DataGridViewContentAlignment.MiddleLeft;
            dataGridViewCellStyle1.BackColor = System.Drawing.SystemColors.Control;
            dataGridViewCellStyle1.Font = new System.Drawing.Font("Segoe UI", 12F);
            dataGridViewCellStyle1.ForeColor = System.Drawing.SystemColors.WindowText;
            dataGridViewCellStyle1.SelectionBackColor = System.Drawing.SystemColors.Highlight;
            dataGridViewCellStyle1.SelectionForeColor = System.Drawing.SystemColors.HighlightText;
            dataGridViewCellStyle1.WrapMode = System.Windows.Forms.DataGridViewTriState.True;
            this.groupsDataGridView.ColumnHeadersDefaultCellStyle = dataGridViewCellStyle1;
            this.groupsDataGridView.ColumnHeadersHeightSizeMode = System.Windows.Forms.DataGridViewColumnHeadersHeightSizeMode.AutoSize;
            this.groupsDataGridView.Columns.AddRange(new System.Windows.Forms.DataGridViewColumn[] {
            this.groupNameColumn,
            this.groupEnabledColumn});
            this.groupsDataGridView.ContextMenuStrip = this.groupsContextMenu;
            this.groupsDataGridView.Dock = System.Windows.Forms.DockStyle.Fill;
            this.groupsDataGridView.EnableHeadersVisualStyles = false;
            this.groupsDataGridView.GridColor = System.Drawing.SystemColors.Control;
            this.groupsDataGridView.Location = new System.Drawing.Point(0, 0);
            this.groupsDataGridView.Name = "groupsDataGridView";
            this.groupsDataGridView.ReadOnly = true;
            this.groupsDataGridView.RowHeadersVisible = false;
            this.groupsDataGridView.RowTemplate.Height = 35;
            this.groupsDataGridView.SelectionMode = System.Windows.Forms.DataGridViewSelectionMode.FullRowSelect;
            this.groupsDataGridView.ShowCellToolTips = true;
            this.groupsDataGridView.Size = new System.Drawing.Size(800, 600);
            this.groupsDataGridView.TabIndex = 1;
            this.groupsDataGridView.CellContentClick += new System.Windows.Forms.DataGridViewCellEventHandler(this.groupsDataGridView_CellContentClick);
            this.groupsDataGridView.CellMouseDown += new System.Windows.Forms.DataGridViewCellMouseEventHandler(this.groupsDataGridView_CellMouseDown);
            this.groupsDataGridView.CellPainting += new System.Windows.Forms.DataGridViewCellPaintingEventHandler(this.groupsDataGridView_CellPainting);
            this.groupsDataGridView.ColumnHeaderMouseClick += new System.Windows.Forms.DataGridViewCellMouseEventHandler(this.groupsDataGridView_ColumnHeaderMouseClick);
            // 
            // groupNameColumn
            // 
            this.groupNameColumn.DataPropertyName = "Name";
            this.groupNameColumn.FillWeight = 80F;
            this.groupNameColumn.HeaderText = "Group Name";
            this.groupNameColumn.Name = "groupNameColumn";
            this.groupNameColumn.ReadOnly = true;
            // 
            // groupEnabledColumn
            // 
            this.groupEnabledColumn.DataPropertyName = "IsEnabled";
            this.groupEnabledColumn.FillWeight = 20F;
            this.groupEnabledColumn.HeaderText = "Enabled";
            this.groupEnabledColumn.Name = "groupEnabledColumn";
            this.groupEnabledColumn.ReadOnly = true;
            // 
            // GroupsControl
            // 
            this.AutoScaleDimensions = new System.Drawing.SizeF(8F, 20F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.Controls.Add(this.groupsDataGridView);
            this.Name = "GroupsControl";
            this.Size = new System.Drawing.Size(800, 600);
            this.groupsContextMenu.ResumeLayout(false);
            ((System.ComponentModel.ISupportInitialize)(this.groupsDataGridView)).EndInit();
            this.ResumeLayout(false);
        }
        #endregion
    }
}

--------------------------------------------------
// Full Path: C:/Users/anon/PROGRAMMING/C#/SimpleFirewall/VS Minimal Firewall/MinimalFirewall-NET8/Backups/v2.5.5 - ws/2.5.5.6 - security vulnerability fix 3/IconService.cs
--------------------------------------------------------------------------------
// File: IconService.cs
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.Drawing;
using System.IO;
using System.Runtime.InteropServices;
using System.Windows.Forms;

namespace MinimalFirewall
{
    public class IconService : Component
    {
        private ImageList? _imageList;
        private readonly Dictionary<string, int> _iconCache = new(StringComparer.OrdinalIgnoreCase);
        private int _defaultIconIndex = -1;
        private int _systemIconIndex = -1;

        #region Native Methods
        [DllImport("shell32.dll", CharSet = CharSet.Auto)]
        private static extern IntPtr SHGetFileInfo(string pszPath, uint dwFileAttributes, ref SHFILEINFO psfi, uint cbFileInfo, uint uFlags);

        [DllImport("user32.dll", CharSet = CharSet.Auto)]
        [return: MarshalAs(UnmanagedType.Bool)]
        private static extern bool DestroyIcon(IntPtr hIcon);

        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Auto)]
        private struct SHFILEINFO
        {
            public IntPtr hIcon;
            public int iIcon;
            public uint dwAttributes;
            [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 260)]
            public string szDisplayName;
            [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 80)]
            public string szTypeName;
        }

        private const uint SHGFI_ICON = 0x000000100;
        private const uint SHGFI_LARGEICON = 0x000000000;
        #endregion

        public ImageList? ImageList
        {
            get => _imageList;
            set
            {
                _imageList = value;
                if (_imageList != null)
                {
                    AddDefaultIcon();
                    AddSystemIcon();
                }
            }
        }

        public IconService() { }

        public IconService(IContainer container)
        {
            container.Add(this);
        }

        private void AddDefaultIcon()
        {
            if (_imageList == null || _imageList.Images.ContainsKey("default")) return;
            try
            {
                var bmp = new Bitmap(32, 32);
                using (var g = Graphics.FromImage(bmp))
                {
                    g.Clear(Color.Transparent);
                }
                _imageList.Images.Add("default", (Bitmap)bmp.Clone());
                bmp.Dispose();
                _defaultIconIndex = _imageList.Images.IndexOfKey("default");
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"[IconService] Failed to create default icon: {ex.Message}");
            }
        }

        private void AddSystemIcon()
        {
            if (_imageList == null || _imageList.Images.ContainsKey("system_icon")) return;
            try
            {
                if (_imageList.Images.ContainsKey("advanced.png"))
                {
                    Image systemImage = _imageList.Images["advanced.png"];
                    _imageList.Images.Add("system_icon", systemImage);
                    _systemIconIndex = _imageList.Images.IndexOfKey("system_icon");
                }
                else
                {
                    _systemIconIndex = _defaultIconIndex;
                }
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"[IconService] Failed to create system icon: {ex.Message}");
                _systemIconIndex = _defaultIconIndex;
            }
        }

        public int GetIconIndex(string? filePath)
        {
            if (string.IsNullOrEmpty(filePath) || _imageList == null)
            {
                return _systemIconIndex;
            }

            if (_iconCache.TryGetValue(filePath, out int cachedIndex))
            {
                return cachedIndex;
            }

            if (!File.Exists(filePath))
            {
                return _systemIconIndex;
            }

            IntPtr hIcon = IntPtr.Zero;
            try
            {
                var shinfo = new SHFILEINFO();
                const uint flags = SHGFI_ICON | SHGFI_LARGEICON;
                SHGetFileInfo(filePath, 0, ref shinfo, (uint)Marshal.SizeOf(shinfo), flags);
                hIcon = shinfo.hIcon;

                if (hIcon != IntPtr.Zero)
                {
                    Icon icon = (Icon)Icon.FromHandle(hIcon).Clone();
                    _imageList.Images.Add(filePath, icon);

                    int newIndex = _imageList.Images.IndexOfKey(filePath);
                    _iconCache[filePath] = newIndex;
                    return newIndex;
                }
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"[IconService] SHGetFileInfo failed for {filePath}: {ex.Message}");
            }
            finally
            {
                if (hIcon != IntPtr.Zero)
                {
                    DestroyIcon(hIcon);
                }
            }

            try
            {
                using (Icon? icon = Icon.ExtractAssociatedIcon(filePath))
                {
                    if (icon != null)
                    {
                        _imageList.Images.Add(filePath, (Icon)icon.Clone());
                        int newIndex = _imageList.Images.IndexOfKey(filePath);
                        _iconCache[filePath] = newIndex;
                        return newIndex;
                    }
                }
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"[IconService] Fallback icon extraction failed for {filePath}: {ex.Message}");
            }

            _iconCache[filePath] = _systemIconIndex;
            return _systemIconIndex;
        }

        public void ClearCache()
        {
            if (_imageList == null)
            {
                _iconCache.Clear();
                return;
            }

            foreach (var key in _iconCache.Keys)
            {
                if (key != "default" && key != "system_icon")
                {
                    if (_imageList.Images.ContainsKey(key))
                    {
                        _imageList.Images.RemoveByKey(key);
                    }
                }
            }
            _iconCache.Clear();
        }
    }
}



--------------------------------------------------
// Full Path: C:/Users/anon/PROGRAMMING/C#/SimpleFirewall/VS Minimal Firewall/MinimalFirewall-NET8/Backups/v2.5.5 - ws/2.5.5.6 - security vulnerability fix 3/LiveConnectionsControl.cs
--------------------------------------------------------------------------------
using System.ComponentModel;
using System.Diagnostics;
using System.Drawing;
using System.Windows.Forms;
using Firewall.Traffic.ViewModels;
using System.Linq;
using NetFwTypeLib;
using MinimalFirewall.TypedObjects;
using System.Collections.Specialized;
using System;

namespace MinimalFirewall
{
    public partial class LiveConnectionsControl : UserControl
    {
        private TrafficMonitorViewModel _viewModel = null!;
        private AppSettings _appSettings = null!;
        private IconService _iconService = null!;
        private BackgroundFirewallTaskService _backgroundTaskService = null!;
        private FirewallActionsService _actionsService = null!;
        private BindingSource _bindingSource;
        private SortableBindingList<TcpConnectionViewModel> _sortableList;

        public LiveConnectionsControl()
        {
            InitializeComponent();
            this.DoubleBuffered = true;
        }

        public void Initialize(
            TrafficMonitorViewModel viewModel,
            AppSettings appSettings,
            IconService iconService,
            BackgroundFirewallTaskService backgroundTaskService,
            FirewallActionsService actionsService)
        {
            _viewModel = viewModel;
            _appSettings = appSettings;
            _iconService = iconService;
            _backgroundTaskService = backgroundTaskService;
            _actionsService = actionsService;

            liveConnectionsDataGridView.AutoGenerateColumns = false;
            _sortableList = new SortableBindingList<TcpConnectionViewModel>(_viewModel.ActiveConnections);
            _bindingSource = new BindingSource { DataSource = _sortableList };
            liveConnectionsDataGridView.DataSource = _bindingSource;

            _viewModel.ActiveConnections.CollectionChanged += ActiveConnections_CollectionChanged;

            liveConnectionsDataGridView.ColumnHeaderMouseClick += liveConnectionsDataGridView_ColumnHeaderMouseClick;

            UpdateEnabledState();
        }

        public void UpdateEnabledState()
        {
            bool isEnabled = _appSettings.IsTrafficMonitorEnabled;
            liveConnectionsDataGridView.Visible = isEnabled;
            disabledPanel.Visible = !isEnabled;
        }

        private void ActiveConnections_CollectionChanged(object? sender, NotifyCollectionChangedEventArgs e)
        {
            if (this.InvokeRequired)
            {
                this.Invoke(new Action(() => UpdateLiveConnectionsView(e)));
            }
            else
            {
                UpdateLiveConnectionsView(e);
            }
        }

        public void UpdateLiveConnectionsView(NotifyCollectionChangedEventArgs e = null)
        {
            if (e != null)
            {
                if (e.Action == NotifyCollectionChangedAction.Reset)
                {
                    _sortableList = new SortableBindingList<TcpConnectionViewModel>(_viewModel.ActiveConnections);
                    _bindingSource.DataSource = _sortableList;
                }
                else
                {
                    _sortableList = new SortableBindingList<TcpConnectionViewModel>(_viewModel.ActiveConnections);
                    _bindingSource.DataSource = _sortableList;
                }
            }
            else
            {
                _sortableList = new SortableBindingList<TcpConnectionViewModel>(_viewModel.ActiveConnections);
                _bindingSource.DataSource = _sortableList;
            }

            _bindingSource.ResetBindings(false);
            ApplySorting();
            liveConnectionsDataGridView.Refresh();
            UpdateEnabledState();
        }


        public void OnTabDeselected()
        {
            _viewModel.StopMonitoring();
            UpdateEnabledState();
        }

        public void UpdateIconColumnVisibility()
        {
            if (connIconColumn != null)
            {
                connIconColumn.Visible = _appSettings.ShowAppIcons;
            }
        }

        private void ApplySorting()
        {
            int sortCol = _appSettings.LiveConnectionsSortColumn;
            var sortOrder = (SortOrder)_appSettings.LiveConnectionsSortOrder;

            if (sortCol > -1 && sortOrder != SortOrder.None && sortCol < liveConnectionsDataGridView.Columns.Count)
            {
                var column = liveConnectionsDataGridView.Columns[sortCol];
                var direction = sortOrder == SortOrder.Ascending ? ListSortDirection.Ascending : ListSortDirection.Descending;
                _sortableList.Sort(column.DataPropertyName, direction);
                liveConnectionsDataGridView.Sort(column, direction);
            }
        }

        private void liveConnectionsDataGridView_CellFormatting(object sender, DataGridViewCellFormattingEventArgs e)
        {
            if (e.RowIndex < 0) return;
            var grid = (DataGridView)sender;

            if (grid.Rows[e.RowIndex].DataBoundItem is not TcpConnectionViewModel conn) return;

            if (grid.Columns[e.ColumnIndex].Name == "connIconColumn")
            {
                if (_appSettings.ShowAppIcons && !string.IsNullOrEmpty(conn.ProcessPath))
                {
                    int iconIndex = _iconService.GetIconIndex(conn.ProcessPath);
                    if (iconIndex != -1 && _iconService.ImageList != null)
                    {
                        e.Value = _iconService.ImageList.Images[iconIndex];
                    }
                }
                return;
            }

            if (conn.State.Equals("Established", StringComparison.OrdinalIgnoreCase))
            {
                e.CellStyle.BackColor = Color.FromArgb(204, 255, 204);
                e.CellStyle.ForeColor = Color.Black;
            }
            else if (conn.State.Equals("Listen", StringComparison.OrdinalIgnoreCase))
            {
                e.CellStyle.BackColor = Color.FromArgb(255, 255, 204);
                e.CellStyle.ForeColor = Color.Black;
            }

            if (grid.Rows[e.RowIndex].Selected)
            {
                e.CellStyle.SelectionBackColor = SystemColors.Highlight;
                e.CellStyle.SelectionForeColor = SystemColors.HighlightText;
            }
            else
            {
                e.CellStyle.SelectionBackColor = e.CellStyle.BackColor;
                e.CellStyle.SelectionForeColor = e.CellStyle.ForeColor;
            }
        }

        private void liveConnectionsDataGridView_CellMouseDown(object sender, DataGridViewCellMouseEventArgs e)
        {
            if (e.Button == MouseButtons.Right && e.RowIndex >= 0)
            {
                var grid = (DataGridView)sender;
                var clickedRow = grid.Rows[e.RowIndex];

                if (!clickedRow.Selected)
                {
                    grid.ClearSelection();
                    clickedRow.Selected = true;
                }
            }
        }

        private void liveConnectionsDataGridView_ColumnHeaderMouseClick(object sender, DataGridViewCellMouseEventArgs e)
        {
            if (e.ColumnIndex < 0) return;

            var newColumn = liveConnectionsDataGridView.Columns[e.ColumnIndex];
            var sortOrder = liveConnectionsDataGridView.SortOrder;
            string propertyName = newColumn.DataPropertyName;

            if (string.IsNullOrEmpty(propertyName)) return;

            _appSettings.LiveConnectionsSortColumn = e.ColumnIndex;
            _appSettings.LiveConnectionsSortOrder = (int)sortOrder;

            var direction = sortOrder == SortOrder.Ascending ? ListSortDirection.Ascending : ListSortDirection.Descending;
            _sortableList.Sort(propertyName, direction);
            _bindingSource.ResetBindings(false);
        }

        private bool TryGetSelectedConnection(out TcpConnectionViewModel? connection)
        {
            connection = null;
            if (liveConnectionsDataGridView.SelectedRows.Count == 0)
            {
                return false;
            }

            if (liveConnectionsDataGridView.SelectedRows[0].DataBoundItem is TcpConnectionViewModel conn)
            {
                connection = conn;
                return true;
            }
            return false;
        }

        private void killProcessToolStripMenuItem_Click(object sender, EventArgs e)
        {
            if (TryGetSelectedConnection(out var connection) && connection.KillProcessCommand.CanExecute(null))
            {
                connection.KillProcessCommand.Execute(null);
            }
        }

        private void blockRemoteIPToolStripMenuItem_Click(object sender, EventArgs e)
        {
            if (TryGetSelectedConnection(out var connection) && connection.BlockRemoteIpCommand.CanExecute(null))
            {
                connection.BlockRemoteIpCommand.Execute(null);
            }
        }

        private void createAdvancedRuleToolStripMenuItem_Click(object sender, EventArgs e)
        {
            if (TryGetSelectedConnection(out var connection) && !string.IsNullOrEmpty(connection.ProcessPath))
            {
                using var dialog = new CreateAdvancedRuleForm(_actionsService, connection.ProcessPath, "", _appSettings);
                if (dialog.ShowDialog(this.FindForm()) == DialogResult.OK)
                {
                    if (dialog.RuleVm != null)
                    {
                        var payload = new CreateAdvancedRulePayload { ViewModel = dialog.RuleVm, InterfaceTypes = dialog.RuleVm.InterfaceTypes, IcmpTypesAndCodes = dialog.RuleVm.IcmpTypesAndCodes };
                        _backgroundTaskService.EnqueueTask(new FirewallTask(FirewallTaskType.CreateAdvancedRule, payload));
                    }
                }
            }
        }

        private void openFileLocationToolStripMenuItem_Click(object sender, EventArgs e)
        {
            if (TryGetSelectedConnection(out var connection) && !string.IsNullOrEmpty(connection.ProcessPath))
            {
                if (!File.Exists(connection.ProcessPath) && !Directory.Exists(connection.ProcessPath))
                {
                    DarkModeForms.Messenger.MessageBox("The path for this item is no longer valid or does not exist.", "Path Not Found", MessageBoxButtons.OK, MessageBoxIcon.Error);
                    return;
                }

                try
                {
                    Process.Start("explorer.exe", $"/select, \"{connection.ProcessPath}\"");
                }
                catch (Exception ex) when (ex is Win32Exception or FileNotFoundException)
                {
                    DarkModeForms.Messenger.MessageBox($"Could not open file location.\n\nError: {ex.Message}", "Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
                }
            }
            else
            {
                DarkModeForms.Messenger.MessageBox("The path for this item is not available or does not exist.", "Path Not Found", MessageBoxButtons.OK, MessageBoxIcon.Error);
            }
        }

        private void copyDetailsToolStripMenuItem_Click(object sender, EventArgs e)
        {
            if (TryGetSelectedConnection(out var connection))
            {
                var details = new System.Text.StringBuilder();
                details.AppendLine($"Type: Live Connection");
                details.AppendLine($"Application: {connection.DisplayName}");
                details.AppendLine($"Path: {connection.ProcessPath}");
                details.AppendLine($"State: {connection.State}");
                details.AppendLine($"Local: {connection.LocalAddress}:{connection.LocalPort}");
                details.AppendLine($"Remote: {connection.RemoteAddress}:{connection.RemotePort}");
                Clipboard.SetText(details.ToString());
            }
        }

        private void liveConnectionsContextMenu_Opening(object sender, CancelEventArgs e)
        {
            if (!TryGetSelectedConnection(out var connection) || connection == null)
            {
                e.Cancel = true;
                return;
            }

            killProcessToolStripMenuItem.Enabled = connection.KillProcessCommand.CanExecute(null);
            blockRemoteIPToolStripMenuItem.Enabled = connection.BlockRemoteIpCommand.CanExecute(null);
            bool pathExists = !string.IsNullOrEmpty(connection.ProcessPath) && File.Exists(connection.ProcessPath);
            openFileLocationToolStripMenuItem.Enabled = pathExists;
            createAdvancedRuleToolStripMenuItem.Enabled = pathExists;
        }

        private void liveConnectionsDataGridView_RowPostPaint(object sender, DataGridViewRowPostPaintEventArgs e)
        {
            var grid = (DataGridView)sender;
            var row = grid.Rows[e.RowIndex];

            if (row.Selected) return;

            var mouseOverRow = grid.HitTest(grid.PointToClient(MousePosition).X, grid.PointToClient(MousePosition).Y).RowIndex;
            if (e.RowIndex == mouseOverRow)
            {
                using var overlayBrush = new SolidBrush(Color.FromArgb(25, Color.Black));
                e.Graphics.FillRectangle(overlayBrush, e.RowBounds);
            }
        }

        private void liveConnectionsDataGridView_CellMouseEnter(object sender, DataGridViewCellEventArgs e)
        {
            if (e.RowIndex >= 0)
            {
                var grid = (DataGridView)sender;
                grid.InvalidateRow(e.RowIndex);
            }
        }

        private void liveConnectionsDataGridView_CellMouseLeave(object sender, DataGridViewCellEventArgs e)
        {
            if (e.RowIndex >= 0)
            {
                var grid = (DataGridView)sender;
                grid.InvalidateRow(e.RowIndex);
            }
        }
    }
}

--------------------------------------------------
// Full Path: C:/Users/anon/PROGRAMMING/C#/SimpleFirewall/VS Minimal Firewall/MinimalFirewall-NET8/Backups/v2.5.5 - ws/2.5.5.6 - security vulnerability fix 3/LiveConnectionsControl.Designer.cs
--------------------------------------------------------------------------------
namespace MinimalFirewall
{
    partial class LiveConnectionsControl
    {
        private System.ComponentModel.IContainer components = null;
        private System.Windows.Forms.Panel disabledPanel;
        private System.Windows.Forms.Label disabledLabel;

        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Component Designer generated code

        private void InitializeComponent()
        {
            this.components = new System.ComponentModel.Container();
            System.Windows.Forms.DataGridViewCellStyle dataGridViewCellStyle1 = new System.Windows.Forms.DataGridViewCellStyle();
            this.liveConnectionsDataGridView = new System.Windows.Forms.DataGridView();
            this.connIconColumn = new System.Windows.Forms.DataGridViewImageColumn();
            this.connNameColumn = new System.Windows.Forms.DataGridViewTextBoxColumn();
            this.connStateColumn = new System.Windows.Forms.DataGridViewTextBoxColumn();
            this.connLocalAddrColumn = new System.Windows.Forms.DataGridViewTextBoxColumn();
            this.connLocalPortColumn = new System.Windows.Forms.DataGridViewTextBoxColumn();
            this.connRemoteAddrColumn = new System.Windows.Forms.DataGridViewTextBoxColumn();
            this.connRemotePortColumn = new System.Windows.Forms.DataGridViewTextBoxColumn();
            this.connPathColumn = new System.Windows.Forms.DataGridViewTextBoxColumn();
            this.liveConnectionsContextMenu = new System.Windows.Forms.ContextMenuStrip(this.components);
            this.killProcessToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.blockRemoteIPToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.toolStripSeparator1 = new System.Windows.Forms.ToolStripSeparator();
            this.createAdvancedRuleToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.toolStripSeparator2 = new System.Windows.Forms.ToolStripSeparator();
            this.openFileLocationToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.copyDetailsToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.disabledPanel = new System.Windows.Forms.Panel();
            this.disabledLabel = new System.Windows.Forms.Label();
            ((System.ComponentModel.ISupportInitialize)(this.liveConnectionsDataGridView)).BeginInit();
            this.liveConnectionsContextMenu.SuspendLayout();
            this.disabledPanel.SuspendLayout();
            this.SuspendLayout();
            // 
            // liveConnectionsDataGridView
            // 
            this.liveConnectionsDataGridView.AllowUserToAddRows = false;
            this.liveConnectionsDataGridView.AllowUserToDeleteRows = false;
            this.liveConnectionsDataGridView.AllowUserToResizeRows = false;
            this.liveConnectionsDataGridView.AutoSizeColumnsMode = System.Windows.Forms.DataGridViewAutoSizeColumnsMode.Fill;
            this.liveConnectionsDataGridView.BackgroundColor = System.Drawing.SystemColors.Control;
            this.liveConnectionsDataGridView.BorderStyle = System.Windows.Forms.BorderStyle.None;
            this.liveConnectionsDataGridView.CellBorderStyle = System.Windows.Forms.DataGridViewCellBorderStyle.None;
            this.liveConnectionsDataGridView.ColumnHeadersBorderStyle = System.Windows.Forms.DataGridViewHeaderBorderStyle.None;
            dataGridViewCellStyle1.Alignment = System.Windows.Forms.DataGridViewContentAlignment.MiddleLeft;
            dataGridViewCellStyle1.BackColor = System.Drawing.SystemColors.Control;
            dataGridViewCellStyle1.Font = new System.Drawing.Font("Segoe UI", 9F);
            dataGridViewCellStyle1.ForeColor = System.Drawing.SystemColors.WindowText;
            dataGridViewCellStyle1.SelectionBackColor = System.Drawing.SystemColors.Highlight;
            dataGridViewCellStyle1.SelectionForeColor = System.Drawing.SystemColors.HighlightText;
            dataGridViewCellStyle1.WrapMode = System.Windows.Forms.DataGridViewTriState.True;
            this.liveConnectionsDataGridView.ColumnHeadersDefaultCellStyle = dataGridViewCellStyle1;
            this.liveConnectionsDataGridView.ColumnHeadersHeightSizeMode = System.Windows.Forms.DataGridViewColumnHeadersHeightSizeMode.AutoSize;
            this.liveConnectionsDataGridView.Columns.AddRange(new System.Windows.Forms.DataGridViewColumn[] {
            this.connIconColumn,
            this.connNameColumn,
            this.connStateColumn,
            this.connLocalAddrColumn,
            this.connLocalPortColumn,
            this.connRemoteAddrColumn,
            this.connRemotePortColumn,
            this.connPathColumn});
            this.liveConnectionsDataGridView.ContextMenuStrip = this.liveConnectionsContextMenu;
            this.liveConnectionsDataGridView.Dock = System.Windows.Forms.DockStyle.Fill;
            this.liveConnectionsDataGridView.EnableHeadersVisualStyles = false;
            this.liveConnectionsDataGridView.GridColor = System.Drawing.SystemColors.Control;
            this.liveConnectionsDataGridView.Location = new System.Drawing.Point(0, 0);
            this.liveConnectionsDataGridView.MultiSelect = false;
            this.liveConnectionsDataGridView.Name = "liveConnectionsDataGridView";
            this.liveConnectionsDataGridView.ReadOnly = true;
            this.liveConnectionsDataGridView.RowHeadersVisible = false;
            this.liveConnectionsDataGridView.RowTemplate.Height = 28;
            this.liveConnectionsDataGridView.SelectionMode = System.Windows.Forms.DataGridViewSelectionMode.FullRowSelect;
            this.liveConnectionsDataGridView.ShowCellToolTips = true;
            this.liveConnectionsDataGridView.Size = new System.Drawing.Size(800, 600);
            this.liveConnectionsDataGridView.TabIndex = 0;
            this.liveConnectionsDataGridView.CellFormatting += new System.Windows.Forms.DataGridViewCellFormattingEventHandler(this.liveConnectionsDataGridView_CellFormatting);
            this.liveConnectionsDataGridView.CellMouseDown += new System.Windows.Forms.DataGridViewCellMouseEventHandler(this.liveConnectionsDataGridView_CellMouseDown);
            this.liveConnectionsDataGridView.CellMouseEnter += new System.Windows.Forms.DataGridViewCellEventHandler(this.liveConnectionsDataGridView_CellMouseEnter);
            this.liveConnectionsDataGridView.CellMouseLeave += new System.Windows.Forms.DataGridViewCellEventHandler(this.liveConnectionsDataGridView_CellMouseLeave);
            this.liveConnectionsDataGridView.ColumnHeaderMouseClick += new System.Windows.Forms.DataGridViewCellMouseEventHandler(this.liveConnectionsDataGridView_ColumnHeaderMouseClick);
            this.liveConnectionsDataGridView.RowPostPaint += new System.Windows.Forms.DataGridViewRowPostPaintEventHandler(this.liveConnectionsDataGridView_RowPostPaint);
            // 
            // connIconColumn
            // 
            this.connIconColumn.AutoSizeMode = System.Windows.Forms.DataGridViewAutoSizeColumnMode.None;
            this.connIconColumn.DataPropertyName = "ProcessPath";
            this.connIconColumn.FillWeight = 10F;
            this.connIconColumn.HeaderText = "";
            this.connIconColumn.ImageLayout = System.Windows.Forms.DataGridViewImageCellLayout.Zoom;
            this.connIconColumn.MinimumWidth = 32;
            this.connIconColumn.Name = "connIconColumn";
            this.connIconColumn.ReadOnly = true;
            this.connIconColumn.Resizable = System.Windows.Forms.DataGridViewTriState.False;
            this.connIconColumn.Width = 32;
            // 
            // connNameColumn
            // 
            this.connNameColumn.DataPropertyName = "DisplayName";
            this.connNameColumn.FillWeight = 25F;
            this.connNameColumn.HeaderText = "Application";
            this.connNameColumn.Name = "connNameColumn";
            this.connNameColumn.ReadOnly = true;
            // 
            // connStateColumn
            // 
            this.connStateColumn.DataPropertyName = "State";
            this.connStateColumn.FillWeight = 15F;
            this.connStateColumn.HeaderText = "State";
            this.connStateColumn.Name = "connStateColumn";
            this.connStateColumn.ReadOnly = true;
            // 
            // connLocalAddrColumn
            // 
            this.connLocalAddrColumn.DataPropertyName = "LocalAddress";
            this.connLocalAddrColumn.FillWeight = 20F;
            this.connLocalAddrColumn.HeaderText = "Local Address";
            this.connLocalAddrColumn.Name = "connLocalAddrColumn";
            this.connLocalAddrColumn.ReadOnly = true;
            // 
            // connLocalPortColumn
            // 
            this.connLocalPortColumn.DataPropertyName = "LocalPort";
            this.connLocalPortColumn.FillWeight = 10F;
            this.connLocalPortColumn.HeaderText = "Port";
            this.connLocalPortColumn.Name = "connLocalPortColumn";
            this.connLocalPortColumn.ReadOnly = true;
            // 
            // connRemoteAddrColumn
            // 
            this.connRemoteAddrColumn.DataPropertyName = "RemoteAddress";
            this.connRemoteAddrColumn.FillWeight = 20F;
            this.connRemoteAddrColumn.HeaderText = "Remote Address";
            this.connRemoteAddrColumn.Name = "connRemoteAddrColumn";
            this.connRemoteAddrColumn.ReadOnly = true;
            // 
            // connRemotePortColumn
            // 
            this.connRemotePortColumn.DataPropertyName = "RemotePort";
            this.connRemotePortColumn.FillWeight = 10F;
            this.connRemotePortColumn.HeaderText = "Port";
            this.connRemotePortColumn.Name = "connRemotePortColumn";
            this.connRemotePortColumn.ReadOnly = true;
            // 
            // connPathColumn
            // 
            this.connPathColumn.DataPropertyName = "ProcessPath";
            this.connPathColumn.FillWeight = 30F;
            this.connPathColumn.HeaderText = "Path";
            this.connPathColumn.Name = "connPathColumn";
            this.connPathColumn.ReadOnly = true;
            // 
            // liveConnectionsContextMenu
            // 
            this.liveConnectionsContextMenu.ImageScalingSize = new System.Drawing.Size(20, 20);
            this.liveConnectionsContextMenu.Items.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.killProcessToolStripMenuItem,
            this.blockRemoteIPToolStripMenuItem,
            this.toolStripSeparator1,
            this.createAdvancedRuleToolStripMenuItem,
            this.toolStripSeparator2,
            this.openFileLocationToolStripMenuItem,
            this.copyDetailsToolStripMenuItem});
            this.liveConnectionsContextMenu.Name = "liveConnectionsContextMenu";
            this.liveConnectionsContextMenu.Size = new System.Drawing.Size(228, 142);
            this.liveConnectionsContextMenu.Opening += new System.ComponentModel.CancelEventHandler(this.liveConnectionsContextMenu_Opening);
            // 
            // killProcessToolStripMenuItem
            // 
            this.killProcessToolStripMenuItem.Name = "killProcessToolStripMenuItem";
            this.killProcessToolStripMenuItem.Size = new System.Drawing.Size(227, 24);
            this.killProcessToolStripMenuItem.Text = "Kill Process";
            this.killProcessToolStripMenuItem.Click += new System.EventHandler(this.killProcessToolStripMenuItem_Click);
            // 
            // blockRemoteIPToolStripMenuItem
            // 
            this.blockRemoteIPToolStripMenuItem.Name = "blockRemoteIPToolStripMenuItem";
            this.blockRemoteIPToolStripMenuItem.Size = new System.Drawing.Size(227, 24);
            this.blockRemoteIPToolStripMenuItem.Text = "Block Remote IP";
            this.blockRemoteIPToolStripMenuItem.Click += new System.EventHandler(this.blockRemoteIPToolStripMenuItem_Click);
            // 
            // toolStripSeparator1
            // 
            this.toolStripSeparator1.Name = "toolStripSeparator1";
            this.toolStripSeparator1.Size = new System.Drawing.Size(224, 6);
            // 
            // createAdvancedRuleToolStripMenuItem
            // 
            this.createAdvancedRuleToolStripMenuItem.Name = "createAdvancedRuleToolStripMenuItem";
            this.createAdvancedRuleToolStripMenuItem.Size = new System.Drawing.Size(227, 24);
            this.createAdvancedRuleToolStripMenuItem.Text = "Create Advanced Rule...";
            this.createAdvancedRuleToolStripMenuItem.Click += new System.EventHandler(this.createAdvancedRuleToolStripMenuItem_Click);
            // 
            // toolStripSeparator2
            // 
            this.toolStripSeparator2.Name = "toolStripSeparator2";
            this.toolStripSeparator2.Size = new System.Drawing.Size(224, 6);
            // 
            // openFileLocationToolStripMenuItem
            // 
            this.openFileLocationToolStripMenuItem.Name = "openFileLocationToolStripMenuItem";
            this.openFileLocationToolStripMenuItem.Size = new System.Drawing.Size(227, 24);
            this.openFileLocationToolStripMenuItem.Text = "Open File Location";
            this.openFileLocationToolStripMenuItem.Click += new System.EventHandler(this.openFileLocationToolStripMenuItem_Click);
            // 
            // copyDetailsToolStripMenuItem
            // 
            this.copyDetailsToolStripMenuItem.Name = "copyDetailsToolStripMenuItem";
            this.copyDetailsToolStripMenuItem.Size = new System.Drawing.Size(227, 24);
            this.copyDetailsToolStripMenuItem.Text = "Copy Details";
            this.copyDetailsToolStripMenuItem.Click += new System.EventHandler(this.copyDetailsToolStripMenuItem_Click);
            // 
            // disabledPanel
            // 
            this.disabledPanel.Controls.Add(this.disabledLabel);
            this.disabledPanel.Dock = System.Windows.Forms.DockStyle.Fill;
            this.disabledPanel.Location = new System.Drawing.Point(0, 0);
            this.disabledPanel.Name = "disabledPanel";
            this.disabledPanel.Size = new System.Drawing.Size(800, 600);
            this.disabledPanel.TabIndex = 1;
            this.disabledPanel.Visible = false;
            // 
            // disabledLabel
            // 
            this.disabledLabel.Dock = System.Windows.Forms.DockStyle.Fill;
            this.disabledLabel.Font = new System.Drawing.Font("Segoe UI", 12F);
            this.disabledLabel.Location = new System.Drawing.Point(0, 0);
            this.disabledLabel.Name = "disabledLabel";
            this.disabledLabel.Size = new System.Drawing.Size(800, 600);
            this.disabledLabel.TabIndex = 0;
            this.disabledLabel.Text = "Live connection monitoring is disabled.\r\n\r\nYou can enable it in the Settings tab.";
            this.disabledLabel.TextAlign = System.Drawing.ContentAlignment.MiddleCenter;
            // 
            // LiveConnectionsControl
            // 
            this.AutoScaleDimensions = new System.Drawing.SizeF(8F, 20F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.Controls.Add(this.disabledPanel);
            this.Controls.Add(this.liveConnectionsDataGridView);
            this.Name = "LiveConnectionsControl";
            this.Size = new System.Drawing.Size(800, 600);
            ((System.ComponentModel.ISupportInitialize)(this.liveConnectionsDataGridView)).EndInit();
            this.liveConnectionsContextMenu.ResumeLayout(false);
            this.disabledPanel.ResumeLayout(false);
            this.ResumeLayout(false);

        }

        #endregion

        private System.Windows.Forms.DataGridView liveConnectionsDataGridView;
        private System.Windows.Forms.ContextMenuStrip liveConnectionsContextMenu;
        private System.Windows.Forms.ToolStripMenuItem killProcessToolStripMenuItem;
        private System.Windows.Forms.ToolStripMenuItem blockRemoteIPToolStripMenuItem;
        private System.Windows.Forms.ToolStripSeparator toolStripSeparator1;
        private System.Windows.Forms.ToolStripMenuItem createAdvancedRuleToolStripMenuItem;
        private System.Windows.Forms.ToolStripSeparator toolStripSeparator2;
        private System.Windows.Forms.ToolStripMenuItem openFileLocationToolStripMenuItem;
        private System.Windows.Forms.ToolStripMenuItem copyDetailsToolStripMenuItem;
        private System.Windows.Forms.DataGridViewImageColumn connIconColumn;
        private System.Windows.Forms.DataGridViewTextBoxColumn connNameColumn;
        private System.Windows.Forms.DataGridViewTextBoxColumn connStateColumn;
        private System.Windows.Forms.DataGridViewTextBoxColumn connLocalAddrColumn;
        private System.Windows.Forms.DataGridViewTextBoxColumn connLocalPortColumn;
        private System.Windows.Forms.DataGridViewTextBoxColumn connRemoteAddrColumn;
        private System.Windows.Forms.DataGridViewTextBoxColumn connRemotePortColumn;
        private System.Windows.Forms.DataGridViewTextBoxColumn connPathColumn;
    }
}

--------------------------------------------------
// Full Path: C:/Users/anon/PROGRAMMING/C#/SimpleFirewall/VS Minimal Firewall/MinimalFirewall-NET8/Backups/v2.5.5 - ws/2.5.5.6 - security vulnerability fix 3/logo.ico
--------------------------------------------------------------------------------
           V                        00     n           ?  H  PNG

   
IHDR         a   sRGB   IDAT8O}KSa;cnS\*i4(X"N2&*
.

R\Z$9ol3L>}Cq@z%g
  9>)jYM-j	UV_nX%^c`uXA!m<x+\IBF(c&h vOA+@ Q)8C5uu8-TT/tt266`sIcK$jFj%=::P?Tl:=bM_zN7-Vch0qNxx1\p:.v,6tXI0K
iGjc
S._btV@&i1eB7 R?=@u
0 +(du%G4c9Lpq .PNBwBrdXk%D?E0w ;!E]!Lr_3+k]=(uCKXh0C- +3.;XJ">0}g&JSoQGg]
z{ovSI'=
jd"amqvJq' [    IENDB`PNG

   
IHDR         w=   sRGB   IDATHK[lUgfgfnv{VR;!FF}PCH`/D" GJBEn
,mQ-$s9C,_Bm{
Y F1Yw*5PD)NR.)q[
`T#(jsQ
r.ey8B![zHNJ?+QrqW>%	P-kcX0Q*cKG$~K`LEy/OJ<?i]u(L)dEv#*%l` };(5
DdGTL`Hm7z-k:JvZkGY^H`E$Iu.h^,I5xmk0y*7a2Ya7e#a
ikck#!2jP#KhV6b}w$gg <'{-H	bW\c86HmE8x4C{s9J'WvX$u*F*R)Y/g?eYV-$Im95_hONf:Y7E#M .0N4|vMI&?X y(`>S5fx7pc.eN$c?e\AEjba:w/_#`E }[+HF|	5UndS\;rszR5;a_]?;q mQ^$Y0y!LhNt[:i%K<Fdc;tA}9`>~e{zxj)l<uy5Q*[u.B	y'aib|-^lW[j7N1vqt=W{%kw:KjmbfmYk@hO	(b|%q}Z|7obVzbeB	8PZ\4wJ(Ok    IENDB`PNG

   
IHDR           szz   sRGB   |IDATXGYl\gw}<}'N.!&PZ
(<Q$ B)6M
0!&!!
i[x{<g_RNxF#]}9\)CwjN tO+V{<Y
 U^)`sC$,[Z1M: `P.[$$~-ht;P\*thiexT
tT5io%A]@7,zW[%c>O~1^60+8L%dY6J"Tdf2[^^~ },=wGuQ\*G6B
ti;#|H|eS4lh`gJ[e7t5Zbq"%wjR)VIIUdy.W9%sxj4dgm[	}XwbPJUPe&~zr,eSp"&QO)769.8R	u?-&YL,;fhbsD]F@v8NQ.*+YN\Nm$%hrB)S
RI;UxS?m=UIDI@}Z/):k)v*X&UR|rwTn0-aA(Mb'V@lSc_vt2uYmN!
e1?+CblfQ(EeZ*z`Su]_3-+Q+XY1.(.<	h
f$p1}jJLJo?'+8UTJb6iDEKx~<XLvp[oOk<+YOx}
oPgj	B_N<q./l<rR(j5[D4jTP*gb~^3sjE*PnK'MlD?FQq(x!Htq0QjZn[$	pxUM
lk#I{gx/?Qyh	v[~=8|&p=Dw4
y%?,Ue; |B.Jpn;ZI
_+Sq)9;F2b*bqfU 5W+Chh dyZz;pybw3yx^Nrr~r$@h":}lsGBlVwC07x_"$
)<^\!7"[#95 Rn).S;o0wl5[i'vW'kwCo]dCu+\SK msowky2'?{3}#d!6U*>kt0S7sn?_)0If2-gDB^[k4two| g^mF6x%$K_j;BrWLo| ;iJdwra 8- 3}iB!L,2wj6ma(|{vj#_QVi[iuN+\U    IENDB`PNG

   
IHDR   0   0   W   sRGB   (IDAThCY{pT}k}J]i~C 	c%ql38t:nS'3u\q'Ll]gLK\;~$qL!@HHb{Zj=5xFvY{;sg<~\7 c/`0xzl5	_40s)JnG&"{%PX?5jM@dblSg$^\b#Wf 6m$kiZ70VN%N-U~"C7`d
x]z>$d@ 41[@`&.thqm4U-/`%*7x~OXq
8}u(	L#N_$QY_buI kiHaSf0i FVp5HG3TdSFsO~@b#aYz'QoKy)0,, |8}N$D;ah#Q&F:Gps?AM(_QADuZZADGqi	0fVFj:	{VA01%_k L7xGc+4=o>77S&Ici<Znb?2a|["IBT$wiBc(ZG)K8
h  @V,r!I
}g_Y@JB0thj;Y tiS)qxjT\Oi}zn[#Xps%.o@<_.C;A0px
4SA6Ef&eQ s(Z/0313' [.yl+Ct4!#az4
Ox|)TXw6PTCMi5n?=wh{
{K.o@o6a|' `n 
TNA0(^ao~!"pI@/;R,(Gx'x`ZRE:LGxo'Npy~a[eHES;OpAL@Y4G_H:ey)"#=6Jd?en")xBb,{Pu>IN' -SZz;t2(6;5A2jLLVy5JR]otd2/o;T4W 1@mx7)6*nW3I7'`n ^J5CX+sMgR(BH*O:v5F0z8O?o*VU"Nl*K
6LkI
^0)6m!AdlT}*E!Z%N)cQRq+([V
n`}p`ERZLHCAg:{{}}X\ <u(m,E<$p9;7&.+ih|E<ED!]h$	f9[LD'EML%f!VTO4L@[0?IeLgy')auQ$MI#^P,DF<W!I4E"0`A  ~7T`5|b;dBo Ie}vZg	4/>I{ j)4s55%\]}#;[nAKd% J"7/"	e1>v{+ln_5&'hu
gMdNO"KJ1_YC|8oB:Sqp#X<MdtJ
5w3p8egLfejTlFh~@o	a-,x8)6"Rdt(N-/VYU _52}xdr{qs	w[B;&9,SYJh19sKIAIUv	d-fk%4Z[:z:yf)^E>|nH<f/ {MZe2FFtTE
X}
E,oW_ wmA)i9>2~J"K<`p \5	 _p3b;:&Y1
,(vc ,[*QtC	I-c:UYGQ+Z??5'  3o]O?<!8* jqdk;Js#%%N*B
mo03`'\Hja7#9ce7~}Uggu|C+QZ\ jqWr l6L;	KS	EQe&cqX
Y$3*\i)p[!B\"BT
SHS-+-1aH0Mi!d2 XY9=F\xdLFM2yfw	t|#fR;.+w%A_<XF6ri* ^_Y5vv8L?YrW<UhzpvHq -,3,"|&yrub02Lz,ie;}:5gMyV<T*m,@SDI)
0!)"FvQJ  RcgU8 JJ|MG_/CsVyg.x
]RHT(y(he	]3v|VZZSr%*lbV[6/hI u@}+CqkiF{r~y>ssummv_ $aFsQl{VNp9 r5,a;P-%d/ds8Z+]q$^Ix\Q_Zkkk \_%%[x
)X%PyB-h]wr;H$??8k Ci.-=PTCG]0>Xb50O<Lm_CP;n;L^%0M)oEGaqYU r/}s gmr?&x q39
(RsB;y]RfS8%ngvEy6J=:jkh@9"k }D$jj
}2 699s]?8{7)Lv?o  DQ5y_|`0m$Y..E? j!L    IENDB`PNG

   
IHDR         \rf   sRGB     IDATx^}|uyNN*!mmbCQuE{H'tB [%IHoyy!7qd|{e#>-#`XeXF<~G Xe#`1 oytXeXF<~G Xe#`1 oytXeXF<|w=j[a<2`afo=cgYRZ#+00p/9>>4g?xk.,h0F#l`y?DFFOKcyH:F1cwpQz}ooe3m6nZhs@@Yf` c3aiNWQZZ2^Nt! [;G'|st< EvvvGxzAcllvvG<<ifAhhfKxKF?wdwy'#\QVP ^s@A	2mj/_h#X-Bv;FQwws((]RZSS] foaei-ZN4iq*owZ{sGb ns7BzCQoT<Gcr]]\h25   cgo[. &|}_b4cQ^VVYS[kTw{{(q:7n~|/vOw6woXAAzW|tz4VV+psuUVkz!!!7{,:Xp^^^	UU]zAm%g36ruutss[~gt:{>^6mUXXPVVPU]Mr.oz;V .DGGxw_|:Pq|	UJwn]v[.\xRpS_5]b inIt}Q
6t/*W\RPUYN.PYzuCNH	OGo8;0a-fT6?DM}/[l\11s^b ~IMIIi0<k]]cgbked?;n-:]%J
`
69NN^^Ng~X_,ZGw9
.PSQ^Q]]Y_W`^}n~kt*h+%L=yM76mZ<36pmts=>ZVQYUQMV#7KB-x{zYP1Tutpg`?c%T,Y'Ovx0UU!55ukj<+;/vo__v-j\_of0^0z|C
:OHFT@>*,ehtgU(~Z
n`cS fw^^[p\5 \~'K.msn.\V[[`27_;$=>E5F(7iW5_N	b~d}FWcA	k9::rqvtvvg'O`8-5m4f]*BjjT)f~hY
:keg:(m?X)Qbpl#YY?dmkV}Z;`ZY*+QUR}(H2ZYYvppg3gYs]76/))R\\,[mmM["[3'y8I7E>}mx`UB"W/^"Mp]@6*[t:+XX_=}^G'NXl?Xz_|v=kjkkz' _~#rtwK;A+.<WWY{<S m d6we/24O{0qN+taB7S2a*6vv;9d;W\P"fl[geem}]]-3z ;8{;k3oZV hJ=M|	 
*
Zk%>c;Nl<
.\0!h5j+j+x1zw*
+ dwng1 :uFMy
f575Eu
Vlll998uss~DHHHijn &M{ng(UQVP\SS`08e3rC{KxyVDW ';W.15adXJYsM953"'Fa
_6HUafqE3_xb A\[bX|\)Ws	f=AE++M;;.vA]7nQ P>vQW[n4\		f5ly\66 CPbVe6
NouOT~HP
vv9&|9V#7 	X
1c;KDAo+=;X	fL;*&
@sWdgIS%9'-pr	z	74f@
mmlm~e]DDD?dF/ hn={|?2[um-E/
7QsnJ#vw84"W{/}EEQVk^c6m%p|4CuI>7w=F~2apf g6 .8
/mp74\<}QdY~YCcpT~`%cUkccSdcc{>''NnN}=}O\xW+v3g{_. hh1()g{KX uK>hd4^1k>PG#]V6JR%p1Ikf]/sE$}qElFY*]0Qb <>g<T]BE+)ppm'}H7z$>/JU_H;Pq0Jhc`5BDIuVVvvy66':Ou`ErqK9GrWWWk0<za7bg"4g11y{%clmtGAei%>U9awYf0DBQ]][[vV\K>}qL1Dw`D})OG/ -\1*IDLz).8u_e!$d5{# ) .[7xv-$TST-}]AHYF+k*kbg!.\po~2e?O4QiTU
42
b%`</B'nySw?GP]WT/5K%!
6_l;,5zs=zC
#?U@O@^Nm;#zaHy.+?JO'_t'f!(L?y>
KRrt4<#oJVFc'4[|}Mx/Vrs^zu9^U]z
mWkwLHx@Dt(`i=_}FzhjJY *gKD=
^mMW46;T!9:^|k?\BEw@C9c>245S[OXeKW#f?=3=@liDx/.?Kpvq>w\egt^srMj%9Dvw(RqpAuZ"t#U(8TpM{1b]sGYy!mR
<<_P{6m08$2>@=!1'L_w5
!h ~>e1)6[Oj `uE5i6'FQ<^{!	
a?X4%U1upt8}w2oU>`0xAXWZGH2_v
G?##XN:J*yjz2~&E#P[Me3
HU,Qj*;+ED^6
LRuMqxLm^}[Az}0\8qH99^%=
~b,  }IH(4Gl>+71??1pr1oC7VW<8NN.N'$my/p
L7fZy8 E'Ov	84MY}j sphb	
`8Zl9Y.;z*5B*>dWm7BoM, >
 ZyG&w@OXkm?~nH\504S}	ZyRP|Nnr"wBgC^st Xx]2zr\  vGHz>	+KGn-C{:Nx^Y# 8mo)sTo2HEz_xD+^qe< ooF3 F}XR)[po=gd1 sq0M	8Vh_ .+EnYj]a?$!B.|	CRKfPo4t:U~`~'qEZ-HPGF?3<Np:;kOp;Fuwo/PVPhB57M=g1RMB|vCgHx.M6sI\
=Hz"?
mo
R	3a4onGc#MX[ 899TVV@3'Sbhd |=@"/.e9B]L7 L%LM8T>qdTC.U+OWJ]wL'3sbUzd~' 88@in)VS[Gx{8|787Zuu	{a`'U[E3$It\!}gj cyX=7&10%/);k3j,ycNn9M
\:|~7Chhp:C	rc.B=y{@CH$ X8{;n` @Ea*la3a}"5_YUH Wo]IW6h4Zn]vK,p[w
!N}{yOEakMFPWS?nY;Lgw'zR_e	X<^D|CX,Bp?Qamkc*ikqrFWz nG,G%]C&@"3FJZ'ogx'lB"0	a!:,1-]uzMv14+teu&PdHKXZM"0jCHcVd
}riDC>kdoB,xv0!CmHwa(nzrVQ(pp8 k\xjV=[cB
,{}` q h~! )__S[O}^]X
3 ~X]{ XD>aCL4*\j r|`=B=puVVg*1Sw_'ATLU=wgKc9.QG*+]*A^xE'4o+ z
i)I+?HX@A#a^FnJxrr!iJx " +2DSqX>}:Dt@n- T`kTo1v8r=GB8TEV=)/,wqPY~i<
H+02Mx 09/o "oYH$j 0z\B':t	1Q^O(TY. d|\88P.u_kCws=H,{sytEcc1L 
<yzwAm`ccsr43 E
GP16'8[pvA~N>cu*K_[N$%@TTb
>y8
}=F!p^GO" Xy_+n5U5,xopS$o?g&-\< q#GWUgyusXf9?6 ~3^fGd5M0<mHy>>o~+)E.FwJ[Up2e?8V\^RF|9eF@xWb]vab<qY pr_	uORvsxO$<H!d{U
4	5Nkk\Z
.]H1b?6b}b\8OxyNOL;wo&-FW ll<?k gXG:pri
mc3 
C^$$V_
2O0Xj+5
Bz_(/T`X"0rhWL+xy Ee    IDAT6w3	1!+>J_ q.8.qHz:_Y.o,L1J~F  K_[jZoCQ}7m?Y-",6Vhc 4TgC#Q=+gIs.`ZKqhq|f3 Fz~:'ti`a37Wk`4S|gzc+^[..|"zo41
t;G[zg\<Sva~	_^$oyh.>Zuz`G&e8G{	]0EybFJEgWxa_`7 	y)vJ@tE-Bi9'I@1~$9wOCa#u#L]USf?8(@eealVK)>;2c85I
8H;g>bP\h@1
ks?$k?Z85Cpor;QOF#,~n!V G3?M,^P?X DQ1[N;{W3Z0Q1`&]SqwFe7e<y"aJ"Nm<,7O#4!!25JZpZYP5q
r8*`[zw\o64)&Fa v=*
2%@vxHB!wH y	e\11Nl9)1Vdrld{p`~yO] X,)Z%v>}*JD1s '7  i 4cc9k_KWyH1OH^O;Dt:t
>-6S05GX-__}+(E9Q_p[s
&t_%_sjvr}csO\@J*yoFh>%)-uv,.j)C2EcX8B(67;#=PYT!)9+KI8+KB-BTVH} WAw<6[~-o$GM?GXT) H
U28+! Kijjdr__w.A17Pnsp|+<YpbkZooxb 44UB6A$5\ibizvGyIl[eB
}|
WJ)UGIf:lgcqpA,m7v$]L@^xjZKKW/JluYCxNhNbiz89H:x'66,j?NvvjCM>`DIn	r]J)`P374!w"8Sc89m xl2?Y=/lE>i4tI^A/BVTAk;+
C	Ge249ISK	tMT1W;O8:E*LPUyY/#{	Z\Oy{d5OU\*,u`P3qaGk@aA/s
Xc4 c>+bM&
[E3t	o!]EF]
K~^94(,A[]Jaqrvq<=y8iLd LW2gLDO^/a?DRZK8v@trZqP1Nx(BBV!W'.,:ssM;uHx>Qv4CPaO`_uR	K@XiXj%:i{GTcPi2A9&'>4hQWQoNTU}QA@hu@B48J`S\KAN{@DX*|Wk^I\uQ_k'o'NaXjqW1>SCP;EBR&ODuP{y`,{c^AM2#Zqimmakogd3$C+bM1{&5Rqhk	X
4 &hD _#2?\0kq/Bjd~G9>RhB!>\dU&FxOFPhl9]NLZ-(:^(6]X.bjONc^C]e
+W`{8HX
\S1{#hY$pFvZ{XB
Ab,|.U_AQ(>S,|V> Zv;V(iBvP{0pm]3Kqhy+GZ. =bJP'X)W!UXJu)Nn9%:+d;R)E2j;pek^TTf0CEY.<84A+. *5 I$yRzGKKre"1+ 5h~;pH7I3hB4
;_AcJw>d~~,sft?G+\U~;Q61:@<eRw^SqyCBX8,l6}Ak>^sv	2o_eT%7a>Ab]1m`-QG;VnP8`	d+qXL0<?"DftuiAx#-dN+BqAoP	
?B+n<-x	.gZTcyP&D4V6!p`7>;Oc+
; GsY{ToD=jlFYHI]18gs <wQVToW`urX H_+y<Rf7hg+_#[/A3n57"!e-AF^
r-6}Ccj6& .d#lF1f
&BA}Dw[N#U
1C!X]@pfdZiwEiJL%\y
x5 *Eex~We'KNc'KT$;?$6d{KX6}IJ7&5F}6F	 4FFcW7	Oaewq@qXq[OX[30?KBs//#p9+~|N<#'pv1Lh||VrdlXd\'8-1B%*,U XfbP?(+A=W+Y1~*R)4
aJE
=\;*rG#%L/%(}~u/2Dx$YWh .. t@1}0pJ
Y
TE;Kr?!i 3]ge
	S[{S 0IPxp0VcGvc
.;pYcaoE{EN^J&i%:NnFR~`@M>	/{z_8.(K2P uSE2	 ?0Q<ZB)l 7Ev42?^
	AEe)#{^\(9eQB2b%Jp/`MD"~
HH$f+X}H`fVH^r)Ahid+$6mb{ #,
'cAXHeI^A\8hKZb>]fGk]R\(=G^NbhbU'^ [
zO5+qwNd},KwP
xQRPS/ObtXYpN^.N6.XH7
[(z4,G
D< 9@Rcf(AU8yK_^"_{.9r!A1
GF*Xd%`C#GvD?l?slg7jE(C%K2t"a	Bf6g9RbG3JSeM: ]b;AUO~%. 8-']N!Hk'.@o<Mt)6II2?]$ereKs]Gbm@ =9;xZmy0Te_N$93_MFcM`q;`T^`^2L$3ah-5GM"6';9O
;7;1HtzG>[;zGx1Y T|rh
'NM~ba]j>\wwA>tM	{GrY=B&7[n2=}F"]Aasc!eYu}bWdg#}QX4]%-hfT JbJF	x0#iw <~z|no;pP7Qw
6JUUHx"^,=u44P
C1 f`  o4vr."8S,jospi<K0/dO}!9+e;FuG}T!6GX|H0HYRk(wf.E,IiFi4
_E{~xxd:=dgZexJB!]wJSL;4F%L1J/2F451}N<x':XYK?lS<P9+K\4yAGLI(x,YnSbL,0m,~KNl8.}`?7ap'~_Fc	BY"AM>"1&-[W+a2p7W76 f#Bp;"a]H{Jy|]0e@1XrG<q!WDl"/irft>[j%:{MvK:X0	}U$ZjFBREG .6{1< $jf}VJ3L+;4u04ahg7d 1iH3S{ WJDNY9a//ei4V]KRMi&61/E]bb'
ilVtR {U8#rCEcq_E/M:h	GXq:117o _W"qQYZ%e}Ev:k]Q1gi)[/za>kY.l
#o]OX{[ 
$5+'!nXZ,LF_;<+rdaa8x%G5J@k+!E]&?` ..\ctGuVAzS^Ffd!i g Eh=Z '#GGY~|WdXF} lb wG/#;w,gz@WgHx>A)kNTwF'P'%yH{/
3	xrs2rW&lIwREt6"ijkcArKjK -?nQyTFPx4Hx	E8PbS ywH$;%{uJ<+h
MV )F/$J,Q~ {q<8Xkl:qdaGi2 dm$f@Uj7!7i+*;~5
3]JEdnl8bdM)\zf4D(0EW4JO/4 ~a\5l7[Fr@wrm `'&
W2YZGPuRX@1"cK[AP]Z+K
`eZq}!'ES/\+tK,"i/qVt$YyEhO;=+[:Zm
x;yX
hp&AS	N@j"{MD)/9WN^!Z ?UituG3@7c5w'6k4/l%:-{ByiG27`4W
j3th@OJMK?}F|>#?8vVVOxwi_yGyA-{)OKR,hhtW4udW?P{)I]IAe bI84o^FR
fCm
8:`K30}n8^Z>YJd~8 }Y-])a{J HgqO?{y.j @9-&Jn=,C2fVJi=R$+uP+.'
\/k.e\4^)QTXA66|ly~::%CPV1}`<IC-BXn:wb&rz(*+7@qqY	@?v?0a6@
9K|F:25LHK -	\zd?@7+"
 P4 {X0avBC/fa~wmi^M&B$`#Hx/oF a_v 	Kqg$>8.b\w(;*\
s2e|Y^cR,u)uFj)j=mYfv,
PU\%`!{x& {`Z{w@|aSa|
r#{NGwW[/f65z?$o6 N48kV
[c)Dhtu \,  Cn#0qZ'.Ai"(5.)(o6JcH'Xj]0'Tvhs?X    IDATMY?hT&>%D%//
Ov1y-+f %0pB)RkP<c)lFSY<dD,'5-8y'D}/emsAy*a	?6!T9'L+nn*kIG":^+6k=c=3aC52k}K7[ \jg\wJ;/)W)CNQ\Pwp80EWKV3 i/m)O%
>wP8!wsr26DpdQ#7/_KrL)*vP\:}kL|V2YKxCC@?L'Hg:kkGo.hZ}s!h!QrVDkvUV
~8<[1F"LI\TEE-F^/k"
/_G-.-	eLFYj#V[j:%Pq 
S5IoA
gl6L8 55U)9[ 4
4L8uhlmKuT1T4<<k.A==Z+ytE-9voQYR);SN")t<&vM'DW6fJm.|&^J70O@ &0G,.+E~8#GRkWs&zz]R3qQM~ya~Hz%~mo~	4FX
.-Y0k3y7:;%a1_a+BFJAS~JIRkOt	Q?&| @{fiBpr{^0SEu@
)pE'Y` M}qEW?+GM2X*>'B
krW( 3!N*cC<,l),Q_"6$`hjMjj~=IqI*LVjks78V}QR-H^S@l1h8n1(vN.HB$uV;N}FV}Jdhx4&KE"
BL7?g#ooU3 ith%F=B*>v/3b/C"WBt!Qy,\_j XwwPrs'l=1Fbxj[vv"tsVHQ
CzJH5U4$$P04
5^3thJMc:p:&$1Qq4*rb:*?ij2a?7`
	Ti ^"; {+^zZC;;{_NFYCdx.}aSi7+kTZ(gA7XKKI2w4;DuG`}>J3E"$aZKEjcPp@I0|&h4:_- ;lAGqJ*1OHaLfU_lkEE
Ih9&c<)U0{y`'c
po#{XQ,Hjo--QEH,n"U;"!7\%
HR$"d"aq/8T0`S2QWCR2vcS`cJ7S]Q?!G/gg-F(
JJ])sd;#w~A]z&.lfOMEY*S6=	nCiQ),&x 4 '0ol}$PM8%Yxu}c`tsQ<	>	J_3E $PS^]qh:5	Pqs1w0Vb!;"xmb ZIS=D}laiM CkcIg\o$wb;4 K@;s&[DxX<\["DDMSeaRze_;e#8
b4XIH
PEO]4!6iI^ 8_1^c19HQDJ4&I|=O$
_@[+Q5F@J]>u'N:-t~$gaW{qSmKecIW4dQ]L}rG:nv	D~QUZ)lbCtzqt!O3YSb:mn'695.x4_0`Jn}eM<S$q9+2\V tEV@UW?3U,%[< xY8ry' ~R?!oSi9R7C'1EsB
CY>)r(pmsl:Kr"6|)45C dub`["@[ X(7mD*PJW5w+[EDv_AB	.HG_d
k8"\IA17.XXUIQyFA5uAm
*	/>ff4C"O~E='HMZ^z)HQqhsnCJ%p4_@ N@l=!/gH?U
h.MiKk'j5m6Q\C53Tc>[9Rl	DOxl/B]T(FV;C&rC.Q{{hu6}As8z	+;+W-wXZlf1=nG)`i&Fi/O] * 05LUU#LU zr08h ^Kvqwm{SjJ
6OJg1euR@1qq5v/e/5U>jKaCrBp%
C GO'3[r'|uH^~r6U4gP1
%hg+5dopxa#'@+%#Rv#	%Ob%''R4

b;I*In&Dxng^l\6C%.ARI
C.^po.iJR5[=Fu<V<xiM42rk3)+=1Y`s2_]0-aN:aF{R^o4|f*ExsX*)'Z\@kY1vFK)U%8` &`0:+r0C&#D9^Z {gz#pb~B=(yG3#(f,D>Ah'LCmY
<7)/
G{O
_m?_[.8MLE."%C 7;J2CH><dSF(:tIGjn6yxa#hK'e5b3
lsP
7'%`kE0``$?`*<9f4DMX#PJM;X7/lIZ&kP^Fd"i.qb0jfA-&tTqF,!U_@ViG8#;o<_O@|zz,c!8veK^8W=_Gl
QVUHi=e 8{9DY<""hO{$9wnf$CJ/Gy?@>Kt{ bo>*0LIej1*_,^NVv(KA =Z`$?|	:cHX_sP
 fn!Xa5yT=ix!XUyPxej.`,,^)
h46OkMYOoJ{~9>h\~G1 S@7I}V X.x(w;/E\q/&'vSfe$
b0,SPS
v!V@8z;a&9$y"Foc;?MH-H*>Nrd?LTX	)3V
5)b2v%YGwTWaQRvo&m09iA`qE{DGFioN_LR% aCUyJ~i%odp(mRZBkxsX~<{??|{$Ebk)R@?v]]tR0{sFqsxuntna^pRmUM>:V:<kLoIqS;{_82!XLD]<gey>L L`;i2wGxwF
gS7+{bgc
=9&/L
*XMVToM?t4 {b, 50+},2G!xL0}?FH-vPiwr
D9Hn!Z	Y-RFs\gY^D:{5oV2u^	,bO6;0D?IJPa7$)IG]VG$.!T<:zJn%u9OW`%(<UyOk;>"='+Xcr
LUjTVE*#Z&Fd&t8Yg72psvu~|@5W
D@:Pa3%imUo {51J&iKE4wT&4JJXc\OIr#YnOt-v\qx4*]iyXh4
M btPQ6lC]JR)TD|e"Wx2 
51dTQ\)5}kS/W3Lx.}Bxs w8xvx+uYIo-[1ij=$
3P		bZ5i|:F"fO-DcI+3z Me1>vA[+%]=#QS
cK]U='WZ>]8|Dxg5No:L,(v)iQ:Q_b5OK-HH&X_bk.9 0X$al\a?e
txU=Vpgum;C0o~gbc|/(o<f"%Wm*-;-Pazb:LF+7OLNn:@' iHE*Dt"Z PBzI;}oP4 ?y=DpABEN{<6%X(@u5="/upxT
%6BODdiM'W) y/,E44y
p404;
>KG-msBPXyra9RZthUjSr*iX$`< IBP(L?z>V]ATZl
WI,ZByO;F]*qFHz=	*Y3(cU^O<0z>S!J9Vlk`FD}*JSbUp2e$P
]E#IzCq#IY>  o
W
F:
tWf+OQI' x% kz}-`C~{c.cNyc(SMqcq
%JgSBdO]6)g@|W/-l[iXsx)dL[:n%)9
|oHDAH=UVrIT-kI'2F >#U c
#-!j9Hal.?8	&@aoJ(?,0uM,r	5x4Y2f)e1AI])T2l8&oK EKQx~'T[up80<p0 L28~ztZA'ZCa[HEYyQP<>OVyR(nhSb
Tj}VX>j-oc)vMD,|h@gI\fu;HG6VJcD69n#6z1F[IT7p~w}#76/M ?R}Oj6rLh;&aPW=FX5%J~{jF.j@p)rh'2_lNn;Njnf{L9zjM[~Ehd+*^6lIcl=TZm{t>l8_ Q= `2
Z[*[apn#A$O5'C&F9"tz=pclHE=I9;PLzCe*\ HTGn/+ -,e0Az0+iU&o8%=DYD!@`pm*JSE[NlK=>5Y
qhG!dV^NC{`% U:5!(EWBtdb!7'Rl"hxD[S zN2&C",RZ=:(0l ~>}.'(H/z.xz'xqHpjixKV$-xgU	jTo>)o7	7n5H
u+B ,T&f|M:Yb	`vjoDO2^O1/$OR}JqH'hWN]_N%*qCqmA)0@cNC;C=8=|     IDATQ("T!._4+vh 2! 
T?htMbl"C'[}dO"2!qq$p|@nrG0lb\nqaTrJdBG08#`ny8g8
zC7
{4DwAr3?vRmBB7aK)zKAWmZsq*}N&U@s2) ]t{.<k-2GK/dq@ C#>RW;)y0\^v.K#ybPF$J!,,MI _J\i$|]%XKHp'e) _C inx,4^5!~Y_d*qQRx(Iaq5epmm]'!cJ&Rd E{phpK&!iOS`}0?)s
S\~gi-K^S{?Mk](upgRjnXJ
2`wk"!3 58yCSz8qDuD @T#<	9	pcboLh
""}"na@$T/L;df]mR.8@%QAIM}X e'_A*H`rrI(=5q=,K p)ss3[~,_ 2`
^$)1m$Gr"D"'3
US
8YoXX*v!!!sw:F2j~`;j/nDzF"`#ha%V< %O%ld:`m _iL%Nw~P]jtg$\E`%v;E
q[^S+,%)rpVHaJDTWQjW=^BH828JX?S[+7gK4,,B.VI:mlE5mc0)nI 7dsBbOn>1$Jxmg>Y].N
Yi0L;x|'%baH\s0x @$(5>?H	?
x%}g"_@(l&}%o>C6|d,x~:2+Z:EO7d  K8EbQs/or ^@C6e@x\.,Dj(
;_.^Sm%yN!6V 
BG^A`w Krb F!SP^e8h:Yq|S6p{(|vc_1S1.`d(?il+V0F	S
*foy[2fRYy6IiX<SyE8s8m8D')8Kxm@	X$^r@
dj}0s(S Z<m  %RN	?_LAoI<cm!k8 }D|(=
gFVtxAmFSD7]$F<a 2O*\9sN~J(x:g"r # QhX%p
v+
i(G06&k6ZH`C:AdK'D
O_/_2RG  4q#@cy`
4b.)!X`$n ),-`,R!Rr "M #V2Q)  hS}e7QUY@nNIPP "1>\3_6uqHDRZ?$9o 7-}!`9z~
v.|Hz}#y !&\$HBU;'#OTL%!(N@AO;{=8 
 ?Jgo$`"	PrDP"1 3r>[ =6r(b@k|,rMb#beN@cLp,	hi4z@Z%Q4uSI}AV'
B6)re0AJ06_[3Gc,oY&h\"m	;z6 CB@N?	 i7}/}{EsM-<hGx	p3b.;|jTu&XH',~	8*Y^pQaA-}&7 _8SgOYlQah>jH;l86CU#P o|X|?h'/3X6f!1miub<n`Wwy-R%g`C'Vg,r
-^ToC%XlwD=
zdtb.
V /_>G'|ViGwSb7@;BdF0QfD\FKY@-*&   xL|6~{7=wjK~#!>
:6-{NCM TExLjOX!&(t5KsH,I'K9RFH)25qA{<HE}!>	;n)BO]b'*Q^UaI*,2B3 1(HNn* X2z1UzEgos,<BDdu~0}2&q<^]pncUUAq
OFC!z$&/omV rN> NA$: Sw{<Dup5!v@)Zlv~;Jo
|^6d]
*aw7{!s8 {F)p<MX9{+_4
DdBtyI"h+$ H b|u'r
+}	-rF$=Kgi]f7&8RGX1zia\,*c$*"._.mg#rWr4y:t=M	){'[>EC"rq7*j%OaZs\jc@l tYbx-=6-xP~H0Ns8~{nzGN/'P$ `o9%E{{.N,|	l/xa)Psra0zR20pj3aLy$0a@dn!8*N>k('# F#W% *Fay>8qfAg}LFY~8Jc
=v
bI5rA"qd:9W.0!t|D8?]TMc>bJ/DW)K3v3y ,Ru;vQd%%'*2yo@q@]vKj
p(ndG_x!![8L|x"Ynq`k3){U ZC\
`.}' X7]/dG
U"B]`/D
v9]@Hk3!tr`z0Cl:Y(,DX~0a.!#Q{a}FJ3?-:v$S8] !$o0N>@hD%D>s0rp{
fL@ x=jJQlRS`X;i-
2Xa*q+@Xum~E
O g~
v/](RUAEJ|ox?RjjTj,K(z6'`q w^{.\(Lo[g  H|5L|' 3.FhMyZ=DI4
nKMk
	o%KaYpwo7LyW
@)ON&Ni;(O0YS1Fk.XJpzHA7nC]OUpO+@9AQ=A^;Z/RhXe\X= ;e3};E). ha&RQbyd<,*Wxl3rbu.W:3jWSysTcBGh_OPE&1xhp4QD"FF,AKdAA~.5 ?"I%Xo?I]f~72j[v}+32c.]lT	D?lJZi &>  U ~
h/>gE&[v(G'UXT0mT*;}P~(\pR\2g&!TmVWK'8v yT,+nO8mBVwT_d9 =6d' g`JpfN-v_n 0:v@,t@ fePuor;B!Y	]Ofpr)HyzEU;6sY~rKqz,>1pncn,o6 x]-\_tYoN/w	@? wA n@?8ea X}0ihr31pq o~tfWBO]O'2HE~RkZGc2r-\~F'/WXOeE-oe<{&I
O]KwQRj+	N\)c&0H|b
Hihkp8@ D"@C50PshB;y(o,l06)XxBe	x	]nG6~=*X-lppvwiO*
ixZf$$%KR B$C_' ?!$Ol ?0J=ct[Zf;h>,p?Y'>4D^v(~RqBXZ:O`X~
 hc nCpQs,T|B",ANefb:?k `u"l!77H809U@Hfqnd9. G }0_s`<txf%L,I/&X,j9dMa%QH8g<07nDY6F;Db,;}w?v [Cu-p1D',jq5j5+O[O@{@XJ)K9m=057j4iRACW}]h> "RDg3GX"^D
`h
Jb&X6wEB0*vo~8 RW&# j4A[m{,5np|1aLxJ0.]R%c}f YgQp =!s(x	0m JD!r\@2#:|4spg^>c!eSf 'M<yIuEX`n0@O'\.:]pb(`4n"	CQE@,ma{`P|p]Ad$2/nt)~EQoy+<qz<HX]=^odGa)(>!>-J%%<P}|4cTD1qcDjW9oV%CJl&,[|VSu%$g4dtQpm!8h?SI(yf#v1MWmRaA6?/C2 .RJ?'Kc5`]'-D\
`wcZK|
l`;skL<6mxlb,>b	H(,.m@	E=n?kY^@R4`Z+zQ0
$
 @VXOn3|"Y-<ld}v+Y3;O: "%'ZL"RoQ`S9
'gdS7)l$)I(EViyI3eR; vH
	J*9dR3 		C=Mx{C[yEYplAX|ZxZw3Ti_
\c>yd[Wj0\R,R'6 2+:>J*	ap9cXXo.6I>SL*@,JD<i"-_eA(|+B^A>W,
wh  &0I0%s*4t%fe!.`)ptzK
 S`PkYd\jF>|2C^I'ag'1daXMPN,shWH-Tb0liWW__ei`'6czx"vIP}C%bhNv td T{[`Wk*:DPiY>#nX'P]gIj0^s>nwIQr  /2>N-7a
z^c>0+8hODw `zO@
dM6\4IW@BFaAb0 dDX0?e2<P] G;O	SKCMx1Q
b/9 !qT7,j(E[
zt-ht41.` k78|Y4'I8`e-,PI<{L&z.@g

mV bM f%( qx,|"9<EU~g@9"fbt?SBN
+ \eTw 'nz4$D|:`.URUOO0?dq>T&@D    IDAT4%~8 (I6F"I4 me .z/z Zao:SqQDgsRLU4GmppN,o.S PNp F$C@8U$`7XTO6 'Y;O NdB%i]>p0](T{G`$
1 PNC5_&{~ZhO#AJjtAF7&xY` @	gPgufO'`A"~W,VRh926 3B[:vj0 tou *tiZ g	 |!1 J !t6xK*8/a VdZ _v: P\7qEm5px8U	 L
*k!TwxB<5ZN+@G>vHs XL El7/@|X(f>c P 69stja jr[qO~"j% @9+O@s?@(BzYy~g)@/p^Z .XVH@1 $ ~i :k^%KGpc`
ZKnRb6 F93Ut_niQ*')v 0P`a
D,prXBd.6j3##cm (fjggg^r# fh`Sp:@Sj ,xe
 !8do=h_;Et	=[ .MhDW_w+
Q [[K@z*}D	uH0>bm 6  % xn5thc4(]7yk' 0|u|Y{6X;zOm'j}%"/lU>Wrc B-8-d"YWR2
 w}WLRHMz'I ]P 
U_H1Pj4nK-tft`O1d l 6 x
ct*gL6zX d@/  6$>	#	usU)e
 :tjUyI Z\uh ^
erg@0
|iMR>)PHWzkn5 N*m4O  BN yQ 8RC/l7T\Ye{c)2oY=2)S 0l01c&:}^w[kc!cU'aPXgILP!_D0W/D4*81,
Pr%FR!@Q] (@?K	uJ*(5Z}	 qXF@e,pK"s{`$QI`ma%e7VxlS @3 Mpl{B1Gs/6lT.c2 86*U=&%>w J CR JU0<b)~NC
<N_Y20Cut \z	@sKe~
r>Q7Q@n@#]tU	-@o.0`)<R(U2#}4#44SN}a`YdnJ9i  4,2/s  eZ9i"ATr^R97*yFwr
 4;A .SYu'Kp ;(&8UL3~jA/;EMh;0C"=c6fZRK'o|AIU>EEEu"H-[
m5Xq}sCQZp
  J"zk	~0NhF0Y T  h!^YdP6Ie1C)i@ XZ5C)/K*	h\
vHG`!
0\ ^z>N*sZj3`S]w{)]s76l{y!zb&Q>fXW`rVZ/  yJK!}`5&.,1@ Y)HNs@z< + @;4g8Eg-hGC5'{IgL;M6 6  r7!	  m7m.6[NddnRKx]VJ{.m_k~ yXbF14}%E +q 5Tsah$#M $@	@ VaJX5\"S\ xxA3*sc
rAS ,>
6! |	,zW$nAL0)K @l_ZN?ku>}9YyyE!uC itwpB@~s'asY]Q 8-J^W48.C vM
#WQ
8*%7UK EH3_wq~{
`j O9Hu}P{p*[7tP.rH@^x)~ Yx6t,dzB|}}
|^/sd\(pN22prri@;;
x	rP/;J| HE| &Bv
sbAHAF>M?$mk6X3b% GwF5
*u{Y\%ewa7X6t|#1>R_
"ZqNO)vH4.e]6t0R
FY&wAs-Ro9%_I 8LUVvw PlBkdZy&K61
0syEFq41D/Xx;iC
^?B
v<E"EAMe!%uG'4vPs+<G`GV#5)Z2=xC)c"l%4y/wg7<d*T#=XP>J}[e@U?tC^z;( R/U-tCUDx6YX	))D
-Bf,$H#h^N$!E[gnO,mrsof4{rE'g# 	9U.T3KE;E.lTS3|H"RA#]~p0T9x/J1>S>bt
6r7d/<I	~q{pTDhZ/c{5&yIy5stCqq/jmh8q5b~$ E.^w Q6Jd68I&]d!
"

Z__}Zohbq, 0l0G|s32ZzLuzQSCCX_qa(,\jnHUb:>Nis^ViZZ:k3?=iT4R0gzU.	;uDWYg?+lXLX+[39^MbNn
5KpdaV?h'+D4aOF4yh6uH0Rp)>@ k;W\#GiJ*7H5XhU	IFy<_;GLRi~[M8,=cgotIY."6>`PJJY V~*)@d6cN*UO_'|H @K2x\TFhP.0_X?j
lmQ}Bxpx9t nJe$7dsHsJPxq8HXpip4&U2n , P^a,~*zj9-B^OQ;TVgvI/Z9\ko-b$	8_|otp_\DqYpPR,w
riVRVOBK	1,&|4x[!op'/vpzq"qP(;lKwmL 4 DEggoWQ]ZK*2DO<r2vG2R *}bQ3YUZPqT201`%(Pv|
iYWYcz'T+8c<,~~>b06/bCFAx(<1]u gC|
JS1#NT6LeqY1Onc<5I[x
'r8qhD(t"	L!%}JV5Qr
 a3d.W$
   l`ok$B$=]_v<8(>KTI#"
r)fJr aw.BOuxf#
X`TV5Z?, }2dH M/ rUVcq&M0X:a_
y V( PAE8d_<r6)-U>yk&7 	5J-	G Pp eHaK	8kss0|w3UP
-D/(@":76!<Q j ^q< VZO:pp4\BP:@;kAnj%I%C P)

?* ad"P09\J;#_RAj1dp,#]6jR
EK&E7=h3 ~~ @Q `P0(,ASTJl:2
 1117m4QI
4
'oK[ ^mC	 [}exTe?I5WwZFq 
T .p7CNnU\"{GuD:)@~< xR8
/ P(Z
$n?ncVQMITtDlL@>}*?/=*7Hx^W|DZ?3P0  DhWeVx,k#[^U@)\sM m aUCJ3Hh#AOV"k2_9bAY}

%P(iT>
 +XB	Cn@B\a+fu
r*VeN0((u,Y*AU j.EM-odr1g;T1 d4	z(L>A@`[vw*	@ CmC<& VO6h05 
r ankX_"y =YGjjo<xkx_zk p$;[P7
j	uoHtyW?z&z>f nh( 40]iM3YuJuK `l`n17nxhHdSm6aI <U%fSK7atYmwo8jWWM6Mef[h;:E+[AT2@  
g[V#Q8gQq `Fc lfS_B P% T <&%/6\YR	]v)))>oh20C|73?@}P5:J{UEq9 a6R3_UvUW3F .-9$*S- /2 @L01T7D4&X/!8vp/BH))se\u7K 8UV}oS`&;rLl=m"Y7mn Q	*#@	AIEiVQz*Hijd2(,ya>$7`	LdCvd4vvjH@E+X@p~ib&$ q]m}S7 DGG'goZW Ew84y_Q"` 
2X)N PE0%C c_PFB(iJ/P0Hkjl9kOC7 ||"urD	
If6@n]"h/8n
 ,X`p@1
JTV
PO;-bU.m}6K
F$EVml\,J  "d/U_9	iC tDSJ@,u~#XfLm
;h>
X) rY*U' !.(cZkpJ!:;<c!nALhT	 5_29"o$$ ()\kJ Kv[Ys
<HQc1E|@/w;x\9k V)  av}Xwz"Gd'[vxYlj} G`g1l&_sz`c_cz>FM$U{z~
P@LE -` 0D0 }XfIz+v}6J5FJ
u,&:oe {$K_bKk3!
Hh!+}&v
f7RmV*U@IDDq>F rB+f>Y#GAt@`?	q<$Ek9' $KT G	
C4V@I#rTTgzW{ B*T=,4 0eA?yD:t|j_,=w(8<P`:Q^[ G62]\r.[IdxLvlf+<_Wr%5u`&'1qPN70xG{6}2_KOFo$@.5,Rb6B(*CPSK0cTb;x#o!p#{  Bxx;w_(I7*42XW\HYkXTc&J~vp$08
 *EVm|kyO.-6{5bKoZauSNxmjAHA    IDATlt X>GV!aA}@e>N=i!{y/4.H#O91	qrJ&'J)?GZj}YN/\P
N}g|"R"
LNqlQ'_~_I^Vt,*9PR:  uPrCO>Ab_P(7 IB>?rFUt??nFDI-7YEx7M7cn%nzm
 p,7o!kjAA~!D'UA+w7}yU4WR[9iVZP}2 {y)z=g!Bo>dUH}B8HA28k	xY5{^U~4U*
$NF6h
1DLb II]O:u
7%y/4aig$	 @X\}$cRGLmI:B'W?/(K5!]
LN5(4R#J6Y=AMHMFR.e@\woMDx#OrHX!fn;YZz?~Rg&{.+{Z=G^V={
1Lo&l$~M 
<{*ouC~aK ybPuGK!+5Yes'cpS $.S\JXH%f
2e`-_vT# zx%pi_*PfXl
1%fE;^x7% t\tvQ,*KA"<&C33$&}Xm6vHkCP.Zj?fC}.pG q,c$]|{e	H)l,<9X$ d6Apy
wau
Tzqa58| ~8&}G ^OAxts\FV
E3!Z6Hb9=`4
 ~;~b [:Nn6.xEw.!E BHz` :Q, Xmefn2 H|||M6W	'CNU@!rPd/	7].3{&nUV\yzAI$<"  TV R= 0v,)pa$&I? .# o{_`i]_ThoOOjv44y..;`3` w^OvYje 0 J F$AF!6QFtW	(Zw@t \-NO@
^&;,UJw`on\ju[,(,5o(.zN"a2,=)=)T=	kl{% @)Q$ &]  w @#foX:4,/ fFNgqSFwM
 :m3mHP0_DVQ8mJh yA@OvQV]kVP'dP"&FZm tHg	 -fRt31 ;LM_ c`n X	/E>{C
w(GZGJ ^yLW PJzvO9YK" `LFN_vjW (S M1z+V7h6>Q9{g9Ofj/=Z>
x
s@7
 UcA@r7eiH  5 d 1]X#][GHj/o|8E>zd~X"f4	6O?o_Jy|nz 9a=5!C`h$g$f@,4rfm ^ewX* (.j-I2_F PFK BlMFI TE?67f&H{q$)	;!>>9-ZEsv} <55ssy$qOzG@;3NtS@sF*iis#a5  * t=q;<M  /fXE/ J    4Z)l8jRni`K(YjOlg+n- w)g
_t[
ovk$EE7n"|fJ(]dV@7 87U j JDZ,J%4n?7?d8@9pziC?~Ygr 0s/ofTI% \HQAgYHG-Jafp26lI'  ^QNd|
*$ atFg_!qY}9+ *V8_zW^p> SG{\>
AA)_55mpf tJd` 6&~
9	'/h]w> %0x[]n@T|Q1`tyyX8d.\<y
x`Q3K[
 P
2r=!P` Pr1S601=U. AC.
I@=w7  	-
V1y7%]rj~6  B*-F8<9@
d 73qd=AoO~K vI&leLaAH*2}hgwkNO=	#GA-!d * c/:_Y 0zi>7
>P0WdW3'N}Om(Q.Cg]a3ypGOd
?a%[ 0d	?=Ok?H q+ s+$*8UkCP`VIg9
.n q"FP.6p
 ?:Bhb]"A.vB
@I*bVXR`AVT(_q/  ;;{s# `lZA!sW)as_.=P3fa7 5tz{A0 

Uz	C=/_}`u:T>4x1e-sw2`I'l7x b]v
yYP}}rbcXld/iR*F'?z=Oja,mN ;,2%fqX9]b[j&3XVptZco"YtL(ml@05%R<H/~w7c`6C+prI"7ar9d8{XIv'jp,N kj
SbcTZc}g7%oI7-	 :Yv/WTz)}!BQTEc
%J!/h	Y

J3CE;fc
|}lPy'CWtx(?z\W\Gi8l>6(W<I[M3=94K
Ui-&D3P[(Z=WZZMW_\w m}r4D/	H^c~pmY7nO6 $:W'[l{V+joY NwKtbt!f+$g*
ZB!9VGRKh8/@ppuw}w}:4? 1MygEST"$r!'j1m;_hLKy** et@"OR'$Wdzm'	nLHS*7f-Dd!P?O' R4Uppy8$OT
&JxwPl:bX[1~)<"uY?{x~2z(Q>v
3X]pEXvziv'
8r.-Uh+D|:0g No
 :}6
L0`f<g@ 
Cv;3T%~?+;z_vvMi"#!13uaJn]wxO	9f
h 5{|F igV
jO? < `kn]f/Wf'a($OS(0@_/`dODf]!I3U;oFHg3@rm|X[wxl0,BE^mEq3/M	>ftwIob	Cn~Noo2d% 57xe=q:VOahpg
m<Mo7d|m$|^"J>M===Gfg"Rg.,XPB"lJgET|_a4
['=%X,wycmLDu&t3wwvU'L0To^VhjUs\l^6/x V'B7,)/FC*oe&tkUC@AQA/{y uzW[*}aAM/ex\6^p|&NvNK?\L,G @v+O@[I7k5$TOK .W,KU(QEP QxSN   
 dEm
r4C"  H!vbji{`K U-=d l8Ec`kWnQ BNAs33y[@jA<K F".u6 4
`eC  TI@>|u>D.
\k5E2be  ]4,K&\f^n$RCo]  W_-?a_;z .	xstNF!6u snP,	QhFzZ	 3  B7l)u$J4F0Zf?
.*7fdaXa*_.0 Ww7Jonq 3r_.a}'|!mh|`bH]R^ug,YXVO!{LN6+m  V5Fhv[ {cPjyw! X},J9PPvr\og=nR__}X%	 8liT^^^	G%
u+@^`L ~cn8$kztrC+YP6Lja6 Rzv#U"aWR xbpy<<H{U@@TX4ld%<%l[~?lz{{pX EjCwV[[BV#rR(F$_l41)^'pCP,4 nma]#$zR7>xyHF@M
+>]J78.Xt7ftnjW?3cUsO<(Zq/-* *@I Fzs_u@?y?tq $` K	W=% 
 A3`>~tM? ppVpF% N{R$B#C5i7MF7vt&@ `l
w+b+; 	 s8wj o+`")HLtcK,{ZfZ[m6f= $
v)/!$B L\Y4L&{pZ1]ydtZ`	 z^POyR|
FNb`;aet? HSt0AE4z533~]2 k|k:
mEftHh`S$ 
["yQ 
W{7_p.P`q 'A24DAiiYj[n'p=
66p =uaZbqYk3VekE Gpa7;ved'"" ] lCI"c_u=gX=|*B)5hF'#l(0v**[ O	|:Y|c6Ahh91c
s j.L)'LL,D!GW#PzP\V%Mx\T
.BZ}tr}(l H@
 W9E[=P_==umixpi EET
p7ig^WN@7j		Zed9?
Z>PPX(rcL<#}%u/CZap`S<^H}:5i&19[
,7
e{ajPQO,[f-n6 Nll[l+F%Y&|q wuytKt8  j*1Q@RUtF?5sj2[M`o20>PDqL/"pD9gyq/`=w`*
,@hnv)[I~_
k#Dz7k% O&!TykCMA5g".>".\HcF?"HOik6QQQKKuz_
0CAaO"D
|LoTJj[/JC@ fR3%"X	F#wnz'fj^
b Lv8~b[qEB:t]zzXAO pL !To+eW^o12a`@1`R!=3A7v  IDAT-H|
Bf
8@nK6I2P}v :+>aG I0@jw@x6T_&@~QZbXh@2(3cT*54WVk<k& >kk$@q\.*g}<31	1V?#Mi3N4a^dx9y)F@|%@T5
q0RVQm~BL|mp#R	 '
X_
cpw3#>twD	 
YsL[%k) pJ":ui<M**B *+y7:z2&+8#U8QZ;9RFJW?
/0,PFH% Cs'pVbc	=lV"c	n]XROCF	(0o#G6imU{AW7/`Cn $ay5CW, ["w?1.gLDgtK0Zb~99t"
kpq"EC xJx<Lw!<]miC*O-=viV=%hPS yvr\SjMj OcEf@;9W;zviO0bvHsE
	Ad+W~JQ$	^':
_*:D6uBR4earr0 wQ(;VF^cI7Jd>MI& &x[Q
 ,4p
SXvn.*e
?Tj_5,}dO/&&O2$P@lo?Hp2L._^^0sLpf2A) 'W-[(?O1cSsssss9fyB@SS3 hEOA_.]evRph!,XPfzLstvIvW<r3$vuVdC\ndZ3A5+BT^xD~*f6!]*''g'q=]\yBmhnG0 /[>'=#'?d
y=A  puZL,GPx?J<7m3A`%)})\a[_G3~5c.& &'Fm# V!`P0cJ,YM1:/'P;h8p&@1>dRYy$T7qdPq@4D\
'PpRfD	q
:H0w

viUx(jI0ny L	7~ @Z7$P^NaUln&xya"*W:A.6&}MM\xB-Xy@o'#k+`?~


Lf^"~
DX!x; :d0f o'D akl0-k";#aj7m00']iR@7%P
'-u	q|5>G~GA2 )))!Gyv-D'"@gc\Al^@`3p  xk"T|i;9Nm:Gq@M%QqCYSS&4~|+'N\z```eAGrVPNT|$faR8Q<+t$P!5sOuNv~":  @6F
%WA3PyL(^}Fbc@BAtTLjVV#U~rqk:?uvZUzO%Gj8N	iNod<C[66IjT8$l?~
O/H2AfBC~z*[x:{I^wo=
vwUAAbEK+ikk
$j365WrG d<95 n?Ggu] /UJw_C[S]
)#	RSpPIovt})pG%4iK~Zi@!Q
FLq?"Y An@4K7=>-+t='Nwq:jY`?SN8$7N$xX>^,
QD|N ?\$`	|Ny]VxVZuu/N
a
<{7~m0Hut	C>JHx/:0:1Yj9^'Bwb~'2DP||4"CbpY+meJ
;wLJmkXX|hL( [I"=HtGP)py`;gw
BO}fvckDwh8wKRrH&fR
b{/z.g
6|DWCnBR(L+<7Gj #J2%amFFWs]J90vDI%&']8wC4J9 ~FlD?.(:SGz
%04eWv]V<\*vz	J}l.L <?SyBNCgT!c@hz,t*wZK;(`I@J(Q Pm>z
o#k.\@(C"<v=[bU-CqCXc^#^ F:x;eH
b
^:Y
.~qJFur=r? g;kw= z;a)qE?64&c/Z"d
~r7sgpQ'
E~FX|fOp9dr|p-nTUq|ifkmZouJ@P	n!AojEj[[[ +h'@">+?>g/GFV~?##?y~tL t=]l6Wh2G9cH<aG8AfJk +81(*P	qW\&{(@RSSC</ojJ/PkuwL<~G 	mok;7pnJ{i+J<h4C>\b>fs}I& .wQgobs
WJ[O$ =Lfg<( % &_2Tr%yJ>}-	rW xHwuaNC3eg?{aD _h_E.xS3A28P=LVpS3aa|eG& ]i^{Kg2q\u;|{f;0j /
]+vCjOk:D<;
JrJp9\k83,
J	n2	&lIOO*z#(G,7%K=jpbLV~j
u%uxUw:]=Tj
92|CZZG%A`My
&]|&z}W\e)_p4D<U2I36nXl~  =s]j5333_(++{y!vA"Ds'tAAGD}xR |rs
/,,\zn^KKk0%vW@jx[f;{gR	.UQQr.zcdp>32Z722r_{4 }g^Ieee
O5%=_\P!L83un=<i& <a:9GW&WU][t'L&A(r}	M3gW3uk)3)+<Q97o.mink0Q>U L&3j4E!!'$$f@n0at,X0|kU)---#PaK(>h|/81w%Chl.;S6/_<7mQ?gO)t	 ];f#;;C
R,f9=   dx
0K^Q}
0>XKF    dx
0K^Q}
0>XKF    dx
0K^Q}
0>XKFv+h4r    IENDB`

--------------------------------------------------
// Full Path: C:/Users/anon/PROGRAMMING/C#/SimpleFirewall/VS Minimal Firewall/MinimalFirewall-NET8/Backups/v2.5.5 - ws/2.5.5.6 - security vulnerability fix 3/MainForm.cs
--------------------------------------------------------------------------------
using DarkModeForms;
using NetFwTypeLib;
using System.Diagnostics;
using System.Drawing.Drawing2D;
using System.Drawing.Imaging;
using System.Reflection;
using System.Runtime.InteropServices;
using MinimalFirewall.Groups;
using Firewall.Traffic.ViewModels;
using MinimalFirewall.TypedObjects;
using System.Windows.Forms;
using System.ComponentModel;
using MinimalFirewall;
using System.Collections.Concurrent;
using System;
using System.Collections.Generic;
using System.Drawing;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;

namespace MinimalFirewall
{
    public partial class MainForm : Form
    {
        #region Fields
        private readonly FirewallDataService _dataService;
        private readonly FirewallActionsService _actionsService;
        private readonly FirewallEventListenerService _eventListenerService;
        private readonly FirewallSentryService _firewallSentryService;
        private readonly FirewallRuleService _firewallRuleService;
        private readonly UserActivityLogger _activityLogger;
        private readonly WildcardRuleService _wildcardRuleService;
        private readonly ForeignRuleTracker _foreignRuleTracker;
        private readonly AppSettings _appSettings;
        private readonly StartupService _startupService;
        private readonly FirewallGroupManager _groupManager;
        private readonly IconService _iconService;
        private readonly PublisherWhitelistService _whitelistService;
        private readonly BackgroundFirewallTaskService _backgroundTaskService;
        private readonly MainViewModel _mainViewModel;
        private readonly Queue<PendingConnectionViewModel> _popupQueue = new();
        private volatile bool _isPopupVisible = false;
        private readonly object _popupLock = new();
        private readonly DarkModeCS dm;
        private System.Threading.Timer? _autoRefreshTimer;
        private readonly Dictionary<string, System.Threading.Timer> _tabUnloadTimers = new();
        private Image? _lockedGreenIcon;
        private Image? _unlockedWhiteIcon;
        private Image? _refreshWhiteIcon;
        private ToolStripMenuItem? lockdownTrayMenuItem;
        private Icon? _defaultTrayIcon;
        private Icon? _unlockedTrayIcon;
        private Icon? _alertTrayIcon;
        private bool _isRefreshingData = false;
        private bool _isSentryServiceStarted = false;
        private readonly bool _startMinimized;
        private StatusForm? _auditStatusForm = null;
        private CancellationTokenSource? _scanCts = null;
        #endregion

        #region Native Methods
        [LibraryImport("kernel32.dll")]
        [return: MarshalAs(UnmanagedType.Bool)]
        private static partial bool SetProcessWorkingSetSize(IntPtr process,
            IntPtr minimumWorkingSetSize, IntPtr maximumWorkingSetSize);
        [DllImport("user32.dll", CharSet = CharSet.Auto)]
        extern static bool DestroyIcon(IntPtr handle);
        #endregion

        #region Constructor and Initialization
        public MainForm(bool startMinimized = false)
        {
            _startMinimized = startMinimized;
            InitializeComponent();

            this.Opacity = 0;
            this.ShowInTaskbar = false;

            using (Graphics g = this.CreateGraphics())
            {
                float dpiScale = g.DpiY / 96f;
                if (dpiScale > 1f)
                {
                    int newTabWidth = (int)(mainTabControl.ItemSize.Width * dpiScale);
                    int newTabHeight = (int)(mainTabControl.ItemSize.Height * dpiScale);
                    mainTabControl.ItemSize = new Size(newTabWidth, newTabHeight);
                }
            }

            this.DoubleBuffered = true;
            this.Text = "Minimal Firewall";

            _appSettings = AppSettings.Load();
            ConfigPathManager.Initialize(_appSettings);
            dm = new DarkModeCS(this);
            if (this.components != null)
            {
                dm.Components = this.components.Components;
            }

            _startupService = new StartupService();
            _groupManager = new FirewallGroupManager();
            _iconService = new IconService { ImageList = this.appIconList };
            _whitelistService = new PublisherWhitelistService();
            _firewallRuleService = new FirewallRuleService();
            _activityLogger = new UserActivityLogger { IsEnabled = _appSettings.IsLoggingEnabled };
            _wildcardRuleService = new WildcardRuleService();
            _foreignRuleTracker = new ForeignRuleTracker();
            var uwpService = new UwpService(_firewallRuleService);
            _dataService = new FirewallDataService(_firewallRuleService, _wildcardRuleService, uwpService);
            _firewallSentryService = new FirewallSentryService(_firewallRuleService);
            var trafficMonitorViewModel = new TrafficMonitorViewModel();
            _eventListenerService = new FirewallEventListenerService(_dataService, _wildcardRuleService, () => _mainViewModel.IsLockedDown, msg => _activityLogger.LogDebug(msg), _appSettings, _whitelistService, _backgroundTaskService);
            _actionsService = new FirewallActionsService(_firewallRuleService, _activityLogger, _eventListenerService, _foreignRuleTracker, _firewallSentryService, _whitelistService, _wildcardRuleService, _dataService);
            _eventListenerService.ActionsService = _actionsService;
            _backgroundTaskService = new BackgroundFirewallTaskService(_actionsService, _activityLogger, _wildcardRuleService, _dataService);
            _actionsService.BackgroundTaskService = _backgroundTaskService;
            _mainViewModel = new MainViewModel(_firewallRuleService, _wildcardRuleService, _backgroundTaskService, _dataService, _firewallSentryService, _foreignRuleTracker, trafficMonitorViewModel, _eventListenerService, _appSettings, _activityLogger, _actionsService);
            _backgroundTaskService.QueueCountChanged += OnQueueCountChanged;
            _mainViewModel.PopupRequired += OnPopupRequired;
            _mainViewModel.DashboardActionProcessed += OnDashboardActionProcessed;

            dashboardControl1.Initialize(_mainViewModel, _appSettings, _iconService, dm, _wildcardRuleService, _actionsService, _backgroundTaskService);
            rulesControl1.Initialize(_mainViewModel, _actionsService, _wildcardRuleService, _backgroundTaskService, _iconService, _appSettings, appIconList, dm);
            wildcardRulesControl1.Initialize(_wildcardRuleService, _backgroundTaskService, _appSettings);
            auditControl1.Initialize(_mainViewModel, _foreignRuleTracker, _firewallSentryService, _appSettings, dm);
            groupsControl1.Initialize(_groupManager, _backgroundTaskService, dm);
            liveConnectionsControl1.Initialize(_mainViewModel.TrafficMonitorViewModel, _appSettings, _iconService, _backgroundTaskService, _actionsService);

            string versionInfo = "Version " + Assembly.GetExecutingAssembly().GetName()?.Version?.ToString(3);
            _mainViewModel.SystemChangesUpdated += () => {
                UpdateUiWithChangesCount();
            };

            settingsControl1.Initialize(_appSettings, _startupService, _whitelistService, _actionsService, _activityLogger, _mainViewModel, appImageList, versionInfo, dm);

            settingsControl1.ThemeChanged += UpdateThemeAndColors;
            settingsControl1.IconVisibilityChanged += UpdateIconColumnVisibility;
            settingsControl1.DataRefreshRequested += async () => await ForceDataRefreshAsync(true);
            settingsControl1.AutoRefreshTimerChanged += SetupAutoRefreshTimer;
            settingsControl1.TrafficMonitorSettingChanged += OnTrafficMonitorSettingChanged;

            SetupTrayIcon();

            lockdownButton.BringToFront();
            rescanButton.BringToFront();
        }

        private void OnQueueCountChanged(int count)
        {
            if (this.InvokeRequired)
            {
                this.Invoke(() => OnQueueCountChanged(count));
                return;
            }

            if (count == 0)
            {
                _mainViewModel.ClearRulesCache();
            }
        }

        protected override void OnLoad(EventArgs e)
        {
            base.OnLoad(e);
            UpdateThemeAndColors();
            ApplyLastWindowState();
        }

        protected override async void OnShown(EventArgs e)
        {
            base.OnShown(e);
            DarkModeCS.ExcludeFromProcessing(rescanButton);
            rescanButton.BackColor = Color.Transparent;
            DarkModeCS.ExcludeFromProcessing(lockdownButton);
            lockdownButton.BackColor = Color.Transparent;
            lockdownButton.Paint += OwnerDrawnButton_Paint;
            rescanButton.Paint += OwnerDrawnButton_Paint;
            SetupAppIcons();
            if (!_startMinimized)
            {
                await DisplayCurrentTabData();

                this.ShowInTaskbar = true;

                var fadeTimer = new System.Windows.Forms.Timer();
                fadeTimer.Interval = 20;
                fadeTimer.Tick += (sender, args) =>
                {
                    this.Opacity += 0.1;
                    if (this.Opacity >= 1.0)
                    {
                        fadeTimer.Stop();
                        fadeTimer.Dispose();
                        this.Opacity = 1.0;
                    }
                };
                fadeTimer.Start();

                this.Activate();
            }
            else
            {
                Hide();
                await PrepareForTrayAsync();
            }

            _actionsService.CleanupTemporaryRulesOnStartup();
            if (_appSettings.StartOnSystemStartup)
            {
                _startupService.VerifyAndCorrectStartupTaskPath();
            }
            if (_mainViewModel.IsLockedDown)
            {
                AdminTaskService.SetAuditPolicy(true);
                _eventListenerService.Start();
            }

            UpdateTrayStatus();

            await Task.Run(() => _actionsService.ReenableMfwRules());

            string versionInfo = "Version " + Assembly.GetExecutingAssembly().GetName()?.Version?.ToString(3);
            _activityLogger.LogDebug("Application Started: " + versionInfo);
            settingsControl1.LoadSettingsToUI();
            SetupAutoRefreshTimer();
            UpdateIconColumnVisibility();
        }

        private Icon CreateRecoloredIcon(Icon originalIcon, Color color)
        {
            using var bmp = originalIcon.ToBitmap();
            using var recoloredImage = RecolorImage(bmp, color);
            IntPtr hIcon = ((Bitmap)recoloredImage).GetHicon();
            try
            {
                using var newIcon = Icon.FromHandle(hIcon);
                return (Icon)newIcon.Clone();
            }
            finally
            {
                DestroyIcon(hIcon);
            }
        }

        private void SetupAppIcons()
        {
            var assembly = Assembly.GetExecutingAssembly();
            using (var stream = assembly.GetManifestResourceStream("MinimalFirewall.logo.ico"))
            {
                if (stream != null)
                {
                    var icon = new Icon(stream);
                    this.Icon = icon;
                    _defaultTrayIcon = icon;
                    _unlockedTrayIcon = CreateRecoloredIcon(icon, Color.Red);
                    _alertTrayIcon = CreateRecoloredIcon(icon, Color.Orange);
                    if (notifyIcon != null)
                    {
                        notifyIcon.Icon = _mainViewModel.IsLockedDown ?
                                          _defaultTrayIcon : _unlockedTrayIcon;
                    }
                }
            }

            appImageList.ImageSize = new Size(32, 32);
            mainTabControl.ImageList = appImageList;

            Image? lockedIcon = appImageList.Images["locked.png"];
            if (lockedIcon != null)
            {
                _lockedGreenIcon = DarkModeCS.RecolorImage(lockedIcon, Color.FromArgb(0, 200, 83));
            }
            Image? unlockedIcon = appImageList.Images["unlocked.png"];
            if (unlockedIcon != null)
            {
                _unlockedWhiteIcon = DarkModeCS.RecolorImage(unlockedIcon, Color.White);
            }
            Image? refreshIcon = appImageList.Images["refresh.png"];
            if (refreshIcon != null)
            {
                _refreshWhiteIcon = DarkModeCS.RecolorImage(refreshIcon, Color.White);
            }

            lockdownButton!.Text = string.Empty;
            rescanButton.Text = string.Empty;
            lockdownButton.AutoSize = false;
            rescanButton.AutoSize = false;
            using (var g = this.CreateGraphics())
            {
                int scaledSize = (int)(40 * (g.DpiY / 96f));
                lockdownButton.Size = new Size(scaledSize, scaledSize);
                rescanButton.Size = new Size(scaledSize, scaledSize);
            }
            lockdownButton.Image = null;
            rescanButton.Image = null;
            using (var stream = assembly.GetManifestResourceStream("MinimalFirewall.logo.png"))
            {
                if (stream != null)
                {
                    logoPictureBox.Image = Image.FromStream(stream);
                }
            }
        }
        #endregion

        #region Settings and Theme

        private void UpdateThemeAndColors()
        {
            this.SuspendLayout();
            bool isDark = _appSettings.Theme == "Dark";
            dm.ColorMode = isDark ? DarkModeCS.DisplayMode.DarkMode : DarkModeCS.DisplayMode.ClearMode;
            dm.ApplyTheme(isDark);
            rulesControl1.ApplyThemeFixes();
            auditControl1.ApplyThemeFixes();
            settingsControl1.ApplyTheme(isDark, dm);
            settingsControl1.ApplyThemeFixes();

            rescanButton.Invalidate();
            UpdateTrayStatus();
            this.ResumeLayout(true);
            this.Refresh();
            lockdownButton.FlatAppearance.BorderColor = this.BackColor;
            rescanButton.FlatAppearance.BorderColor = this.BackColor;
            lockdownButton.BringToFront();
            rescanButton.BringToFront();
        }

        private void UpdateIconColumnVisibility()
        {
            rulesControl1.UpdateIconColumnVisibility();
            dashboardControl1.SetIconColumnVisibility(_appSettings.ShowAppIcons);
            liveConnectionsControl1.UpdateIconColumnVisibility();
        }
        #endregion

        #region Core Logic and Backend Event Handlers
        private void UpdateTrayStatus()
        {
            bool locked = _mainViewModel.IsLockedDown;
            logoPictureBox.Visible = !locked;
            dashboardControl1.Visible = locked;

            lockdownButton.Invalidate();

            if (notifyIcon != null)
            {
                if (locked)
                {
                    notifyIcon.Icon = _defaultTrayIcon;
                }
                else if (_appSettings.AlertOnForeignRules && _mainViewModel.UnseenSystemChangesCount > 0)
                {
                    notifyIcon.Icon = _alertTrayIcon;
                }
                else
                {
                    notifyIcon.Icon = _unlockedTrayIcon;
                }
            }
        }

        private void UpdateUiWithChangesCount()
        {
            if (this.InvokeRequired)
            {
                this.Invoke(new Action(UpdateUiWithChangesCount));
                return;
            }

            if (_appSettings.AlertOnForeignRules && _mainViewModel.UnseenSystemChangesCount > 0)
            {
                systemChangesTabPage.Text = "Audit";
                dm.SetNotificationCount(systemChangesTabPage, _mainViewModel.UnseenSystemChangesCount);
            }
            else
            {
                systemChangesTabPage.Text = "Audit";
                dm.SetNotificationCount(systemChangesTabPage, 0);
            }
            UpdateTrayStatus();
        }

        private void OnPopupRequired(PendingConnectionViewModel pending)
        {
            if (this.InvokeRequired)
            {
                this.Invoke(() => OnPopupRequired(pending));
                return;
            }

            bool alreadyInPopupQueue = _popupQueue.Any(p => p.AppPath.Equals(pending.AppPath, StringComparison.OrdinalIgnoreCase) && p.Direction.Equals(pending.Direction, StringComparison.OrdinalIgnoreCase));
            if (alreadyInPopupQueue)
            {
                _activityLogger.LogDebug($"Ignoring duplicate pending connection for {pending.AppPath} (in popup queue)");
                return;
            }

            if (_appSettings.IsPopupsEnabled)
            {
                lock (_popupLock)
                {
                    _popupQueue.Enqueue(pending);
                }
                BeginInvoke(new Action(ProcessNextPopup));
            }
        }

        private void ProcessNextPopup()
        {
            lock (_popupLock)
            {
                if (_isPopupVisible || _popupQueue.Count == 0)
                {
                    return;
                }

                _isPopupVisible = true;
                var pending = _popupQueue.Dequeue();

                var notifier = new NotifierForm(pending, _appSettings.Theme == "Dark");
                notifier.FormClosed += Notifier_FormClosed;
                notifier.TopMost = true;
                notifier.Show();
            }
        }

        private void Notifier_FormClosed(object? sender, FormClosedEventArgs e)
        {
            try
            {
                if (sender is not NotifierForm notifier) return;
                notifier.FormClosed -= Notifier_FormClosed;

                var pending = notifier.PendingConnection;
                var result = notifier.Result;
                _mainViewModel.PendingConnections.Remove(pending);
                if (result == NotifierForm.NotifierResult.CreateWildcard)
                {
                    this.BeginInvoke(new Action(() =>
                    {
                        using var wildcardDialog = new WildcardCreatorForm(_wildcardRuleService, pending.AppPath, _appSettings);
                        if (wildcardDialog.ShowDialog(this) == DialogResult.OK)
                        {
                            var newRule = wildcardDialog.NewRule;
                            _backgroundTaskService.EnqueueTask(new FirewallTask(FirewallTaskType.AddWildcardRule, newRule));

                            string decision = newRule.Action.StartsWith("Block", StringComparison.OrdinalIgnoreCase) ? "Block" : "Allow";
                            var allowPayload = new ProcessPendingConnectionPayload
                            {
                                PendingConnection = pending,
                                Decision = decision,
                                Duration = default,
                                TrustPublisher = false
                            };
                            _backgroundTaskService.EnqueueTask(new FirewallTask(FirewallTaskType.ProcessPendingConnection, allowPayload));
                        }

                        lock (_popupLock)
                        {
                            _isPopupVisible = false;
                        }
                        BeginInvoke(new Action(ProcessNextPopup));
                    }));
                }
                else
                {
                    var payload = new ProcessPendingConnectionPayload
                    {
                        PendingConnection = pending,
                        Decision = result.ToString(),
                        Duration = (result == NotifierForm.NotifierResult.TemporaryAllow) ?
                                   notifier.TemporaryDuration : default,
                        TrustPublisher = notifier.TrustPublisher
                    };
                    _backgroundTaskService.EnqueueTask(new FirewallTask(FirewallTaskType.ProcessPendingConnection, payload));

                    lock (_popupLock)
                    {
                        _isPopupVisible = false;
                    }
                    BeginInvoke(new Action(ProcessNextPopup));
                }
            }
            catch (Exception)
            {
            }
            finally
            {
                if (sender is IDisposable disposable)
                {
                    disposable.Dispose();
                }
            }
        }

        private void OnDashboardActionProcessed(PendingConnectionViewModel processedConnection)
        {
            if (this.InvokeRequired)
            {
                this.Invoke(() => OnDashboardActionProcessed(processedConnection));
                return;
            }

            NotifierForm? notifierToClose = null;
            lock (_popupLock)
            {
                var newQueue = new Queue<PendingConnectionViewModel>(
                    _popupQueue.Where(p =>
                        !(p.AppPath.Equals(processedConnection.AppPath, StringComparison.OrdinalIgnoreCase) &&
                           p.Direction.Equals(processedConnection.Direction, StringComparison.OrdinalIgnoreCase))
                    )
                );
                _popupQueue.Clear();
                foreach (var item in newQueue)
                {
                    _popupQueue.Enqueue(item);
                }

                if (_isPopupVisible)
                {
                    var activeNotifier = Application.OpenForms.OfType<NotifierForm>().FirstOrDefault();
                    if (activeNotifier != null)
                    {
                        var pendingInPopup = activeNotifier.PendingConnection;
                        if (pendingInPopup.AppPath.Equals(processedConnection.AppPath, StringComparison.OrdinalIgnoreCase) &&
                             pendingInPopup.Direction.Equals(processedConnection.Direction, StringComparison.OrdinalIgnoreCase))
                        {
                            notifierToClose = activeNotifier;
                        }
                    }
                }
            }

            if (notifierToClose != null)
            {
                notifierToClose.Result = NotifierForm.NotifierResult.Ignore;
                notifierToClose.Close();
            }
        }
        #endregion

        #region System Tray & Lifecycle
        private void SetupTrayIcon()
        {
            lockdownTrayMenuItem = new ToolStripMenuItem("Toggle Lockdown", null, ToggleLockdownTrayMenuItem_Click);
            var contextMenu = new ContextMenuStrip();
            contextMenu.Items.Add(lockdownTrayMenuItem);
            contextMenu.Items.Add(new ToolStripMenuItem("Show", null, ShowWindow));
            contextMenu.Items.Add(new ToolStripMenuItem("Exit", null, ExitApplication));
            contextMenu.Opening += TrayContextMenu_Opening;
            notifyIcon = new NotifyIcon(this.components)
            {
                Icon = this.Icon,
                Text = "Minimal Firewall",
                Visible = true,
                ContextMenuStrip = contextMenu
            };
            notifyIcon.DoubleClick += ShowWindow;
        }

        private void ToggleLockdownTrayMenuItem_Click(object? sender, EventArgs e)
        {
            _actionsService.ToggleLockdown();
            UpdateTrayStatus();
        }

        private void TrayContextMenu_Opening(object? sender, System.ComponentModel.CancelEventArgs e)
        {
            if (lockdownTrayMenuItem != null)
            {
                lockdownTrayMenuItem.Text = _mainViewModel.IsLockedDown ?
 "Disable Lockdown" : "Enable Lockdown";
            }
        }

        private void SetupAutoRefreshTimer()
        {
            _autoRefreshTimer?.Dispose();
            if (_appSettings.AutoRefreshIntervalMinutes > 0)
            {
                var interval = TimeSpan.FromMinutes(_appSettings.AutoRefreshIntervalMinutes);
                _autoRefreshTimer = new System.Threading.Timer(_ =>
                {
                    if (this.IsDisposed || !this.IsHandleCreated)
                    {
                        return;
                    }

                    try
                    {
                        this.Invoke(new Action(async () =>
                        {
                            if (this.Visible && (mainTabControl.SelectedTab?.Name is "rulesTabPage"))
                            {
                                await ForceDataRefreshAsync();
                            }
                        }));
                    }
                    catch (ObjectDisposedException)
                    {
                    }
                }, null, interval, interval);
                _activityLogger.LogDebug($"Auto-refresh timer set to {_appSettings.AutoRefreshIntervalMinutes} minutes.");
            }
        }

        private void ApplyLastWindowState()
        {
            if (_appSettings.WindowSize.Width > 0 && _appSettings.WindowSize.Height > 0)
            {
                this.Size = _appSettings.WindowSize;
            }

            bool isVisible = false;
            foreach (Screen screen in Screen.AllScreens)
            {
                if (screen.WorkingArea.Contains(_appSettings.WindowLocation))
                {
                    isVisible = true;
                    break;
                }
            }
            if (isVisible)
            {
                this.Location = _appSettings.WindowLocation;
            }
            else
            {
                this.StartPosition = FormStartPosition.CenterScreen;
            }

            FormWindowState savedState = (FormWindowState)_appSettings.WindowState;
            if (savedState == FormWindowState.Minimized)
            {
                savedState = FormWindowState.Normal;
            }

            this.WindowState = savedState;
        }

        private async void ShowWindow(object? sender, EventArgs e)
        {
            this.Opacity = 1;
            this.ShowInTaskbar = true;

            ApplyLastWindowState();
            this.Show();
            this.Activate();
            if (_mainViewModel.IsLockedDown)
            {
                _eventListenerService.Start();
            }
            if (_isSentryServiceStarted)
            {
                _firewallSentryService.Start();
            }

            SetupAutoRefreshTimer();
            await DisplayCurrentTabData();
            await RefreshRulesListAsync();
        }

        private void ExitApplication(object? sender, EventArgs e)
        {
            Application.Exit();
        }

        private void MainForm_FormClosing(object? sender, FormClosingEventArgs e)
        {
            if (this.WindowState == FormWindowState.Maximized)
            {
                _appSettings.WindowLocation = this.RestoreBounds.Location;
                _appSettings.WindowSize = this.RestoreBounds.Size;
                _appSettings.WindowState = (int)FormWindowState.Maximized;
            }
            else if (this.WindowState == FormWindowState.Normal)
            {
                _appSettings.WindowLocation = this.Location;
                _appSettings.WindowSize = this.Size;
                _appSettings.WindowState = (int)FormWindowState.Normal;
            }
            else
            {
                _appSettings.WindowLocation = this.RestoreBounds.Location;
                _appSettings.WindowSize = this.RestoreBounds.Size;
                _appSettings.WindowState = (int)FormWindowState.Normal;
            }

            settingsControl1.SaveSettingsFromUI();
            bool isExiting = !(_appSettings.CloseToTray && e.CloseReason == CloseReason.UserClosing);

            if (!isExiting)
            {
                e.Cancel = true;
                this.Hide();
                if (notifyIcon != null)
                {
                    notifyIcon.Visible = true;
                }
                PrepareForTrayAsync();
            }
            else
            {
                _scanCts?.Cancel();
                foreach (var timer in _tabUnloadTimers.Values)
                {
                    timer.Dispose();
                }
                _tabUnloadTimers.Clear();
                _mainViewModel.PopupRequired -= OnPopupRequired;
                _backgroundTaskService.QueueCountChanged -= OnQueueCountChanged;
                Application.Exit();
            }
        }

        private async void OnTrafficMonitorSettingChanged()
        {
            liveConnectionsControl1.UpdateEnabledState();
            if (_appSettings.IsTrafficMonitorEnabled && mainTabControl.SelectedTab == liveConnectionsTabPage)
            {
                await LoadLiveConnectionsAsync();
            }
        }

        public async Task PrepareForTrayAsync()
        {
            _scanCts?.Cancel();
            _firewallSentryService.Stop();
            _mainViewModel.TrafficMonitorViewModel.StopMonitoring();
            _autoRefreshTimer?.Dispose();

            _mainViewModel.ClearRulesData();
            _mainViewModel.PendingConnections.Clear();
            _mainViewModel.SystemChanges.Clear();
            auditControl1.ApplySearchFilter();
            groupsControl1.ClearGroups();
            wildcardRulesControl1.ClearRules();

            _dataService.ClearCaches();
            _iconService.ClearCache();
            await Task.Run(() =>
            {
                GC.Collect(GC.MaxGeneration, GCCollectionMode.Forced, true);
                GC.WaitForPendingFinalizers();
                if (Environment.OSVersion.Platform == PlatformID.Win32NT)
                {
                    SetProcessWorkingSetSize(Process.GetCurrentProcess().Handle, -1, -1);
                }
            });
        }
        #endregion

        #region Tab Loading and Filtering
        private async Task DisplayCurrentTabData()
        {
            if (mainTabControl is null) return;
            var selectedTab = mainTabControl.SelectedTab;
            if (selectedTab == null) return;

            this.SuspendLayout();
            if (selectedTab != liveConnectionsTabPage)
            {
                liveConnectionsControl1.OnTabDeselected();
            }

            try
            {
                switch (selectedTab.Name)
                {
                    case "dashboardTabPage":
                        break;
                    case "rulesTabPage":
                        await ForceDataRefreshAsync(true);
                        break;
                    case "wildcardRulesTabPage":
                        wildcardRulesControl1.LoadRules();
                        break;
                    case "systemChangesTabPage":
                        await ScanForSystemChangesAsync(true);
                        break;
                    case "groupsTabPage":
                        await groupsControl1.OnTabSelectedAsync();
                        break;
                    case "liveConnectionsTabPage":
                        await LoadLiveConnectionsAsync();
                        break;
                }
            }
            catch (OperationCanceledException) { }
            this.ResumeLayout(true);
        }

        public async Task ForceDataRefreshAsync(bool forceUwpScan = false, bool showStatus = true, StatusForm? statusFormInstance = null)
        {
            if (_isRefreshingData) return;
            _scanCts?.Cancel();
            _scanCts = new CancellationTokenSource();
            var token = _scanCts.Token;
            StatusForm? statusForm = null;
            try
            {
                _isRefreshingData = true;
                statusForm = statusFormInstance;
                if (showStatus && statusForm == null && this.Visible)
                {
                    statusForm = new StatusForm("Scanning firewall rules...", _appSettings);
                    statusForm.Show(this);
                }

                var progress = new Progress<int>(p => statusForm?.UpdateProgress(p));
                UpdateUIForRefresh(showStatus);
                _iconService.ClearCache();

                await rulesControl1.RefreshDataAsync(forceUwpScan, progress, token);

                if (token.IsCancellationRequested)
                {
                    _mainViewModel.ClearRulesData();
                    GC.Collect();
                    return;
                }
            }
            finally
            {
                if (statusForm != null && statusFormInstance == null && !statusForm.IsDisposed)
                {
                    statusForm.Close();
                }
                _isRefreshingData = false;
                UpdateUIAfterRefresh(showStatus);
            }
        }


        private async Task RefreshRulesListAsync()
        {
            try
            {
                await rulesControl1.RefreshDataAsync();
                if (this.Visible)
                {
                    await DisplayCurrentTabData();
                }
            }
            catch (OperationCanceledException) { }
        }

        private void UpdateUIForRefresh(bool showStatus)
        {
            if (this.InvokeRequired)
            {
                this.Invoke(() => UpdateUIForRefresh(showStatus));
                return;
            }

            rescanButton.Text = "Refreshing...";
            rescanButton.Enabled = false;
            lockdownButton.Enabled = false;
        }

        private void UpdateUIAfterRefresh(bool showStatus)
        {
            if (this.InvokeRequired)
            {
                this.Invoke(() => UpdateUIAfterRefresh(showStatus));
                return;
            }

            rescanButton.Text = "";
            rescanButton.Enabled = true;
            lockdownButton.Enabled = true;
        }

        private async Task ScanForSystemChangesAsync(bool showStatusWindow = false, IProgress<int>? progress = null, CancellationToken token = default)
        {
            if (token == default)
            {
                _scanCts?.Cancel();
                _scanCts = new CancellationTokenSource();
                token = _scanCts.Token;
            }

            try
            {
                if (showStatusWindow && this.Visible)
                {
                    _auditStatusForm = new StatusForm("Scanning for system changes...", _appSettings);
                    var progressIndicator = new Progress<int>(p => _auditStatusForm?.UpdateProgress(p));
                    _auditStatusForm.Show(this);
                    progress = progressIndicator;
                }
                await _mainViewModel.ScanForSystemChangesAsync(token, progress);
            }
            finally
            {
                if (token.IsCancellationRequested)
                {
                    _mainViewModel.SystemChanges.Clear();
                    auditControl1.ApplySearchFilter();
                    GC.Collect();
                }
                if (_auditStatusForm?.IsDisposed == false) _auditStatusForm?.Close();
                _auditStatusForm = null;
            }
        }

        private async Task LoadLiveConnectionsAsync(StatusForm? statusFormInstance = null)
        {
            if (!_appSettings.IsTrafficMonitorEnabled)
            {
                _mainViewModel.TrafficMonitorViewModel.StopMonitoring();
                liveConnectionsControl1.UpdateLiveConnectionsView();
                return;
            }

            if (_isRefreshingData) return;
            _scanCts?.Cancel();
            _scanCts = new CancellationTokenSource();
            var token = _scanCts.Token;
            StatusForm? statusForm = null;
            try
            {
                _isRefreshingData = true;
                statusForm = statusFormInstance;
                if (statusForm == null && this.Visible)
                {
                    statusForm = new StatusForm("Scanning live connections...", _appSettings);
                    statusForm.Show(this);
                }

                var progress = new Progress<int>(p => statusForm?.UpdateProgress(p));
                UpdateUIForRefresh(true);

                await _mainViewModel.RefreshLiveConnectionsAsync(token, progress);
                liveConnectionsControl1.UpdateLiveConnectionsView();
            }
            catch (OperationCanceledException)
            {

            }
            finally
            {
                if (statusForm != null && statusFormInstance == null && !statusForm.IsDisposed)
                {
                    statusForm.Close();
                }
                _isRefreshingData = false;
                UpdateUIAfterRefresh(true);
            }
        }
        #endregion

        #region UI Event Handlers
        private async void MainTabControl_SelectedIndexChanged(object? sender, EventArgs e)
        {
            var selectedTab = mainTabControl.SelectedTab;
            if (selectedTab == null) return;

            if (_tabUnloadTimers.TryGetValue(selectedTab.Name, out var timer))
            {
                timer.Dispose();
                _tabUnloadTimers.Remove(selectedTab.Name);
            }

            if (selectedTab != liveConnectionsTabPage)
            {
                liveConnectionsControl1.OnTabDeselected();
            }

            try
            {
                switch (selectedTab.Name)
                {
                    case "dashboardTabPage":
                        break;
                    case "rulesTabPage":
                        await ForceDataRefreshAsync(true);
                        break;
                    case "wildcardRulesTabPage":
                        wildcardRulesControl1.LoadRules();
                        break;
                    case "systemChangesTabPage":
                        if (!_isSentryServiceStarted)
                        {
                            _firewallSentryService.Start();
                            _isSentryServiceStarted = true;
                        }
                        await ScanForSystemChangesAsync(true);
                        break;
                    case "groupsTabPage":
                        await groupsControl1.OnTabSelectedAsync();
                        break;
                    case "liveConnectionsTabPage":
                        liveConnectionsControl1.UpdateEnabledState();
                        await LoadLiveConnectionsAsync();
                        break;
                }
            }
            catch (OperationCanceledException) { }
        }

        private void MainTabControl_Deselecting(object sender, TabControlCancelEventArgs e)
        {
            if (e.TabPage == null) return;
            _scanCts?.Cancel();

            var tabsToUnload = new[] { "rulesTabPage", "systemChangesTabPage", "groupsTabPage", "liveConnectionsTabPage", "wildcardRulesTabPage" };
            if (tabsToUnload.Contains(e.TabPage.Name))
            {
                if (_tabUnloadTimers.TryGetValue(e.TabPage.Name, out var existingTimer))
                {
                    existingTimer.Dispose();
                }

                var timer = new System.Threading.Timer(UnloadTabData, e.TabPage.Name, 30000, Timeout.Infinite);
                _tabUnloadTimers[e.TabPage.Name] = timer;
            }
        }

        private void UnloadTabData(object? state)
        {
            if (state is not string tabName) return;
            this.BeginInvoke(new Action(() =>
            {
                if (mainTabControl.SelectedTab != null && mainTabControl.SelectedTab.Name == tabName)
                {
                    return;
                }

                switch (tabName)
                {
                    case "rulesTabPage":
                        _mainViewModel.ClearRulesData();
                        break;
                    case "wildcardRulesTabPage":
                        wildcardRulesControl1.ClearRules();
                        break;
                    case "systemChangesTabPage":
                        if (_auditStatusForm?.IsDisposed == false) _auditStatusForm?.Close();
                        _auditStatusForm = null;
                        _mainViewModel.SystemChanges.Clear();
                        auditControl1.ApplySearchFilter();
                        UpdateUiWithChangesCount();
                        _firewallSentryService.Stop();
                        _isSentryServiceStarted = false;
                        break;
                    case "groupsTabPage":
                        groupsControl1.ClearGroups();
                        break;
                    case "liveConnectionsTabPage":
                        liveConnectionsControl1.OnTabDeselected();
                        break;
                }

                GC.Collect();
                if (_tabUnloadTimers.TryGetValue(tabName, out var timer))
                {
                    timer.Dispose();
                    _tabUnloadTimers.Remove(tabName);
                }
            }));
        }


        private async void RescanButton_Click(object? sender, EventArgs e)
        {
            if (mainTabControl.SelectedTab != null)
            {
                _activityLogger.LogDebug($"Rescan triggered for tab: {mainTabControl.SelectedTab.Text}");
            }

            try
            {
                if (mainTabControl.SelectedTab == systemChangesTabPage)
                {
                    await ScanForSystemChangesAsync(true);
                }
                else if (mainTabControl.SelectedTab == liveConnectionsTabPage)
                {
                    await LoadLiveConnectionsAsync();
                }
                else
                {
                    _mainViewModel.ClearRulesCache();
                    await ForceDataRefreshAsync(true);
                }
            }
            catch (OperationCanceledException) { }
        }

        private void ToggleLockdownButton_Click(object sender, EventArgs e)
        {
            bool wasLocked = _mainViewModel.IsLockedDown;
            _actionsService.ToggleLockdown();
            UpdateTrayStatus();

            bool isNowLocked = _mainViewModel.IsLockedDown;
            if (wasLocked && !isNowLocked)
            {
                DismissAllPopups();
            }
        }

        private void DismissAllPopups()
        {
            foreach (var form in Application.OpenForms.OfType<NotifierForm>().ToList())
            {
                form.Close();
            }

            lock (_popupLock)
            {
                _popupQueue.Clear();
                _isPopupVisible = false;
            }
        }

        private void ArrowPictureBox_Paint(object sender, PaintEventArgs e)
        {
            e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;
            Color arrowColor = (_appSettings.Theme == "Dark") ? Color.White : Color.Black;
            using (var arrowPen = new Pen(arrowColor, 2.5f))
            {
                arrowPen.EndCap = LineCap.ArrowAnchor;
                Point startPoint = new(arrowPictureBox.Width - 1, 0);
                Point endPoint = new(5, arrowPictureBox.Height - 5);
                Point controlPoint1 = new(arrowPictureBox.Width - 5, arrowPictureBox.Height / 2);
                Point controlPoint2 = new(arrowPictureBox.Width / 2, arrowPictureBox.Height);
                e.Graphics.DrawBezier(arrowPen, startPoint, controlPoint1, controlPoint2, endPoint);
            }
        }

        private void LockdownButton_MouseEnter(object? sender, EventArgs e)
        {
            lockdownButton.Invalidate();
        }

        private void LockdownButton_MouseLeave(object? sender, EventArgs e)
        {
            lockdownButton.Invalidate();
        }

        private void RescanButton_MouseEnter(object? sender, EventArgs e)
        {
            rescanButton.Invalidate();
        }

        private void RescanButton_MouseLeave(object? sender, EventArgs e)
        {
            rescanButton.Invalidate();
        }

        private static Image RecolorImage(Image sourceImage, Color newColor)
        {
            var newBitmap = new Bitmap(sourceImage.Width, sourceImage.Height);
            using (var g = Graphics.FromImage(newBitmap))
            {
                float r = newColor.R / 255f;
                float g_ = newColor.G / 255f;
                float b = newColor.B / 255f;
                var colorMatrix = new ColorMatrix(
                new float[][]
                {
                    new float[] {0, 0, 0, 0, 0},
                    new float[] {0, 0, 0, 0, 0},
                    new float[] {0, 0, 0, 0, 0},
                    new float[] {0, 0, 0, 1, 0},
                    new float[] {r, g_, b, 0, 1}
                });
                using (var attributes = new ImageAttributes())
                {
                    attributes.SetColorMatrix(colorMatrix, ColorMatrixFlag.Default, ColorAdjustType.Bitmap);
                    g.DrawImage(sourceImage, new Rectangle(0, 0, sourceImage.Width, sourceImage.Height),
                        0, 0, sourceImage.Width, sourceImage.Height, GraphicsUnit.Pixel, attributes);
                }
            }
            return newBitmap;
        }

        private void OwnerDrawnButton_Paint(object? sender, PaintEventArgs e)
        {
            if (sender is not Button button) return;
            e.Graphics.Clear(this.BackColor);
            e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;
            e.Graphics.InterpolationMode = InterpolationMode.HighQualityBicubic;

            Image? imageToDraw = null;
            if (button.Name == "lockdownButton")
            {
                imageToDraw = _mainViewModel.IsLockedDown ?
                              _lockedGreenIcon : ((_appSettings.Theme == "Dark") ? _unlockedWhiteIcon : appImageList.Images["unlocked.png"]);
            }
            else if (button.Name == "rescanButton")
            {
                if (_isRefreshingData)
                {
                    TextRenderer.DrawText(e.Graphics, "...", button.Font, button.ClientRectangle, button.ForeColor, TextFormatFlags.HorizontalCenter | TextFormatFlags.VerticalCenter);
                    return;
                }
                imageToDraw = (_appSettings.Theme == "Dark") ?
                              _refreshWhiteIcon : appImageList.Images["refresh.png"];
            }

            if (imageToDraw != null)
            {
                int imgX = (button.ClientSize.Width - imageToDraw.Width) / 2;
                int imgY = (button.ClientSize.Height - imageToDraw.Height) / 2;
                e.Graphics.DrawImage(imageToDraw, imgX, imgY, imageToDraw.Width, imageToDraw.Height);
            }

            if (button.ClientRectangle.Contains(button.PointToClient(Cursor.Position)))
            {
                using var p = new Pen(dm.OScolors.Accent, 2);
                e.Graphics.DrawRectangle(p, 0, 0, button.Width - 1, button.Height - 1);
            }
        }
        #endregion
    }
}

--------------------------------------------------
// Full Path: C:/Users/anon/PROGRAMMING/C#/SimpleFirewall/VS Minimal Firewall/MinimalFirewall-NET8/Backups/v2.5.5 - ws/2.5.5.6 - security vulnerability fix 3/MainForm.Designer.cs
--------------------------------------------------------------------------------
// File: MainForm.Designer.cs
namespace MinimalFirewall
{
    public partial class MainForm
    {
        private System.ComponentModel.IContainer components = null;
        private System.Windows.Forms.NotifyIcon notifyIcon;
        private DarkModeForms.FlatTabControl mainTabControl;
        private System.Windows.Forms.TabPage dashboardTabPage;
        private System.Windows.Forms.TabPage rulesTabPage;
        private System.Windows.Forms.TabPage systemChangesTabPage;
        private System.Windows.Forms.TabPage settingsTabPage;
        private System.Windows.Forms.TabPage groupsTabPage;
        private System.Windows.Forms.TabPage liveConnectionsTabPage;
        private System.Windows.Forms.Button lockdownButton;
        private System.Windows.Forms.Button rescanButton;
        private System.Windows.Forms.ToolTip mainToolTip;
        private System.Windows.Forms.ImageList appImageList;
        private System.Windows.Forms.PictureBox logoPictureBox;
        private System.Windows.Forms.PictureBox arrowPictureBox;
        private System.Windows.Forms.Label instructionLabel;
        private System.Windows.Forms.ImageList appIconList;
        private DashboardControl dashboardControl1;
        private RulesControl rulesControl1;
        private AuditControl auditControl1;
        private GroupsControl groupsControl1;
        private LiveConnectionsControl liveConnectionsControl1;
        private SettingsControl settingsControl1;
        private System.Windows.Forms.TabPage wildcardRulesTabPage;
        private WildcardRulesControl wildcardRulesControl1;

        protected override void Dispose(bool disposing)
        {

            if (disposing)
            {
                _autoRefreshTimer?.Dispose();
                _backgroundTaskService?.Dispose();
                _lockedGreenIcon?.Dispose();
                _unlockedWhiteIcon?.Dispose();
                _refreshWhiteIcon?.Dispose();
                _firewallSentryService?.Dispose();
                _eventListenerService?.Dispose();
                _defaultTrayIcon?.Dispose();
                _unlockedTrayIcon?.Dispose();
                _alertTrayIcon?.Dispose();
                dm?.Dispose();
                components?.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        private void InitializeComponent()
        {
            components = new System.ComponentModel.Container();
            System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(MainForm));
            mainTabControl = new DarkModeForms.FlatTabControl();
            dashboardTabPage = new TabPage();
            logoPictureBox = new PictureBox();
            arrowPictureBox = new PictureBox();
            instructionLabel = new Label();
            dashboardControl1 = new DashboardControl();
            rulesTabPage = new TabPage();
            rulesControl1 = new RulesControl();
            wildcardRulesTabPage = new TabPage();
            wildcardRulesControl1 = new WildcardRulesControl();
            systemChangesTabPage = new TabPage();
            auditControl1 = new AuditControl();
            groupsTabPage = new TabPage();
            groupsControl1 = new GroupsControl();
            liveConnectionsTabPage = new TabPage();
            liveConnectionsControl1 = new LiveConnectionsControl();
            settingsTabPage = new TabPage();
            settingsControl1 = new SettingsControl();
            appImageList = new ImageList(components);
            lockdownButton = new Button();
            rescanButton = new Button();
            mainToolTip = new ToolTip(components);
            appIconList = new ImageList(components);
            mainTabControl.SuspendLayout();
            dashboardTabPage.SuspendLayout();
            ((System.ComponentModel.ISupportInitialize)(logoPictureBox)).BeginInit();
            logoPictureBox.SuspendLayout();
            ((System.ComponentModel.ISupportInitialize)(arrowPictureBox)).BeginInit();
            rulesTabPage.SuspendLayout();
            wildcardRulesTabPage.SuspendLayout();
            systemChangesTabPage.SuspendLayout();
            groupsTabPage.SuspendLayout();
            liveConnectionsTabPage.SuspendLayout();
            settingsTabPage.SuspendLayout();
            SuspendLayout();
            // 
            // mainTabControl
            // 
            mainTabControl.Alignment = TabAlignment.Left;
            mainTabControl.BorderColor = SystemColors.ControlDark;
            mainTabControl.Controls.Add(dashboardTabPage);
            mainTabControl.Controls.Add(rulesTabPage);
            mainTabControl.Controls.Add(wildcardRulesTabPage);
            mainTabControl.Controls.Add(systemChangesTabPage);
            mainTabControl.Controls.Add(groupsTabPage);
            mainTabControl.Controls.Add(liveConnectionsTabPage);
            mainTabControl.Controls.Add(settingsTabPage);
            mainTabControl.Dock = DockStyle.Fill;
            mainTabControl.DrawMode = TabDrawMode.OwnerDrawFixed;
            mainTabControl.ImageList = appImageList;
            mainTabControl.ItemSize = new Size(70, 120);
            mainTabControl.LineColor = SystemColors.Highlight;
            mainTabControl.Location = new Point(0, 0);
            mainTabControl.Multiline = true;
            mainTabControl.Name = "mainTabControl";
            mainTabControl.SelectedForeColor = SystemColors.HighlightText;
            mainTabControl.SelectedIndex = 0;
            mainTabControl.SelectTabColor = SystemColors.ControlLight;
            mainTabControl.Size = new Size(1000, 700);
            mainTabControl.SizeMode = TabSizeMode.Fixed;
            mainTabControl.TabColor = SystemColors.ControlLight;
            mainTabControl.TabIndex = 0;
            mainTabControl.SelectedIndexChanged += MainTabControl_SelectedIndexChanged;
            mainTabControl.Deselecting += MainTabControl_Deselecting;
            // 
            // dashboardTabPage
            // 
            dashboardTabPage.Controls.Add(logoPictureBox);
            dashboardTabPage.Controls.Add(dashboardControl1);
            dashboardTabPage.ImageIndex = 3;
            dashboardTabPage.Location = new Point(124, 4);
            dashboardTabPage.Name = "dashboardTabPage";
            dashboardTabPage.Padding = new Padding(3, 3, 3, 3);
            dashboardTabPage.Size = new Size(872, 692);
            dashboardTabPage.TabIndex = 0;
            dashboardTabPage.Text = "Dashboard";
            dashboardTabPage.UseVisualStyleBackColor = true;
            // 
            // logoPictureBox
            // 
            logoPictureBox.Controls.Add(arrowPictureBox);
            logoPictureBox.Controls.Add(instructionLabel);
            logoPictureBox.Dock = DockStyle.Fill;
            logoPictureBox.Location = new Point(3, 3);
            logoPictureBox.Name = "logoPictureBox";
            logoPictureBox.Size = new Size(866, 686);
            logoPictureBox.SizeMode = PictureBoxSizeMode.CenterImage;
            logoPictureBox.TabIndex = 1;
            logoPictureBox.TabStop = false;
            // 
            // arrowPictureBox
            // 
            arrowPictureBox.Anchor = AnchorStyles.Bottom | AnchorStyles.Left;
            arrowPictureBox.BackColor = Color.Transparent;
            arrowPictureBox.Location = new Point(20, 620);
            arrowPictureBox.Name = "arrowPictureBox";
            arrowPictureBox.Size = new Size(60, 40);
            arrowPictureBox.TabIndex = 3;
            arrowPictureBox.TabStop = false;
            arrowPictureBox.Paint += ArrowPictureBox_Paint;
            // 
            // instructionLabel
            // 
            instructionLabel.Anchor = AnchorStyles.Bottom | AnchorStyles.Left;
            instructionLabel.AutoSize = true;
            instructionLabel.BackColor = Color.Transparent;
            instructionLabel.Font = new Font("Segoe UI", 9F);
            instructionLabel.Location = new Point(20, 590);
            instructionLabel.Name = "instructionLabel";
            instructionLabel.Size = new Size(241, 15);
            instructionLabel.TabIndex = 2;
            instructionLabel.Text = "Press the lock key to initiate firewall defense.";
            // 
            // dashboardControl1
            // 
            dashboardControl1.Dock = DockStyle.Fill;
            dashboardControl1.Location = new Point(3, 3);
            dashboardControl1.Margin = new Padding(3, 2, 3, 2);
            dashboardControl1.Name = "dashboardControl1";
            dashboardControl1.Size = new Size(866, 686);
            dashboardControl1.TabIndex = 2;
            // 
            // rulesTabPage
            // 
            rulesTabPage.Controls.Add(rulesControl1);
            rulesTabPage.ImageIndex = 8;
            rulesTabPage.Location = new Point(124, 4);
            rulesTabPage.Name = "rulesTabPage";
            rulesTabPage.Padding = new Padding(3, 3, 3, 3);
            rulesTabPage.Size = new Size(872, 692);
            rulesTabPage.TabIndex = 1;
            rulesTabPage.Text = "Rules";
            rulesTabPage.UseVisualStyleBackColor = true;
            // 
            // rulesControl1
            // 
            rulesControl1.Dock = DockStyle.Fill;
            rulesControl1.Location = new Point(3, 3);
            rulesControl1.Margin = new Padding(3, 2, 3, 2);
            rulesControl1.Name = "rulesControl1";
            rulesControl1.Size = new Size(866, 686);
            rulesControl1.TabIndex = 0;
            // 
            // wildcardRulesTabPage
            // 
            wildcardRulesTabPage.Controls.Add(wildcardRulesControl1);
            wildcardRulesTabPage.ImageIndex = 11;
            wildcardRulesTabPage.Location = new Point(124, 4);
            wildcardRulesTabPage.Margin = new Padding(3, 2, 3, 2);
            wildcardRulesTabPage.Name = "wildcardRulesTabPage";
            wildcardRulesTabPage.Padding = new Padding(3, 2, 3, 2);
            wildcardRulesTabPage.Size = new Size(872, 692);
            wildcardRulesTabPage.TabIndex = 7;
            wildcardRulesTabPage.Text = "Wildcard Rules";
            wildcardRulesTabPage.UseVisualStyleBackColor = true;
            // 
            // wildcardRulesControl1
            // 
            wildcardRulesControl1.Dock = DockStyle.Fill;
            wildcardRulesControl1.Location = new Point(3, 2);
            wildcardRulesControl1.Margin = new Padding(3, 2, 3, 2);
            wildcardRulesControl1.Name = "wildcardRulesControl1";
            wildcardRulesControl1.Size = new Size(866, 688);
            wildcardRulesControl1.TabIndex = 0;
            // 
            // systemChangesTabPage
            // 
            systemChangesTabPage.Controls.Add(auditControl1);
            systemChangesTabPage.ImageIndex = 1;
            systemChangesTabPage.Location = new Point(124, 4);
            systemChangesTabPage.Name = "systemChangesTabPage";
            systemChangesTabPage.Size = new Size(872, 692);
            systemChangesTabPage.TabIndex = 2;
            systemChangesTabPage.Text = "Audit";
            systemChangesTabPage.UseVisualStyleBackColor = true;
            // 
            // auditControl1
            // 
            auditControl1.Dock = DockStyle.Fill;
            auditControl1.Location = new Point(0, 0);
            auditControl1.Margin = new Padding(3, 2, 3, 2);
            auditControl1.Name = "auditControl1";
            auditControl1.Size = new Size(872, 692);
            auditControl1.TabIndex = 0;
            // 
            // groupsTabPage
            // 
            groupsTabPage.Controls.Add(groupsControl1);
            groupsTabPage.ImageIndex = 4;
            groupsTabPage.Location = new Point(124, 4);
            groupsTabPage.Name = "groupsTabPage";
            groupsTabPage.Padding = new Padding(3, 3, 3, 3);
            groupsTabPage.Size = new Size(872, 692);
            groupsTabPage.TabIndex = 5;
            groupsTabPage.Text = "Groups";
            groupsTabPage.UseVisualStyleBackColor = true;
            // 
            // groupsControl1
            // 
            groupsControl1.Dock = DockStyle.Fill;
            groupsControl1.Location = new Point(3, 3);
            groupsControl1.Margin = new Padding(3, 2, 3, 2);
            groupsControl1.Name = "groupsControl1";
            groupsControl1.Size = new Size(866, 686);
            groupsControl1.TabIndex = 0;
            // 
            // liveConnectionsTabPage
            // 
            liveConnectionsTabPage.Controls.Add(liveConnectionsControl1);
            liveConnectionsTabPage.ImageIndex = 0;
            liveConnectionsTabPage.Location = new Point(124, 4);
            liveConnectionsTabPage.Name = "liveConnectionsTabPage";
            liveConnectionsTabPage.Padding = new Padding(3, 3, 3, 3);
            liveConnectionsTabPage.Size = new Size(872, 692);
            liveConnectionsTabPage.TabIndex = 6;
            liveConnectionsTabPage.Text = "Live Connections";
            liveConnectionsTabPage.UseVisualStyleBackColor = true;
            // 
            // liveConnectionsControl1
            // 
            liveConnectionsControl1.Dock = DockStyle.Fill;
            liveConnectionsControl1.Location = new Point(3, 3);
            liveConnectionsControl1.Margin = new Padding(3, 2, 3, 2);
            liveConnectionsControl1.Name = "liveConnectionsControl1";
            liveConnectionsControl1.Size = new Size(866, 686);
            liveConnectionsControl1.TabIndex = 0;
            // 
            // settingsTabPage
            // 
            settingsTabPage.Controls.Add(settingsControl1);
            settingsTabPage.ImageIndex = 9;
            settingsTabPage.Location = new Point(124, 4);
            settingsTabPage.Name = "settingsTabPage";
            settingsTabPage.Size = new Size(872, 692);
            settingsTabPage.TabIndex = 4;
            settingsTabPage.Text = "Settings";
            settingsTabPage.UseVisualStyleBackColor = true;
            // 
            // settingsControl1
            // 
            settingsControl1.Dock = DockStyle.Fill;
            settingsControl1.Location = new Point(0, 0);
            settingsControl1.Margin = new Padding(3, 2, 3, 2);
            settingsControl1.Name = "settingsControl1";
            settingsControl1.Size = new Size(872, 692);
            settingsControl1.TabIndex = 0;
            // 
            // appImageList
            // 
            appImageList.ColorDepth = ColorDepth.Depth32Bit;
            appImageList.ImageStream = (ImageListStreamer)resources.GetObject("appImageList.ImageStream");
            appImageList.TransparentColor = Color.Transparent;
            appImageList.Images.SetKeyName(0, "antenna.png");
            appImageList.Images.SetKeyName(1, "audit.png");
            appImageList.Images.SetKeyName(2, "coffee.png");
            appImageList.Images.SetKeyName(3, "dashboard.png");
            appImageList.Images.SetKeyName(4, "groups.png");
            appImageList.Images.SetKeyName(5, "locked.png");
            appImageList.Images.SetKeyName(6, "logo.png");
            appImageList.Images.SetKeyName(7, "refresh.png");
            appImageList.Images.SetKeyName(8, "rules.png");
            appImageList.Images.SetKeyName(9, "settings.png");
            appImageList.Images.SetKeyName(10, "unlocked.png");
            appImageList.Images.SetKeyName(11, "wildcard.png");
            // 
            // lockdownButton
            // 
            lockdownButton.Anchor = AnchorStyles.Bottom | AnchorStyles.Left;
            lockdownButton.BackColor = Color.Transparent;
            lockdownButton.FlatAppearance.BorderColor = SystemColors.Control;
            lockdownButton.FlatAppearance.BorderSize = 2;
            lockdownButton.FlatStyle = FlatStyle.Flat;
            lockdownButton.Location = new Point(65, 652);
            lockdownButton.Name = "lockdownButton";
            lockdownButton.Size = new Size(40, 36);
            lockdownButton.TabIndex = 3;
            lockdownButton.UseVisualStyleBackColor = false;
            lockdownButton.Click += ToggleLockdownButton_Click;
            lockdownButton.MouseEnter += LockdownButton_MouseEnter;
            lockdownButton.MouseLeave += LockdownButton_MouseLeave;
            // 
            // rescanButton
            // 
            rescanButton.Anchor = AnchorStyles.Bottom | AnchorStyles.Left;
            rescanButton.BackColor = Color.Transparent;
            rescanButton.FlatAppearance.BorderColor = SystemColors.Control;
            rescanButton.FlatAppearance.BorderSize = 2;
            rescanButton.FlatStyle = FlatStyle.Flat;
            rescanButton.Location = new Point(15, 652);
            rescanButton.Name = "rescanButton";
            rescanButton.Size = new Size(40, 36);
            rescanButton.TabIndex = 1;
            rescanButton.UseVisualStyleBackColor = false;
            rescanButton.Click += RescanButton_Click;
            rescanButton.MouseEnter += RescanButton_MouseEnter;
            rescanButton.MouseLeave += RescanButton_MouseLeave;
            // 
            // appIconList
            // 
            appIconList.ColorDepth = ColorDepth.Depth32Bit;
            appIconList.ImageSize = new Size(32, 32);
            appIconList.TransparentColor = Color.Transparent;
            // 
            // MainForm
            // 
            AutoScaleDimensions = new SizeF(7F, 15F);
            AutoScaleMode = AutoScaleMode.Font;
            ClientSize = new Size(1000, 700);
            Controls.Add(rescanButton);
            Controls.Add(lockdownButton);
            Controls.Add(mainTabControl);
            Name = "MainForm";
            FormClosing += MainForm_FormClosing;
            mainTabControl.ResumeLayout(false);
            dashboardTabPage.ResumeLayout(false);
            ((System.ComponentModel.ISupportInitialize)(logoPictureBox)).EndInit();
            logoPictureBox.ResumeLayout(false);
            logoPictureBox.PerformLayout();
            ((System.ComponentModel.ISupportInitialize)(arrowPictureBox)).EndInit();
            rulesTabPage.ResumeLayout(false);
            wildcardRulesTabPage.ResumeLayout(false);
            systemChangesTabPage.ResumeLayout(false);
            groupsTabPage.ResumeLayout(false);
            liveConnectionsTabPage.ResumeLayout(false);
            settingsTabPage.ResumeLayout(false);
            ResumeLayout(false);

        }
        #endregion
    }
}

--------------------------------------------------
// Full Path: C:/Users/anon/PROGRAMMING/C#/SimpleFirewall/VS Minimal Firewall/MinimalFirewall-NET8/Backups/v2.5.5 - ws/2.5.5.6 - security vulnerability fix 3/MainViewModel.cs
--------------------------------------------------------------------------------
// File: MainViewModel.cs
using Firewall.Traffic.ViewModels;
using MinimalFirewall.TypedObjects;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using System.Windows.Forms;
using System;
using DarkModeForms;

namespace MinimalFirewall
{
    public class MainViewModel : ObservableViewModel
    {
        private readonly FirewallRuleService _firewallRuleService;
        private readonly WildcardRuleService _wildcardRuleService;
        private readonly BackgroundFirewallTaskService _backgroundTaskService;
        private readonly FirewallDataService _dataService;
        private readonly FirewallSentryService _firewallSentryService;
        private readonly ForeignRuleTracker _foreignRuleTracker;
        private readonly FirewallEventListenerService _eventListenerService;
        private readonly AppSettings _appSettings;
        private readonly UserActivityLogger _activityLogger;
        private readonly FirewallActionsService _actionsService;
        private System.Threading.Timer? _sentryRefreshDebounceTimer;

        public TrafficMonitorViewModel TrafficMonitorViewModel { get; }
        public ObservableCollection<PendingConnectionViewModel> PendingConnections { get; } = new();
        public List<AggregatedRuleViewModel> AllAggregatedRules { get; private set; } = [];
        public SortableBindingList<AggregatedRuleViewModel> VirtualRulesData { get; private set; } = new([]);
        public List<FirewallRuleChange> SystemChanges { get; private set; } = [];
        public int UnseenSystemChangesCount => SystemChanges.Count;
        public event Action? RulesListUpdated;
        public event Action? SystemChangesUpdated;
        public event Action<PendingConnectionViewModel>? PopupRequired;
        public event Action<PendingConnectionViewModel>? DashboardActionProcessed;
        public MainViewModel(
            FirewallRuleService firewallRuleService,
            WildcardRuleService wildcardRuleService,
            BackgroundFirewallTaskService backgroundTaskService,
            FirewallDataService dataService,
            FirewallSentryService firewallSentryService,
            ForeignRuleTracker foreignRuleTracker,
            TrafficMonitorViewModel trafficMonitorViewModel,
            FirewallEventListenerService eventListenerService,
            AppSettings appSettings,
            UserActivityLogger activityLogger,
            FirewallActionsService actionsService)
        {
            _firewallRuleService = firewallRuleService;
            _wildcardRuleService = wildcardRuleService;
            _backgroundTaskService = backgroundTaskService;
            _dataService = dataService;
            _firewallSentryService = firewallSentryService;
            _foreignRuleTracker = foreignRuleTracker;
            TrafficMonitorViewModel = trafficMonitorViewModel;
            _eventListenerService = eventListenerService;
            _appSettings = appSettings;
            _activityLogger = activityLogger;
            _actionsService = actionsService;

            _sentryRefreshDebounceTimer = new System.Threading.Timer(DebouncedSentryRefresh, null, Timeout.Infinite, Timeout.Infinite);

            _firewallSentryService.RuleSetChanged += OnRuleSetChanged;
            _eventListenerService.PendingConnectionDetected += OnPendingConnectionDetected;
        }

        public bool IsLockedDown => _firewallRuleService.GetDefaultOutboundAction() == NetFwTypeLib.NET_FW_ACTION_.NET_FW_ACTION_BLOCK;
        public void ClearRulesCache()
        {
            _dataService.InvalidateRuleCache();
        }

        public void ClearRulesData()
        {
            ClearRulesCache();
            AllAggregatedRules.Clear();
            VirtualRulesData.Clear();
            RulesListUpdated?.Invoke();
        }

        public async Task RefreshRulesDataAsync(CancellationToken token, IProgress<int>? progress = null)
        {
            AllAggregatedRules = await _dataService.GetAggregatedRulesAsync(token, progress);
        }

        public async Task RefreshLiveConnectionsAsync(CancellationToken token, IProgress<int>? progress = null)
        {
            var vms = await Task.Run(() =>
            {
                var connections = Firewall.Traffic.TcpTrafficTracker.GetConnections().Distinct().ToList();
                var processInfoCache = new Dictionary<uint, (string Name, string Path, string ServiceName)>();
                var viewModels = new List<TcpConnectionViewModel>();
                int total = connections.Count > 0 ? connections.Count : 1;
                int current = 0;

                foreach (var conn in connections)
                {
                    if (token.IsCancellationRequested)
                    {
                        break;
                    }

                    if (!processInfoCache.TryGetValue(conn.ProcessId, out var info))
                    {
                        try
                        {
                            using (var p = Process.GetProcessById((int)conn.ProcessId))
                            {
                                string name = p.ProcessName;
                                string path = string.Empty;
                                string serviceName = string.Empty;
                                try { if (p.MainModule != null) path = p.MainModule.FileName; }
                                catch (Win32Exception) { path = "N/A (Access Denied)"; }

                                if (name.Equals("svchost", StringComparison.OrdinalIgnoreCase))
                                {
                                    serviceName = SystemDiscoveryService.GetServicesByPID(conn.ProcessId.ToString());
                                }
                                info = (name, path, serviceName);
                            }
                        }
                        catch (ArgumentException) { info = ("(Exited)", string.Empty, string.Empty); }
                        catch { info = ("System", string.Empty, string.Empty); }
                        processInfoCache[conn.ProcessId] = info;
                    }
                    viewModels.Add(new TcpConnectionViewModel(conn, info, _backgroundTaskService));
                    current++;
                    progress?.Report((current * 100) / total);
                }
                return viewModels;
            }, token);

            if (token.IsCancellationRequested) return;

            TrafficMonitorViewModel.ActiveConnections.Clear();
            foreach (var vm in vms)
            {
                TrafficMonitorViewModel.ActiveConnections.Add(vm);
            }
        }

        public void ApplyRulesFilters(string searchText, HashSet<RuleType> enabledTypes, bool showSystemRules)
        {
            IEnumerable<AggregatedRuleViewModel> filteredRules = AllAggregatedRules;
            if (!showSystemRules)
            {
                filteredRules = filteredRules.Where(r => r.Grouping.EndsWith(" - MFW"));
            }

            if (enabledTypes.Count > 0 && enabledTypes.Count < 5)
            {
                filteredRules = filteredRules.Where(r => enabledTypes.Contains(r.Type));
            }

            if (!string.IsNullOrWhiteSpace(searchText))
            {
                filteredRules = filteredRules.Where(r =>
                    r.Name.Contains(searchText, StringComparison.OrdinalIgnoreCase) ||
                    r.Description.Contains(searchText, StringComparison.OrdinalIgnoreCase) ||
                    r.ApplicationName.Contains(searchText, StringComparison.OrdinalIgnoreCase));
            }

            VirtualRulesData = new SortableBindingList<AggregatedRuleViewModel>(filteredRules.ToList());
            RulesListUpdated?.Invoke();
        }

        private Func<AggregatedRuleViewModel, object> GetRuleKeySelector(int columnIndex)
        {
            return columnIndex switch
            {
                2 => rule => rule.InboundStatus,
                3 => rule => rule.OutboundStatus,
                4 => rule => rule.ProtocolName,
                5 => rule => rule.LocalPorts,
                6 => rule => rule.RemotePorts,
                7 => rule => rule.LocalAddresses,
                8 => rule => rule.RemoteAddresses,
                9 => rule => rule.ApplicationName,
                10 => rule => rule.ServiceName,
                11 => rule => rule.Profiles,
                12 => rule => rule.Grouping,
                13 => rule => rule.Description,
                _ => rule => rule.Name,
            };
        }

        public void AddPendingConnection(PendingConnectionViewModel pending)
        {
            var matchingRule = _wildcardRuleService.Match(pending.AppPath);
            if (matchingRule != null)
            {
                if (matchingRule.Action.StartsWith("Allow", StringComparison.OrdinalIgnoreCase))
                {
                    var payload = new ApplyApplicationRulePayload
                    {
                        AppPaths = [pending.AppPath],
                        Action = matchingRule.Action,
                        WildcardSourcePath = matchingRule.FolderPath
                    };
                    _backgroundTaskService.EnqueueTask(new FirewallTask(FirewallTaskType.ApplyApplicationRule, payload));
                    return;
                }
                if (matchingRule.Action.StartsWith("Block", StringComparison.OrdinalIgnoreCase))
                {
                    return;
                }
            }

            bool alreadyPending = PendingConnections.Any(p => p.AppPath.Equals(pending.AppPath, StringComparison.OrdinalIgnoreCase));
            if (!alreadyPending)
            {
                PendingConnections.Add(pending);
            }
        }

        public void ProcessDashboardAction(PendingConnectionViewModel pending, string decision, bool trustPublisher = false)
        {
            var payload = new ProcessPendingConnectionPayload { PendingConnection = pending, Decision = decision, TrustPublisher = trustPublisher };
            _backgroundTaskService.EnqueueTask(new FirewallTask(FirewallTaskType.ProcessPendingConnection, payload));
            PendingConnections.Remove(pending);

            if (decision == "Allow" || decision == "Block")
            {
                string action = $"{decision} ({pending.Direction})";
                FirewallActionsService.ParseActionString(action, out Actions parsedAction, out Directions parsedDirection);

                var newAggregatedRule = new AggregatedRuleViewModel
                {
                    Name = pending.FileName,
                    ApplicationName = pending.AppPath,
                    InboundStatus = parsedDirection == Directions.Incoming ? parsedAction.ToString() : "N/A",
                    OutboundStatus = parsedDirection == Directions.Outgoing ? parsedAction.ToString() : "N/A",
                    Type = RuleType.Program,
                    IsEnabled = true,
                    Grouping = MFWConstants.MainRuleGroup,
                    Profiles = "All",
                    ProtocolName = "Any"
                };
                AllAggregatedRules.Add(newAggregatedRule);
                ApplyRulesFilters(string.Empty, new HashSet<RuleType>(), false);
            }

            DashboardActionProcessed?.Invoke(pending);
        }

        public void ProcessTemporaryDashboardAction(PendingConnectionViewModel pending, string decision, TimeSpan duration)
        {
            var payload = new ProcessPendingConnectionPayload { PendingConnection = pending, Decision = decision, Duration = duration };
            _backgroundTaskService.EnqueueTask(new FirewallTask(FirewallTaskType.ProcessPendingConnection, payload));
            PendingConnections.Remove(pending);
            DashboardActionProcessed?.Invoke(pending);
        }

        public async Task ScanForSystemChangesAsync(CancellationToken token, IProgress<int>? progress = null)
        {
            var newChanges = await Task.Run(() => _firewallSentryService.CheckForChanges(_foreignRuleTracker, progress, token), token);
            if (token.IsCancellationRequested) return;

            SystemChanges.Clear();
            SystemChanges.AddRange(newChanges);
            SystemChangesUpdated?.Invoke();
        }

        public async Task RebuildBaselineAsync()
        {
            _foreignRuleTracker.Clear();
            await ScanForSystemChangesAsync(CancellationToken.None);
        }

        public void AcceptForeignRule(FirewallRuleChange change)
        {
            if (change.Rule?.Name is not null)
            {
                var payload = new ForeignRuleChangePayload { Change = change };
                _backgroundTaskService.EnqueueTask(new FirewallTask(FirewallTaskType.AcceptForeignRule, payload));
                SystemChanges.Remove(change);
                SystemChangesUpdated?.Invoke();
            }
        }

        public void DeleteForeignRule(FirewallRuleChange change)
        {
            if (change.Rule?.Name is not null)
            {
                var payload = new ForeignRuleChangePayload { Change = change };
                _backgroundTaskService.EnqueueTask(new FirewallTask(FirewallTaskType.DeleteForeignRule, payload));
                SystemChanges.Remove(change);
                SystemChangesUpdated?.Invoke();
            }
        }

        public void AcceptAllForeignRules()
        {
            if (SystemChanges.Count == 0) return;
            var payload = new AllForeignRuleChangesPayload { Changes = new List<FirewallRuleChange>(SystemChanges) };
            _backgroundTaskService.EnqueueTask(new FirewallTask(FirewallTaskType.AcceptAllForeignRules, payload));
            SystemChanges.Clear();
            SystemChangesUpdated?.Invoke();
        }

        public void ApplyRuleChange(AggregatedRuleViewModel item, string action)
        {
            var firstRule = item.UnderlyingRules.FirstOrDefault();
            if (firstRule == null) return;

            switch (firstRule.Type)
            {
                case RuleType.Program:
                    var appPayload = new ApplyApplicationRulePayload { AppPaths = [firstRule.ApplicationName], Action = action };
                    _backgroundTaskService.EnqueueTask(new FirewallTask(FirewallTaskType.ApplyApplicationRule, appPayload));
                    break;
                case RuleType.Service:
                    var servicePayload = new ApplyServiceRulePayload { ServiceName = firstRule.ServiceName, Action = action };
                    _backgroundTaskService.EnqueueTask(new FirewallTask(FirewallTaskType.ApplyServiceRule, servicePayload));
                    break;
                case RuleType.UWP:
                    if (firstRule.Description.Contains(MFWConstants.UwpDescriptionPrefix))
                    {
                        var pfn = firstRule.Description.Replace(MFWConstants.UwpDescriptionPrefix, "");
                        var uwpApp = new UwpApp { Name = item.Name, PackageFamilyName = pfn };
                        var uwpPayload = new ApplyUwpRulePayload { UwpApps = [uwpApp], Action = action };
                        _backgroundTaskService.EnqueueTask(new FirewallTask(FirewallTaskType.ApplyUwpRule, uwpPayload));
                    }
                    break;
            }

            FirewallActionsService.ParseActionString(action, out Actions parsedAction, out Directions parsedDirection);
            var ruleToUpdate = AllAggregatedRules.FirstOrDefault(r => r == item);
            if (ruleToUpdate != null)
            {
                if (parsedDirection.HasFlag(Directions.Incoming)) ruleToUpdate.InboundStatus = parsedAction.ToString();
                if (parsedDirection.HasFlag(Directions.Outgoing)) ruleToUpdate.OutboundStatus = parsedAction.ToString();
            }
            RulesListUpdated?.Invoke();
        }

        public void DeleteRules(List<AggregatedRuleViewModel> rulesToDelete)
        {
            var wildcardRulesToDelete = rulesToDelete
                .Where(i => i.Type == RuleType.Wildcard && i.WildcardDefinition != null)
                .Select(i => i.WildcardDefinition!)
                .ToList();
            var standardRuleNamesToDelete = rulesToDelete
                .Where(i => i.Type != RuleType.Wildcard)
                .SelectMany(i => i.UnderlyingRules.Select(r => r.Name))
                .ToList();
            foreach (var wildcardRule in wildcardRulesToDelete)
            {
                var payload = new DeleteWildcardRulePayload { Wildcard = wildcardRule };
                _backgroundTaskService.EnqueueTask(new FirewallTask(FirewallTaskType.DeleteWildcardRules, payload));
                _wildcardRuleService.RemoveRule(wildcardRule);
            }

            if (standardRuleNamesToDelete.Any())
            {
                var payload = new DeleteRulesPayload { RuleIdentifiers = standardRuleNamesToDelete };
                _backgroundTaskService.EnqueueTask(new FirewallTask(FirewallTaskType.DeleteAdvancedRules, payload));
            }

            AllAggregatedRules.RemoveAll(rulesToDelete.Contains);
        }

        public AggregatedRuleViewModel CreateAggregatedRuleFromAdvancedRule(AdvancedRuleViewModel advancedRule)
        {
            return new AggregatedRuleViewModel
            {
                Name = advancedRule.Name,
                ApplicationName = advancedRule.ApplicationName,
                ServiceName = advancedRule.ServiceName,
                Description = advancedRule.Description,
                Grouping = advancedRule.Grouping,
                IsEnabled = advancedRule.IsEnabled,
                InboundStatus = advancedRule.Direction.HasFlag(Directions.Incoming) ? advancedRule.Status : "N/A",
                OutboundStatus = advancedRule.Direction.HasFlag(Directions.Outgoing) ? advancedRule.Status : "N/A",
                ProtocolName = advancedRule.ProtocolName,
                LocalPorts = advancedRule.LocalPorts,
                RemotePorts = advancedRule.RemotePorts,
                LocalAddresses = advancedRule.LocalAddresses,
                RemoteAddresses = advancedRule.RemoteAddresses,
                Profiles = advancedRule.Profiles,
                Type = advancedRule.Type,
                UnderlyingRules = new List<AdvancedRuleViewModel> { advancedRule }
            };
        }


        public void CreateAdvancedRule(AdvancedRuleViewModel vm, string interfaceTypes, string icmpTypesAndCodes)
        {
            var payload = new CreateAdvancedRulePayload { ViewModel = vm, InterfaceTypes = interfaceTypes, IcmpTypesAndCodes = icmpTypesAndCodes };
            _backgroundTaskService.EnqueueTask(new FirewallTask(FirewallTaskType.CreateAdvancedRule, payload));

            var newAggregatedRule = new AggregatedRuleViewModel
            {
                Name = vm.Name,
                ApplicationName = vm.ApplicationName,
                ServiceName = vm.ServiceName,
                Description = vm.Description,
                Grouping = vm.Grouping,
                IsEnabled = vm.IsEnabled,
                InboundStatus = vm.Direction.HasFlag(Directions.Incoming) ? vm.Status : "N/A",
                OutboundStatus = vm.Direction.HasFlag(Directions.Outgoing) ? vm.Status : "N/A",
                ProtocolName = vm.ProtocolName,
                LocalPorts = vm.LocalPorts,
                RemotePorts = vm.RemotePorts,
                LocalAddresses = vm.LocalAddresses,
                RemoteAddresses = vm.RemoteAddresses,
                Profiles = vm.Profiles,
                Type = vm.Type,
                UnderlyingRules = [vm]
            };
            AllAggregatedRules.Add(newAggregatedRule);
            ApplyRulesFilters(string.Empty, new HashSet<RuleType>(), false);
        }

        public void CreateProgramRule(string appPath, string action)
        {
            FirewallActionsService.ParseActionString(action, out Actions parsedAction, out Directions parsedDirection);
            var newAggregatedRule = new AggregatedRuleViewModel
            {
                Name = Path.GetFileName(appPath),
                ApplicationName = appPath,
                InboundStatus = parsedDirection.HasFlag(Directions.Incoming) ? parsedAction.ToString() : "N/A",
                OutboundStatus = parsedDirection.HasFlag(Directions.Outgoing) ? parsedAction.ToString() : "N/A",
                Type = RuleType.Program,
                IsEnabled = true,
                Grouping = MFWConstants.MainRuleGroup,
                Profiles = "All",
                ProtocolName = "Any",
                LocalPorts = "Any",
                RemotePorts = "Any",
                LocalAddresses = "Any",
                RemoteAddresses = "Any",
                Description = "N/A",
                ServiceName = "N/A"
            };
            AllAggregatedRules.Add(newAggregatedRule);
            ApplyRulesFilters(string.Empty, new HashSet<RuleType>(), false);
            var payload = new ApplyApplicationRulePayload { AppPaths = { appPath }, Action = action };
            _backgroundTaskService.EnqueueTask(new FirewallTask(FirewallTaskType.ApplyApplicationRule, payload));
        }

        private void OnRuleSetChanged()
        {
            ClearRulesCache();
            if (!_appSettings.AlertOnForeignRules)
            {
                return;
            }

            _sentryRefreshDebounceTimer?.Change(1000, Timeout.Infinite);
        }

        private async void DebouncedSentryRefresh(object? state)
        {
            _activityLogger.LogDebug("Sentry: Debounce timer elapsed. Checking for foreign rules.");
            await ScanForSystemChangesAsync(CancellationToken.None);
        }

        private void OnPendingConnectionDetected(PendingConnectionViewModel pending)
        {
            bool alreadyPending = PendingConnections.Any(p => p.AppPath.Equals(pending.AppPath, StringComparison.OrdinalIgnoreCase) && p.Direction.Equals(pending.Direction, StringComparison.OrdinalIgnoreCase));
            if (alreadyPending)
            {
                _activityLogger.LogDebug($"Ignoring duplicate pending connection for {pending.AppPath} (already in dashboard list)");
                return;
            }

            AddPendingConnection(pending);
            if (_appSettings.IsPopupsEnabled)
            {
                PopupRequired?.Invoke(pending);
            }
        }

        public void ProcessSpecificAllow(PendingConnectionViewModel pending)
        {
            var vm = new AdvancedRuleViewModel
            {
                Name = $"Allow {pending.FileName} - {pending.RemoteAddress}:{pending.RemotePort}",
                Description = "Granular rule created by Minimal Firewall popup.",
                IsEnabled = true,
                Grouping = MFWConstants.MainRuleGroup,
                Status = "Allow",
                Direction = pending.Direction.Equals("Incoming", StringComparison.OrdinalIgnoreCase) ? Directions.Incoming : Directions.Outgoing,
                Protocol = int.TryParse(pending.Protocol, out int proto) ? proto : 256,
                ApplicationName = pending.AppPath,
                RemotePorts = pending.RemotePort,
                RemoteAddresses = pending.RemoteAddress,
                LocalPorts = "*",
                LocalAddresses = "*",
                Profiles = "All",
                Type = RuleType.Advanced
            };
            var advPayload = new CreateAdvancedRulePayload { ViewModel = vm, InterfaceTypes = "All", IcmpTypesAndCodes = "" };
            _backgroundTaskService.EnqueueTask(new FirewallTask(FirewallTaskType.CreateAdvancedRule, advPayload));
            var newAggregatedRule = new AggregatedRuleViewModel
            {
                Name = vm.Name,
                ApplicationName = vm.ApplicationName,
                Description = vm.Description,
                Grouping = vm.Grouping,
                IsEnabled = vm.IsEnabled,
                InboundStatus = vm.Direction.HasFlag(Directions.Incoming) ? vm.Status : "N/A",
                OutboundStatus = vm.Direction.HasFlag(Directions.Outgoing) ? vm.Status : "N/A",
                ProtocolName = vm.ProtocolName,
                LocalPorts = vm.LocalPorts,
                RemotePorts = vm.RemotePorts,
                LocalAddresses = vm.LocalAddresses,
                RemoteAddresses = vm.RemoteAddresses,
                Profiles = vm.Profiles,
                Type = vm.Type,
                UnderlyingRules = new List<AdvancedRuleViewModel> { vm }
            };
            AllAggregatedRules.Add(newAggregatedRule);
            ApplyRulesFilters(string.Empty, new HashSet<RuleType>(), false);

            DashboardActionProcessed?.Invoke(pending);
        }
        public async Task CleanUpOrphanedRulesAsync()
        {
            using var statusForm = new StatusForm("Scanning for orphaned rules...", _appSettings);
            statusForm.Show(Form.ActiveForm);
            var progress = new Progress<int>(p => statusForm.UpdateProgress(p));
            var cts = new CancellationTokenSource();
            statusForm.FormClosing += (s, e) =>
            {
                if (e.CloseReason == CloseReason.UserClosing)
                {
                    cts.Cancel();
                }
            };

            try
            {
                var deletedRules = await _actionsService.CleanUpOrphanedRulesAsync(cts.Token, progress);
                if (!cts.IsCancellationRequested)
                {
                    statusForm.Close();
                    Messenger.MessageBox(
                        $"{deletedRules.Count} orphaned rule(s) found and deleted.",
                        "Cleanup Complete",
                        MessageBoxButtons.OK,
                        MsgIcon.None);
                    ClearRulesCache();
                }
            }
            catch (OperationCanceledException)
            {
            }
            catch (Exception ex)
            {
                _activityLogger.LogException("CleanUpOrphanedRulesAsync", ex);
                if (!statusForm.IsDisposed)
                {
                    statusForm.Close();
                }
                Messenger.MessageBox(
                    "An error occurred during the cleanup process. Please check the debug log for details.",
                    "Cleanup Error",
                    MessageBoxButtons.OK,
                    MsgIcon.Error);
            }
        }
    }
}

--------------------------------------------------
// Full Path: C:/Users/anon/PROGRAMMING/C#/SimpleFirewall/VS Minimal Firewall/MinimalFirewall-NET8/Backups/v2.5.5 - ws/2.5.5.6 - security vulnerability fix 3/ManagePublishersForm.cs
--------------------------------------------------------------------------------
// File: ManagePublishersForm.cs
using DarkModeForms;

namespace MinimalFirewall
{
    public partial class ManagePublishersForm : Form
    {
        private readonly PublisherWhitelistService _whitelistService;
        private readonly DarkModeCS dm;

        public ManagePublishersForm(PublisherWhitelistService whitelistService, AppSettings appSettings)
        {
            InitializeComponent();
            dm = new DarkModeCS(this);
            dm.ColorMode = appSettings.Theme == "Dark" ? DarkModeCS.DisplayMode.DarkMode : DarkModeCS.DisplayMode.ClearMode;
            dm.ApplyTheme(appSettings.Theme == "Dark");
            _whitelistService = whitelistService;
            LoadPublishers();
        }

        private void LoadPublishers()
        {
            publishersListBox.Items.Clear();
            var publishers = _whitelistService.GetTrustedPublishers();
            foreach (var publisher in publishers)
            {
                publishersListBox.Items.Add(publisher);
            }
        }

        private void removeButton_Click(object sender, EventArgs e)
        {
            if (publishersListBox.SelectedItem is string selectedPublisher)
            {
                var result = MessageBox.Show($"Are you sure you want to remove '{selectedPublisher}' from the trusted list?", "Confirm Removal", MessageBoxButtons.YesNo, MessageBoxIcon.Warning);
                if (result == DialogResult.Yes)
                {
                    _whitelistService.Remove(selectedPublisher);
                    LoadPublishers();
                }
            }
        }

        private void closeButton_Click(object sender, EventArgs e)
        {
            this.Close();
        }
    }
}

--------------------------------------------------
// Full Path: C:/Users/anon/PROGRAMMING/C#/SimpleFirewall/VS Minimal Firewall/MinimalFirewall-NET8/Backups/v2.5.5 - ws/2.5.5.6 - security vulnerability fix 3/ManagePublishersForm.Designer.cs
--------------------------------------------------------------------------------
// File: ManagePublishersForm.Designer.cs
namespace MinimalFirewall
{
    partial class ManagePublishersForm
    {
        private System.ComponentModel.IContainer components = null;
        private System.Windows.Forms.ListBox publishersListBox;
        private System.Windows.Forms.Button removeButton;
        private System.Windows.Forms.Button closeButton;
        private System.Windows.Forms.Label infoLabel;
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        private void InitializeComponent()
        {
            this.publishersListBox = new System.Windows.Forms.ListBox();
            this.removeButton = new System.Windows.Forms.Button();
            this.closeButton = new System.Windows.Forms.Button();
            this.infoLabel = new System.Windows.Forms.Label();
            this.SuspendLayout();

            this.publishersListBox.FormattingEnabled = true;
            this.publishersListBox.ItemHeight = 15;
            this.publishersListBox.Location = new System.Drawing.Point(12, 35);
            this.publishersListBox.Name = "publishersListBox";
            this.publishersListBox.Size = new System.Drawing.Size(460, 199);
            this.publishersListBox.TabIndex = 0;

            this.removeButton.Location = new System.Drawing.Point(12, 240);
            this.removeButton.Name = "removeButton";
            this.removeButton.Size = new System.Drawing.Size(120, 29);
            this.removeButton.TabIndex = 1;
            this.removeButton.Text = "Remove Selected";
            this.removeButton.UseVisualStyleBackColor = true;
            this.removeButton.Click += new System.EventHandler(this.removeButton_Click);

            this.closeButton.Location = new System.Drawing.Point(397, 240);
            this.closeButton.Name = "closeButton";
            this.closeButton.Size = new System.Drawing.Size(75, 29);
            this.closeButton.TabIndex = 2;
            this.closeButton.Text = "Close";
            this.closeButton.UseVisualStyleBackColor = true;
            this.closeButton.Click += new System.EventHandler(this.closeButton_Click);

            this.infoLabel.AutoSize = true;
            this.infoLabel.Location = new System.Drawing.Point(12, 9);
            this.infoLabel.Name = "infoLabel";
            this.infoLabel.Size = new System.Drawing.Size(262, 15);
            this.infoLabel.TabIndex = 3;
            this.infoLabel.Text = "Applications from these publishers will be allowed automatically.";

            this.AutoScaleDimensions = new System.Drawing.SizeF(7F, 15F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.ClientSize = new System.Drawing.Size(484, 281);
            this.Controls.Add(this.infoLabel);
            this.Controls.Add(this.closeButton);
            this.Controls.Add(this.removeButton);
            this.Controls.Add(this.publishersListBox);
            this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedDialog;
            this.MaximizeBox = false;
            this.MinimizeBox = false;
            this.Name = "ManagePublishersForm";
            this.StartPosition = System.Windows.Forms.FormStartPosition.CenterParent;
            this.Text = "Manage Trusted Publishers";
            this.ResumeLayout(false);
            this.PerformLayout();
        }

        #endregion
    }
}

--------------------------------------------------
// Full Path: C:/Users/anon/PROGRAMMING/C#/SimpleFirewall/VS Minimal Firewall/MinimalFirewall-NET8/Backups/v2.5.5 - ws/2.5.5.6 - security vulnerability fix 3/Messenger.cs
--------------------------------------------------------------------------------
// File: Messenger.cs
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Drawing;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Windows.Forms;
using static DarkModeForms.KeyValue;
using Timer = System.Windows.Forms.Timer;

namespace DarkModeForms
{
    public static class Messenger
    {
        #region Events
        private static Action<object, ValidateEventArgs>?
        ValidateControlsHandler;

        public static event Action<object, ValidateEventArgs>? ValidateControls
        {
            add => ValidateControlsHandler += value;
            remove => ValidateControlsHandler -= value;
        }

        private static void ResetEvents()
        {
            ValidateControlsHandler = null;
        }

        #endregion Events

        #region MessageBox

        private static MessageBoxDefaultButton _defaultButton = MessageBoxDefaultButton.Button1;
        public static DialogResult MessageBox(string Message)
            => MessageBox(Message, string.Empty, MessageBoxButtons.OK, MessageBoxIcon.Exclamation);
        public static DialogResult MessageBox(Exception ex, bool ShowTrace = true) =>
            MessageBox(ex.Message + (ShowTrace ? "\r\n" + ex.StackTrace : ""), "Error!", icon: MessageBoxIcon.Error);
        public static DialogResult MessageBox(
            string Message, string title, MessageBoxButtons buttons = MessageBoxButtons.OK,
            MessageBoxIcon icon = MessageBoxIcon.Information, bool pIsDarkMode = true)
        {
            MsgIcon msgIcon = MsgIcon.None;
            switch (icon)
            {
                case MessageBoxIcon.Information:
                    msgIcon = MsgIcon.Info;
                    break;
                case MessageBoxIcon.Exclamation:
                    msgIcon = MsgIcon.Warning; break;
                case MessageBoxIcon.Question:
                    msgIcon = MsgIcon.Question; break;
                case MessageBoxIcon.Error:
                    msgIcon = MsgIcon.Error; break;
                case MessageBoxIcon.None:
                default:
                    break;
            }

            return MessageBox(Message, title, msgIcon, buttons, pIsDarkMode);
        }


        public static DialogResult MessageBox(string Message, string title, MessageBoxButtons buttons,
            MessageBoxIcon icon, MessageBoxDefaultButton DefaultButton, bool pIsDarkMode = true)
        {
            _defaultButton = DefaultButton;
            return MessageBox(Message, title, buttons, icon, pIsDarkMode);
        }

        public static DialogResult MessageBox(string Message, string title, MessageBoxButtons buttons = MessageBoxButtons.OK,
                                              MsgIcon icon = MsgIcon.None, bool pIsDarkMode = true)
        {
            return MessageBox(Message, title,
            icon, buttons, pIsDarkMode, owner: null);
        }

        public static DialogResult MessageBox(Form pOwner, string Message, string title,
            MessageBoxButtons buttons, MsgIcon icon = MsgIcon.None, bool pIsDarkMode = true)
        {
            return MessageBox(Message, title, icon, buttons, pIsDarkMode, owner: pOwner);
        }

        public static DialogResult MessageBox(
            string Message, string title, MsgIcon icon,
            MessageBoxButtons buttons = MessageBoxButtons.OK, bool pIsDarkMode = true,
            MessageBoxDefaultButton defaultButton = MessageBoxDefaultButton.Button1, Form? owner = null)
        {
            Form form = new Form
            {
                FormBorderStyle = FormBorderStyle.FixedDialog,
                StartPosition = FormStartPosition.CenterParent,
                MaximizeBox = false,
                MinimizeBox = false,
                Text = title,
                Width = 340,
                Height = 170,
                KeyPreview = true,
            };
            if (owner != null)
            {
                form.Owner = owner;
            }

            DarkModeCS DMode = new DarkModeCS(form)
            {
                ColorMode = pIsDarkMode ?
            DarkModeCS.DisplayMode.DarkMode : DarkModeCS.DisplayMode.ClearMode
            };
            DMode.ApplyTheme(pIsDarkMode);

            Base64Icons _Icons = new Base64Icons();

            Font systemFont = SystemFonts.DefaultFont;
            int fontHeight = systemFont.Height;
            #region Bottom Panel & Buttons

            Panel bottomPanel = new Panel
            {
                Dock = DockStyle.Bottom,
                Height = 48,
                BackColor = DMode.OScolors.Surface,
                ForeColor = DMode.OScolors.TextActive
            };
            form.Controls.Add(bottomPanel);
            string CurrentLanguage = GetCurrentLanguage();
            var ButtonTranslations = GetButtonTranslations(CurrentLanguage);


            List<Button> CmdButtons = new List<Button>();
            switch (buttons)
            {
                case MessageBoxButtons.OK:
                    CmdButtons.Add(new Button
                    {
                        Anchor = AnchorStyles.Top | AnchorStyles.Right,
                        DialogResult = DialogResult.OK,
                        Text = ButtonTranslations["OK"],
                        Height = fontHeight + 10,
                        FlatStyle = FlatStyle.System
                    });
                    form.AcceptButton = CmdButtons[0];
                    form.KeyPreview = true;
                    form.KeyDown += (s, e) =>
                    { if (e.KeyCode == Keys.Escape) { form.Close(); } };
                    form.FormClosed += (s, e) =>
                    {
                        form.DialogResult = DialogResult.OK;
                    };
                    break;

                case MessageBoxButtons.OKCancel:
                    CmdButtons.Add(new Button
                    {
                        Anchor = AnchorStyles.Top | AnchorStyles.Right,
                        DialogResult = DialogResult.OK,
                        Text = ButtonTranslations["OK"],
                        Height = fontHeight + 10,
                        FlatStyle = FlatStyle.System
                    });
                    CmdButtons.Add(new Button
                    {
                        Anchor = AnchorStyles.Top | AnchorStyles.Right,
                        DialogResult = DialogResult.Cancel,
                        Text
                        = ButtonTranslations["Cancel"],
                        FlatStyle = FlatStyle.System
                    });
                    form.AcceptButton = CmdButtons[0];
                    form.CancelButton = CmdButtons[1];
                    break;

                case MessageBoxButtons.AbortRetryIgnore:
                    CmdButtons.Add(new Button
                    {
                        Anchor = AnchorStyles.Top | AnchorStyles.Right,
                        DialogResult = DialogResult.Abort,
                        Text = ButtonTranslations["Abort"]
                    });
                    CmdButtons.Add(new Button
                    {
                        Anchor = AnchorStyles.Top | AnchorStyles.Right,
                        DialogResult = DialogResult.Retry,
                        Text
                        = ButtonTranslations["Retry"]
                    });
                    CmdButtons.Add(new Button
                    {
                        Anchor = AnchorStyles.Top | AnchorStyles.Right,
                        DialogResult = DialogResult.Ignore,
                        Text
                        = ButtonTranslations["Ignore"]
                    });
                    form.AcceptButton = CmdButtons[0];
                    form.ControlBox = false;
                    break;

                case MessageBoxButtons.YesNoCancel:
                    CmdButtons.Add(new Button
                    {
                        Anchor = AnchorStyles.Top | AnchorStyles.Right,
                        DialogResult = DialogResult.Yes,
                        Text = ButtonTranslations["Yes"]
                    });
                    CmdButtons.Add(new Button
                    {
                        Anchor = AnchorStyles.Top | AnchorStyles.Right,
                        DialogResult = DialogResult.No,
                        Text
                        = ButtonTranslations["No"]
                    });
                    CmdButtons.Add(new Button
                    {
                        Anchor = AnchorStyles.Top | AnchorStyles.Right,
                        DialogResult = DialogResult.Cancel,
                        Text
                        = ButtonTranslations["Cancel"]
                    });
                    form.AcceptButton = CmdButtons[0];
                    form.CancelButton = CmdButtons[2];
                    break;

                case MessageBoxButtons.YesNo:
                    CmdButtons.Add(new Button
                    {
                        Anchor = AnchorStyles.Top | AnchorStyles.Right,
                        DialogResult = DialogResult.Yes,
                        Text = ButtonTranslations["Yes"]
                    });
                    CmdButtons.Add(new Button
                    {
                        Anchor = AnchorStyles.Top | AnchorStyles.Right,
                        DialogResult = DialogResult.No,
                        Text
                        = ButtonTranslations["No"]
                    });
                    form.AcceptButton = CmdButtons[0];
                    form.ControlBox = false;
                    break;

                case MessageBoxButtons.RetryCancel:
                    CmdButtons.Add(new Button
                    {
                        Anchor = AnchorStyles.Top | AnchorStyles.Right,
                        DialogResult = DialogResult.Retry,
                        Text = ButtonTranslations["Retry"],
                        FlatStyle = FlatStyle.System
                    });
                    CmdButtons.Add(new Button
                    {
                        Anchor = AnchorStyles.Top | AnchorStyles.Right,
                        DialogResult = DialogResult.Cancel,
                        Text
                        = ButtonTranslations["Cancel"]
                    });
                    form.AcceptButton = CmdButtons[0];
                    form.CancelButton = CmdButtons[1];
                    break;
            }

            int Padding = 4;
            int LastPos = form.ClientSize.Width;

            systemFont = SystemFonts.MessageBoxFont ?? SystemFonts.DefaultFont;

            using (Graphics g = form.CreateGraphics())
            {
                for (int c = CmdButtons.Count - 1; c >= 0; c--)
                {
                    Button _button = CmdButtons[c];
                    _button.FlatAppearance.BorderColor = (form.AcceptButton == _button) ? DMode.OScolors.Accent : DMode.OScolors.Control;

                    bottomPanel.Controls.Add(_button);
                    _button.TabIndex = c;
                    _button.Font = systemFont;
                    SizeF textSize = g.MeasureString(_button.Text, systemFont);
                    _button.Size = new Size((int)textSize.Width + 20, systemFont.Height + 10);
                    _button.Location = new Point(LastPos - (_button.Width + Padding), (bottomPanel.Height - _button.Height) / 2);
                    LastPos = _button.Left;
                }
            }

            int b = (int)_defaultButton;
            if (b > 0)
            {
                b >>= 8;
                if (b < CmdButtons.Count)
                {
                    CmdButtons[b].Select();
                    CmdButtons[b].FlatStyle = FlatStyle.Flat;
                    CmdButtons[b].FlatAppearance.BorderColor = DMode.OScolors.AccentLight;
                }
            }

            #endregion Bottom Panel & Buttons

            #region Icon

            Rectangle picBox = new Rectangle(2, 10, 0, 0);
            if (icon != MsgIcon.None)
            {
                PictureBox picIcon = new PictureBox { SizeMode = PictureBoxSizeMode.Zoom, Size = new Size(64, 64) };
                picIcon.Image = _Icons.GetIcon(icon);
                form.Controls.Add(picIcon);

                picBox.Size = new Size(64, 64);
                picIcon.SetBounds(picBox.X, picBox.Y, picBox.Width, picBox.Height);
                picIcon.BringToFront();
            }

            #endregion Icon

            #region Prompt Text

            Label lblPrompt = new Label
            {
                Text = Message,
                AutoSize = true,
                ForeColor = DMode.OScolors.TextActive,
                TextAlign = ContentAlignment.MiddleLeft,
                Location = new Point(picBox.X + picBox.Width + 4, picBox.Y),
                MaximumSize = new Size(form.ClientSize.Width - (picBox.X + picBox.Width) + 8, 0),
                MinimumSize = new Size(form.ClientSize.Width - (picBox.X +
                picBox.Width) + 8, 64)
            };
            lblPrompt.BringToFront();
            form.Controls.Add(lblPrompt);
            #endregion Prompt Text

            form.ClientSize = new Size(340,
                bottomPanel.Height +
                lblPrompt.Height +
                20
            );
            #region Keyboard Shortcuts

            string localMessage = Message;
            string localTitle = title;

            form.KeyDown += (object? sender, KeyEventArgs e) =>
            {
                if (e.Control && e.KeyCode == Keys.C)
                {
                    string clipboardText = $"Title: {localTitle}\r\nMessage: {localMessage}";
                    Clipboard.SetText(clipboardText);
                    e.Handled = true;
                }
            };
            #endregion


            return form.ShowDialog();
        }

        #endregion MessageBox

        #region InputBox

        public static DialogResult InputBox(
            string title, string promptText, ref List<KeyValue> Fields,
            MsgIcon icon = MsgIcon.None, MessageBoxButtons buttons = MessageBoxButtons.OK, bool pIsDarkMode = true)
        {
            Form form = new Form
            {
                FormBorderStyle = FormBorderStyle.FixedDialog,
                StartPosition = FormStartPosition.CenterParent,
                MaximizeBox = false,
                MinimizeBox = false,
                Text = title,
                Width = 340,
                Height = 170
            };
            DarkModeCS DMode = new DarkModeCS(form) { ColorMode = pIsDarkMode ? DarkModeCS.DisplayMode.DarkMode : DarkModeCS.DisplayMode.ClearMode };
            DMode.ApplyTheme(pIsDarkMode);
            ErrorProvider Err = new ErrorProvider();
            Base64Icons _Icons = new Base64Icons();

            #region Bottom Panel

            Panel bottomPanel = new Panel
            {
                Dock = DockStyle.Bottom,
                Height = 48,
                BackColor = DMode.OScolors.Surface,
                ForeColor = DMode.OScolors.TextActive
            };
            form.Controls.Add(bottomPanel);

            #endregion Bottom Panel

            #region Icon

            if (icon != MsgIcon.None)
            {
                PictureBox picIcon = new PictureBox { SizeMode = PictureBoxSizeMode.Zoom, Size = new Size(48, 48) };
                picIcon.Image = _Icons.GetIcon(icon);
                bottomPanel.Controls.Add(picIcon);

                picIcon.SetBounds(0, 2, 48, 48);
                picIcon.BringToFront();
            }

            #endregion Icon

            #region Buttons

            string CurrentLanguage = GetCurrentLanguage();
            var ButtonTranslations = GetButtonTranslations(CurrentLanguage);

            List<Button> CmdButtons = new List<Button>();
            switch (buttons)
            {
                case MessageBoxButtons.OK:
                    CmdButtons.Add(new Button
                    {
                        Anchor = AnchorStyles.Top | AnchorStyles.Right,
                        DialogResult = DialogResult.OK,
                        Text = ButtonTranslations["OK"]
                    });
                    form.AcceptButton = CmdButtons[0];
                    break;

                case MessageBoxButtons.OKCancel:
                    CmdButtons.Add(new Button
                    {
                        Anchor = AnchorStyles.Top | AnchorStyles.Right,
                        DialogResult =
                        DialogResult.OK,
                        Text = ButtonTranslations["OK"]
                    });
                    CmdButtons.Add(new Button
                    {
                        Anchor = AnchorStyles.Top | AnchorStyles.Right,
                        DialogResult = DialogResult.Cancel,
                        Text
                        = ButtonTranslations["Cancel"]
                    });
                    form.AcceptButton = CmdButtons[0];
                    form.CancelButton = CmdButtons[1];
                    break;

                case MessageBoxButtons.AbortRetryIgnore:
                    CmdButtons.Add(new Button
                    {
                        Anchor = AnchorStyles.Top | AnchorStyles.Right,
                        DialogResult = DialogResult.Retry,
                        Text = ButtonTranslations["Retry"]
                    });
                    CmdButtons.Add(new Button
                    {
                        Anchor = AnchorStyles.Top | AnchorStyles.Right,
                        DialogResult = DialogResult.Abort,
                        Text
                        = ButtonTranslations["Abort"]
                    });
                    form.AcceptButton = CmdButtons[0];
                    form.CancelButton = CmdButtons[1];
                    break;

                case MessageBoxButtons.YesNoCancel:
                    CmdButtons.Add(new Button
                    {
                        Anchor = AnchorStyles.Top | AnchorStyles.Right,
                        DialogResult = DialogResult.Yes,
                        Text = ButtonTranslations["Yes"]
                    });
                    CmdButtons.Add(new Button
                    {
                        Anchor = AnchorStyles.Top | AnchorStyles.Right,
                        DialogResult = DialogResult.No,
                        Text
                        = ButtonTranslations["No"]
                    });
                    CmdButtons.Add(new Button
                    {
                        Anchor = AnchorStyles.Top | AnchorStyles.Right,
                        DialogResult = DialogResult.Cancel,
                        Text
                        = ButtonTranslations["Cancel"]
                    });
                    form.AcceptButton = CmdButtons[0];
                    form.CancelButton = CmdButtons[2];
                    break;

                case MessageBoxButtons.YesNo:
                    CmdButtons.Add(new Button
                    {
                        Anchor = AnchorStyles.Top | AnchorStyles.Right,
                        DialogResult = DialogResult.Yes,
                        Text = ButtonTranslations["Yes"]
                    });
                    CmdButtons.Add(new Button
                    {
                        Anchor = AnchorStyles.Top | AnchorStyles.Right,
                        DialogResult = DialogResult.No,
                        Text
                        = ButtonTranslations["No"]
                    });
                    form.AcceptButton = CmdButtons[0];
                    form.CancelButton = CmdButtons[1];
                    break;

                case MessageBoxButtons.RetryCancel:
                    CmdButtons.Add(new Button
                    {
                        Anchor = AnchorStyles.Top | AnchorStyles.Right,
                        DialogResult = DialogResult.Retry,
                        Text = ButtonTranslations["Retry"]
                    });
                    CmdButtons.Add(new Button
                    {
                        Anchor = AnchorStyles.Top | AnchorStyles.Right,
                        DialogResult = DialogResult.Cancel,
                        Text
                        = ButtonTranslations["Cancel"]
                    });
                    form.AcceptButton = CmdButtons[0];
                    form.CancelButton = CmdButtons[1];
                    break;
            }

            int Padding = 4;
            int LastPos = form.ClientSize.Width;

            foreach (var _button in CmdButtons)
            {
                _button.FlatAppearance.BorderColor = (form.AcceptButton == _button) ?
                DMode.OScolors.Accent : DMode.OScolors.Control;
                bottomPanel.Controls.Add(_button);

                _button.Location = new Point(LastPos - (_button.Width + Padding), (bottomPanel.Height - _button.Height) / 2);
                LastPos = _button.Left;
            }

            #endregion Buttons

            #region Prompt Text

            Label lblPrompt = new Label();
            if (!string.IsNullOrWhiteSpace(promptText))
            {
                lblPrompt.Dock = DockStyle.Top;
                lblPrompt.Text = promptText;
                lblPrompt.AutoSize = false;
                lblPrompt.Height = 24;
                lblPrompt.TextAlign = ContentAlignment.MiddleCenter;
            }
            else
            {
                lblPrompt.Location = new Point(0, 0);
                lblPrompt.Width = 0;
                lblPrompt.Height = 0;
            }
            form.Controls.Add(lblPrompt);
            #endregion Prompt Text

            #region Controls for KeyValues

            TableLayoutPanel Contenedor = new TableLayoutPanel
            {
                Size = new Size(form.ClientSize.Width - 20, 50),
                AutoSizeMode = AutoSizeMode.GrowAndShrink,
                BackColor = DMode.OScolors.Background,
                AutoSize = true,
                ColumnCount = 2,
                Location = new Point(10, lblPrompt.Location.Y + lblPrompt.Height + 4)
            };
            form.Controls.Add(Contenedor);
            Contenedor.ColumnStyles.Clear();
            Contenedor.ColumnStyles.Add(new ColumnStyle(SizeType.AutoSize));
            Contenedor.ColumnStyles.Add(new ColumnStyle(SizeType.Absolute));
            Contenedor.ColumnStyles[1].Width = form.ClientSize.Width - 120;
            Contenedor.RowStyles.Clear();

            int ChangeDelayMS = 1000;
            int currentRow = 0;
            foreach (KeyValue field in Fields)
            {
                Label field_label = new Label
                {
                    Text = field.Key,
                    AutoSize = false,
                    Dock = DockStyle.Fill,
                    TextAlign = ContentAlignment.MiddleCenter
                };
                Control? field_Control = null;

                BorderStyle BStyle = (DMode.IsDarkMode ? BorderStyle.FixedSingle : BorderStyle.Fixed3D);
                if (field.ValueType == ValueTypes.String)
                {
                    field_Control = new TextBox
                    {
                        Text = field.Value,
                        Dock = DockStyle.Fill,
                        TextAlign = HorizontalAlignment.Center
                    };
                    ((TextBox)field_Control).TextChanged += (sender, args) =>
                    {
                        AddTextChangedDelay((TextBox)field_Control, ChangeDelayMS, text =>
                        {
                            field.Value = ((TextBox)sender!).Text;
                            ((TextBox)sender!).Text = Convert.ToString(field.Value);
                            Err.SetError(field_Control, field.ErrorText);
                        });
                    };
                }
                if (field.ValueType == ValueTypes.Multiline)
                {
                    field_Control = new TextBox
                    {
                        Text = field.Value,
                        Dock = DockStyle.Fill,
                        TextAlign = HorizontalAlignment.Left,
                        Multiline = true,
                        ScrollBars = ScrollBars.Vertical
                    };
                    ((TextBox)field_Control).TextChanged += (sender, args) =>
                    {
                        AddTextChangedDelay((TextBox)field_Control, ChangeDelayMS, text =>
                        {
                            field.Value = ((TextBox)sender!).Text;
                            ((TextBox)sender!).Text = Convert.ToString(field.Value);
                            Err.SetError(field_Control, field.ErrorText);
                        });
                    };
                }
                if (field.ValueType == ValueTypes.Password)
                {
                    field_Control = new TextBox
                    {
                        Text = field.Value,
                        Dock = DockStyle.Fill,
                        UseSystemPasswordChar = true,
                        TextAlign = HorizontalAlignment.Center
                    };
                    ((TextBox)field_Control).TextChanged += (sender, args) =>
                    {
                        AddTextChangedDelay((TextBox)field_Control, ChangeDelayMS, text =>
                        {
                            field.Value = ((TextBox)sender!).Text;
                            ((TextBox)sender!).Text = Convert.ToString(field.Value);
                            Err.SetError(field_Control, field.ErrorText);
                        });
                    };
                }
                if (field.ValueType == ValueTypes.Integer)
                {
                    field_Control = new NumericUpDown
                    {
                        Minimum = int.MinValue,
                        Maximum = int.MaxValue,
                        TextAlign = HorizontalAlignment.Center,
                        Value = Convert.ToInt32(field.Value, CultureInfo.InvariantCulture),
                        ThousandsSeparator = true,
                        Dock = DockStyle.Fill,
                        DecimalPlaces = 0
                    };
                    ((NumericUpDown)field_Control).ValueChanged += (sender, args) =>
                    {
                        AddTextChangedDelay((NumericUpDown)field_Control, ChangeDelayMS, text =>
                        {
                            field.Value = ((NumericUpDown)sender!).Value.ToString(CultureInfo.InvariantCulture);
                            ((NumericUpDown)sender!).Value = Convert.ToInt32(field.Value, CultureInfo.InvariantCulture);
                            Err.SetError(field_Control, field.ErrorText);
                        });
                    };
                }
                if (field.ValueType == ValueTypes.Decimal)
                {
                    field_Control = new NumericUpDown
                    {
                        Minimum = int.MinValue,
                        Maximum = int.MaxValue,
                        TextAlign = HorizontalAlignment.Center,
                        Value = Convert.ToDecimal(field.Value, CultureInfo.InvariantCulture),
                        ThousandsSeparator = false,
                        Dock = DockStyle.Fill,
                        DecimalPlaces = 2
                    };
                    ((NumericUpDown)field_Control).ValueChanged += (sender, args) =>
                    {
                        AddTextChangedDelay((NumericUpDown)field_Control, ChangeDelayMS, text =>
                        {
                            field.Value = ((NumericUpDown)sender!).Value.ToString(CultureInfo.InvariantCulture);
                            ((NumericUpDown)sender!).Value = Convert.ToDecimal(field.Value, CultureInfo.InvariantCulture);
                            Err.SetError(field_Control, field.ErrorText);
                        });
                    };
                }
                if (field.ValueType == ValueTypes.Date)
                {
                    field_Control = new DateTimePicker
                    {
                        Value = Convert.ToDateTime(field.Value, CultureInfo.InvariantCulture),
                        Dock = DockStyle.Fill,
                        Format = DateTimePickerFormat.Short,

                        CalendarForeColor = DMode.OScolors.TextActive,
                        CalendarMonthBackground = DMode.OScolors.Control,
                        CalendarTitleBackColor = DMode.OScolors.Surface,
                        CalendarTitleForeColor = DMode.OScolors.TextActive
                    };
                    ((DateTimePicker)field_Control).ValueChanged += (sender, args) =>
                    {
                        field.Value = ((DateTimePicker)sender!).Value.ToString("o");
                        ((DateTimePicker)sender!).Value = Convert.ToDateTime(field.Value, CultureInfo.InvariantCulture);
                        Err.SetError(field_Control, field.ErrorText);
                        Err.SetIconAlignment(field_Control, ErrorIconAlignment.MiddleLeft);
                    };
                }
                if (field.ValueType == ValueTypes.Time)
                {
                    field_Control = new DateTimePicker
                    {
                        Value = Convert.ToDateTime(field.Value, CultureInfo.InvariantCulture),
                        Dock = DockStyle.Fill,
                        Format = DateTimePickerFormat.Time
                    };
                    ((DateTimePicker)field_Control).ValueChanged += (sender, args) =>
                    {
                        field.Value = ((DateTimePicker)sender!).Value.ToString("o");
                        ((DateTimePicker)sender!).Value = Convert.ToDateTime(field.Value, CultureInfo.InvariantCulture);
                        Err.SetError(field_Control, field.ErrorText);
                        Err.SetIconAlignment(field_Control, ErrorIconAlignment.MiddleLeft);
                    };
                }
                if (field.ValueType == ValueTypes.Boolean)
                {
                    field_Control = new CheckBox
                    {
                        Checked = Convert.ToBoolean(field.Value),
                        Dock = DockStyle.Fill,
                        Text = field.Key
                    };
                    ((CheckBox)field_Control).CheckedChanged += (sender, args) =>
                    {
                        field.Value = ((CheckBox)sender!).Checked.ToString();
                        ((CheckBox)sender!).Checked = Convert.ToBoolean(field.Value);
                        Err.SetError(field_Control, field.ErrorText);
                    };
                }
                if (field.ValueType == ValueTypes.Dynamic)
                {
                    field_Control = new FlatComboBox
                    {
                        DataSource = field.DataSet,
                        ValueMember = "Value",
                        DisplayMember = "Key",
                        Dock = DockStyle.Fill,
                        BackColor = DMode.OScolors.Control,
                        ButtonColor = DMode.OScolors.Surface,
                        ForeColor = DMode.OScolors.TextActive,
                        SelectedValue = field.Value,
                        DropDownStyle = ComboBoxStyle.DropDownList,
                        FlatStyle = (DMode.IsDarkMode ? FlatStyle.Flat : FlatStyle.Standard)
                    };
                    ((ComboBox)field_Control).SelectedValueChanged += (sender, args) =>
                    {
                        field.Value = ((ComboBox)sender!).SelectedValue.ToString()!;
                        ((ComboBox)sender!).SelectedValue = Convert.ToString(field.Value)!;
                        Err.SetError(field_Control, field.ErrorText);
                    };
                }

                Contenedor.Controls.Add(field_label, 0, currentRow);
                if (field_Control != null)
                {
                    if (field.ValueType == ValueTypes.Multiline)
                    {
                        Contenedor.Controls.Add(field_Control, 1, currentRow);
                        const int spanRow = 6;
                        for (int i = 0; i < spanRow; i++)
                        {
                            currentRow++;
                            Contenedor.RowCount++;
                            Contenedor.RowStyles.Add(new RowStyle(SizeType.Absolute, field_Control.Height));
                        }
                        Contenedor.SetRowSpan(field_Control, spanRow);
                    }
                    else
                    {
                        Contenedor.Controls.Add(field_Control, 1, currentRow);
                    }

                    Err.SetIconAlignment(field_Control, ErrorIconAlignment.MiddleLeft);
                    if (field_Control is ComboBox box)
                    {
                        box.CreateControl();
                        box.SelectedValue = field.Value;
                    }

                    field_Control.TabIndex = currentRow;
                }
                currentRow++;
            }

            Contenedor.Width = form.ClientSize.Width - 20;
            #endregion Controls for KeyValues

            form.ClientSize = new Size(340,
                bottomPanel.Height +
                lblPrompt.Height +
                Contenedor.Height +
                20
            );
            form.FormClosing += (sender, e) =>
            {
                if (form.ActiveControl == form.AcceptButton)
                {
                    ValidateEventArgs cArgs = new ValidateEventArgs(null);
                    ValidateControlsHandler?.Invoke(form, cArgs);

                    e.Cancel = cArgs.Cancel;
                    if (!e.Cancel)
                    {
                        form.DialogResult = form.AcceptButton!.DialogResult;
                    }
                }
            };
            return form.ShowDialog();
        }

        #endregion InputBox

        #region Private Stuff

        private static readonly Dictionary<Control, (Timer timer, EventHandler disposedHandler)> timers = new();

        private static void AddTextChangedDelay<TControl>(TControl control, int milliseconds, Action<TControl> action) where TControl : Control
        {
            if (timers.TryGetValue(control, out var existingEntry))
            {
                existingEntry.timer.Stop();
                existingEntry.timer.Dispose();
                control.Disposed -= existingEntry.disposedHandler;
                timers.Remove(control);
            }

            var timer = new Timer { Interval = milliseconds };
            EventHandler? disposedHandler = null;

            timer.Tick += (sender, e) =>
            {
                timer.Stop();
                if (timers.ContainsKey(control))
                {
                    timers.Remove(control);
                }
                if (disposedHandler != null)
                {
                    control.Disposed -= disposedHandler;
                }
                action(control);
                timer.Dispose();
            };

            disposedHandler = (sender, e) =>
            {
                if (timers.TryGetValue(control, out var entryToDispose))
                {
                    entryToDispose.timer.Stop();
                    entryToDispose.timer.Dispose();
                    timers.Remove(control);
                }
            };

            control.Disposed += disposedHandler;
            timer.Start();
            timers.Add(control, (timer, disposedHandler));
        }

        public static string GetCurrentLanguage(string pDefault = "en")
        {
            string _ret = pDefault;
            string CurrentLanguage = CultureInfo.CurrentUICulture.TwoLetterISOLanguageName;
            if (IsCurrentLanguageSupported(new List<string> { "en", "es", "fr", "de", "ru", "ko", "pt" }, CurrentLanguage))
            {
                _ret = CurrentLanguage;
            }
            if (CurrentLanguage.ToLowerInvariant().Equals("zh"))
            {
                var LangVariable = CultureInfo.CurrentCulture.Name;
                if (string.Equals(LangVariable, "zh-CN") || string.Equals(LangVariable, "zh-SG") || string.Equals(LangVariable, "zh-Hans"))
                {
                    _ret = "zh-Hans";
                }
                else if (string.Equals(LangVariable, "zh-TW") || string.Equals(LangVariable, "zh-HK") || string.Equals(LangVariable, "zh-MO") || string.Equals(LangVariable, "zh-Hant"))
                {
                    _ret = "zh-Hant";
                }
                else
                {
                    _ret = "zh-Hans";
                }
            }
            return _ret;
        }

        private static Dictionary<string, string> GetButtonTranslations(string pLanguage)
        {
            Dictionary<string, string> _ret = new Dictionary<string, string>();
            Dictionary<string, string> ButtonTranslations = new Dictionary<string, string> {
                { "en", "OK|Cancel|Yes|No|Continue|Retry|Abort|Ignore|Try Again" },
                { "es", "Aceptar|Cancelar|S|No|Continuar|Reintentar|Abortar|Ignorar|Intentar" },
                { "fr", "Accepter|Annuler|Oui|Non|Continuer|Ressayer|Abandonner|Ignorer|Essayer" },
                { "de", "Akzeptieren|Abbrechen|Ja|Nein|Weiter|Wiederholen|Abbrechen|Ignorieren|Versuchen" },
                { "ru", "||||||||" },
                { "ko", "||||| ||| " },
                { "pt", "Aceitar|Cancelar|Sim|No|Continuar|Tentar novamente|Abortar|Ignorar|Tentar" },
                { "zh-Hans", "||||||||" },
                { "zh-Hant", "||||||||" }
              };
            string? raw = ButtonTranslations[pLanguage];
            if (!string.IsNullOrEmpty(raw))
            {
                var Words = raw.Split('|').ToList();
                _ret = new Dictionary<string, string> {
                    { "OK", Words[0] },
                    { "Cancel", Words[1] },
                    { "Yes", Words[2] },
                    { "No", Words[3] },
                    { "Continue", Words[4] },
                    { "Retry", Words[5] },
                    { "Abort", Words[6] },
                    { "Ignore", Words[7] },
                    { "Try Again", Words[8] }
                };
            }

            return _ret;
        }

        private static bool IsCurrentLanguageSupported(List<string> languages, string currentLanguage)
        {
            if (languages == null || currentLanguage == null)
            {
                throw new ArgumentNullException(languages == null ? nameof(languages) : nameof(currentLanguage));
            }

            currentLanguage = currentLanguage.ToLowerInvariant();
            if (languages.Contains(currentLanguage))
            {
                return true;
            }

            if (currentLanguage.Length >= 2)
            {
                string baseLanguage = currentLanguage.Substring(0, 2);
                return languages.Contains(baseLanguage);
            }

            return false;
        }

        #endregion Private Stuff
    }

    public enum MsgIcon
    {
        None = 0,
        Info,
        Success,
        Warning,
        Error,
        Question,
        Lock,
        User,
        Forbidden,
        AddNew,
        Cancel,
        Edit,
        List
    }

    public class KeyValue
    {
        #region Private Members

        private string _value = string.Empty;
        #endregion Private Members

        #region Contructors

        public KeyValue()
        {
        }

        public KeyValue(string pKey, string pValue, ValueTypes pType = ValueTypes.String, List<KeyValue>? pDataSet = null)
        {
            Key = pKey;
            Value = pValue;
            ValueType = pType;
            DataSet = pDataSet;
        }

        #endregion Contructors

        #region Public Properties

        public enum ValueTypes
        {
            String = 0,
            Integer = 1,
            Decimal = 2,
            Date = 3,
            Time,
            Boolean,
            Dynamic,
            Password,
            Multiline
        }

        public string Key { get; set; } = string.Empty;

        public string Value
        {
            get => _value;
            set
            {
                var newValue = value;
                OnValidate(ref newValue);

                if (_value != newValue)
                {
                    _value = newValue;
                }
            }
        }

        public ValueTypes ValueType { get; set; } = ValueTypes.String;

        public List<KeyValue>? DataSet { get; set; }

        public string ErrorText { get; set; } = string.Empty;
        #endregion Public Properties

        #region Public Events

        public class ValidateEventArgs : EventArgs
        {
            public ValidateEventArgs(string? newValue)
            {
                NewValue = newValue;
                Cancel = false;
            }

            public string? NewValue { get; }
            public string OldValue { get; set; } = string.Empty;

            public bool Cancel { get; set; }
            public string ErrorText { get; set; } = string.Empty;
        }

        public event EventHandler<ValidateEventArgs>? Validate;
        protected virtual void OnValidate(ref string newValue)
        {
            var validateHandler = Validate;
            if (validateHandler != null)
            {
                var args = new ValidateEventArgs(newValue) { OldValue = _value };
                validateHandler(this, args);

                if (args.Cancel) { newValue = _value; }

                ErrorText = args.ErrorText;
            }
        }

        #endregion Public Events

        #region Public Methods

        public override string ToString()
        {
            return string.Format("{0} - {1}", Key, Value);
        }

        #endregion Public Methods
    }

    public class Base64Image
    {
        public Base64Image()
        {
        }

        public Base64Image(string pName, string pBase64Data)
        {
            Name = pName;
            Base64Data = pBase64Data;
        }

        public string Name { get; set; } = string.Empty;
        public string Base64Data { get; set; } = string.Empty;

        public Image?
        Image
        {
            get
            {
                if (string.IsNullOrEmpty(Base64Data)) return null;
                return System.Drawing.Image.FromStream(new MemoryStream(Convert.FromBase64String(Base64Data)));
            }
        }
    }

    public class Base64Icons
    {
        private List<Base64Image> _Icons = new List<Base64Image> {
        new Base64Image("Info", "iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsIAAA7CARUoSoAAAA4OSURBVHhexZt5jF1VHcfP22amM7S1FVSKSN1F3HejiUtINZgQFJdgxH9cYrBYip3pDG0YGyt0YTpUDQmNGjXGhcSoBBWr4FINRkCt4L6h4t7WltJ2Zt7Me34/99zz7j13ee++O1P9Jt959727nPNbzu/8zu+eqZj/JTb+yJiBIR1UjUm23BYXWsbUdO7knDEfeZ79/TTj9CpgVAJXl6mVks2glOaCMXv+rYMLg5+WGkuoAPX2moPGtOrh99MAFLJyUO38SQdLo5DFK2Djz42py3Ubct2WPrMfuUp8tLgm/FwtniHWRCAzmxPiUfGf4t/Ev4ffeWgac7PyjF/r4K32e0ksQgEPyBLH1b3cRzxOfK74TPHxIkqQ+TptYk8I3G988puCQCA8pr5P/In4B9Gircsq4a3BU6S/Xc+23/tEbu+7YlRWr8gw1dTtw+LzxVeLTxOxMhdhYSzphM5rN34O73Ae8rD4O/HbogKLkeZj4Mk1/bmeyy8IfiqK/hUwen/UrQj88krxdeKTRZ47Lzqh+a4x0mE3BcC4wty9Lrj8Ubxd/KaIp0Tgjl3PsMcFUVwB43hi5uWonIH4rOCb4rYY73gj/I4VD4uHws+HRA3kAAyN5SKx4UzxkeF37ud5cWXwPD5/KX5O/LHo4+7zjLmD23ujoAI03ifkdYy9CHTkjeIl4ogYt4br5H/EX4j3ir8X/yWiCITJALe0edajxCeIxBBMikIAynAYEFHg10QUcVKMQE6x29kkHwUU8C1Z/zH20NnAWum94otFBMdlOYObMhwQ9jvi90WE7o6KDN3GyJnAK14iEleeyg+C8zLaQhG454fFv4oWnD2kyz6ODvPRQwEx4SM8SbxKJLJjAZpyrv6g+BXxgIil88FdHYXqoHeypIzKvFTE4/AOYoxTPEpg2twrKkjFMKvT0/mBsXur4/6zhKeIm0W04oRHcDryDfHzItOXwKM5HX609Gc3M2IBrFe7zCeoNQ2GyKXixSKxw3kDx7S9R/Tjwo78wJivgHS0x/ITIuMTt+dehCdP/YSIu0eg86dkpLXy2g0YrySuvkeiSTY//gAWC+8SzxXpjzMGwXWX+DPRgr5c9w/9SWeP2QrYLOH9M4z5D4i4/YzIWTTOWJ8SSVgsSI62a/rnip0FLd4Lo5KlJUPX1aTfL7LKq0VM7DySfpFNbhP/LEbI8IRsBfhTHlq9RnyRGJ+2GB83iHiARVvtN8U9XaLvhbeagbUNU5s7Zporzg6aqcwoXDQGte6RIW++KLwwA+vVr2W6wffMFeJG0fXPKYFpEqORYltkxIO0AjarET8gXSZeLmJ5Hk7AIRn5oBgJz6mm2p96Qfi9ByYnz9Hfi0yzNWxqlRlllbeZbduiKJ6HdP8Akz5GwuXcdMy6m4B8c/ANYKCEV/pPSrs+6rpWRKPMU0xzJDK4V+T2oEug8TA5eZ6EvkQcM8N1FkcWswsPmfn2lBmpf0qK8J+dhXSAPkvE4qxBUIILoTvFH9pDIaEEP87633A0Mjyirptu+CTgRR3EJ/IXRD4Qfm5hk1aON3rCg8HaCgm/zZycnwqu64UjajOeFllv3CeeEum7MxgezJxikVi/xESWJAgTgdyewewiPq5PDu5H+52y/K7CC5B1ZqC2PjzOxnD9Uk2Zrw2/5WOf2pxKed1B8UsigtNnVMTsFT0PGcdZXFpEChjzXAqNsbBx4IF/Eb8QfAM8yLdAbxxv9rYsODr38vCoN1pyStw6Agr4jUjw5gReu05kOW7R4pRFpADfNVjSsqpzIuJSBBSb5JC2sgZPW6A75hZcKtsdrTYJVzFQBzhEUtgBwfqLIsIjHyeJCy8TLWJ+Hzv0QN6NRngI6mK+PyBakLuXK0Bgjd5oF7zOgXzf9wJqBri0MzXPY0jjyR6yFIC2KGagOZQAKUTY3J525r3GiqNRZa3QG9VguPWHOS0GIyXguVrIBIEQIMta8fzgGwjjgFUAFZ4IpJhUcriZ8yxpfyBaoI4bSmZ4Q7Xe8zxoVHtPg0lMa2HqD2O8gPyX4YtmyAtitXbrHFYBtVBz7WA+Qzo++ZGr0E60pDVrfTBQ675CdFhWL6aoJPxhQFssipCBE5DpitmsA38IVKqP0F/yfcaMU4K/siprfYv9SoBcOp2PRtUvbhTFjlTffioyHJATmR4rsq4J0eYEQ6UDlrlMF879KT5SjLSgyrIYkOEdm2OuzkezRRTfb7+UwBHyoA4eEBnCyELnSZlRgsXG+3XCL3iQneEiTgHU7iL3L1Bi6olKYoWWBAoqkgrnYd8Lw4MA9J+VIbLgzcQDls8Wg5XgRBxow0USzpH3Z4/by74cHvSJRpWFVD4qJWaAfOD+GDAuJ0voDpIKcNkSSoBHgm8ZGBxJ3loQQzVKV/nopaCiWO3qqIEXABfTiHMdJKVg4cNFDlRXBOcUEWoz4al+0Wsm6KWgojji5DbHwk+AbNHCSEgqgDESRxix4zqxWBiJBdP+0H0mKDpVFocrlzlUTTsSu6Qfyyf8Obc4us0EVjHlZ4CiiDl0UgHJec4mDRnC1o/3LvfnIm8mWOwMkA23NHaQjJGYSQVE9TML+34po2a/MFTs1VMmBqq/DY98VIJS21KDmmEcXqKQVABJg4uWcHWW9cEpdm6UxfKBbEFXDkRrjqWDmw4QBNm86K2AEB5ZkDS4X/g8U9ZnZkjjM28KD0phv5lbeL+Zmbehem7hpDkxP2nq1VuD70sH3J9538mEApDRQr/qB611xjtaYLHwIdFlguTkVFtJKTUnKK+Y7v6urS/Y2h/Vmv1LNvbfLnnWdOShUEpRFC/AZYlpyHeXqF/agUbiFVYupNbPC0luYCU1Ld4pWhSt/v6/4Fe2qWxttYcBmGVGRZtt7rggMwZgCbeG5ry/X23Cqx2UB9Yf27LZXDWx12zacm2hSnAvjPHOIDy2eI4YL+mzzLbTV+Akbi0QzQocOXfgUVRSGBZRQbEznBYBhD0xf0Dr/h0KfO8LyuGzC/eZ0S289S2Pmie9K4C4yhay8rbIS8KsAvyyNut/sjHOMQxI+XgtbYGK2BlWFoHwzdsldLQqA4O15aZauae8J6hP/sSE+7P0dQpAcDZqWMzYi60CfL9hNxZF0HgB8VUiGrWX1v2W+sQ6M9Kg5pjGUG2VOvbm8Ft/IJCH0shLOeJVsEvtkYXkK7LcXlvU7dySALs7nFZYUtJhdmlYsJ21rBfMt7ySVArN1srwqA94RR2hwtiH9B2gCF7ouPeGHUQK8BMe3qWRrLiyMni9GK2kGrq+jBLq1VQnPAz3WQ+8UiP2CiatDrA2e5foOwMW4VlhfldMIVLAnOcMlMK+Lsa94IkiOzMsuHywVEDcrwB4W3js40TzoAIZm56KY0QOtdxzKt6vUxx0r/RQyB1i9CabV/ghvMFvJjQBROd46nUi7k8AQZMogt+il2tUiU+KN/VRLiPQnZyflrXxKouHmwfMGY3LCydEeN+A2vUl4G0Wb4jdC128AI8aF21dgOuvj3IZz+yJnVpokD0/TngeSCB8t8g2GYu6nrjCxZqCQMjhOpsaeJZlP8KDmrrjC8/q7D0iMYS+IhvmvEWMiiKeiMlHgPR793eKbxCp1gI8g4tIKRNbVtXerkWVzXtjk5Id5nu/5/RpTCRQuxiDsYiObJqywFsTZX3fA8AOPRm9RfisiMA0whka4ClYkDdIEXjaWPeq9+Igtz+a6jL9ulIkV6Fv9BHXZzr/pBihmjC/kPYAkPYCkpZJ0W2P4z5STKRFw1SPIzCUGjLA9uIvebtDhty6hik0/N4Bbr9BRHj6hfAohLfY20X201sMqsvbvIQvQLYCaHDibD3OcwWiHHsEaZRgyL00xkqRnRnRtrSGhuC84gIjsanLumxU7Iqtd+t+6Zm8g6543QkCHmOeV+7O8kR8jjHKXaaqPrB/gKHZ1DMy+pGjgBBpT2AHFK5PoHGegBJYNvNOnpcF/O6Df6SYUwi5kY1cBcAeRTw9u3cIyVT3FpF+OOHpB3Hqo6I/55faKAlYW5+jZ/uaJ4fE7dyGSc4yDdCxX4koQqYLcvBscMesLPNgaFkyDMpuyd5wLvoNlZDdkeQQg/AvyBWMedz+JtGu9QH3s8GyyxaeZJNpvENT/lnxhDAACxYCz9NFLM7gdB3hWKE6iMAoIlln7BdEcxY25PYogDac4lEKsYiAh+UxQIRZ2WCaW/LRWwGApGNIcvnbVZkB3ia+RsT6xAXXKacIUlBWl7ylJVZQAsv3DAu8idyWjRr0niUtqzp+pw2nbNoErFuI9kfsKbxK3aAnBabkYgoA50sJF+up6TuIwGxFw5FxybiAbmjQcYot1OMoSDBrUJzEkoDxS3ClIsXQcv9Yxe/xZyIWz4NUdW6RsHcGw8eBKw6ruY8VK90VV4ADu8mwsQ8WSWxFo76H5Vyn6Q7kjjgdOAfi/eA37secztrQKZNdHwyvr4rx116Cbk3vEeiK/hXAcGhJtiH1J303lSO2uL1CZE8O4zcuEMe92nTXQARGYcQZ9hd9TzwgRpVdwB3MNEy9fU65/SvAYYNyoBE1iFhp0HE2JBG8CJQkUsQMrEh3IXCfrh9OcJ5K8ERoylhUcvjXm/QUi2rB7nLF2vIKcPi0hva9WsMMS2Ynjg/GMeVpAhmKYHzzipp/IkBR9IHhwhzOVEaMYHxDjtNCA1Yh50r68XL/L+iweAU4sO2MYNRGpsKgfZjtR1kINmlK0yX/UTKJpVNAEm5vPyO4bCurJexhPYBV3FR/wa0oTp8CkrhC8WuVZjY3ZvMwoymsJk4VTJsXBWP+C8Jv42GReAgfAAAAAElFTkSuQmCC")
        };
        public List<Base64Image> Icons
        {
            get
            {
                return this._Icons;
            }
            set
            {
                this._Icons = value;
            }
        }

        public Image?
        GetIcon(string pName)
        {
            Image?
            _ret = null;
            if (_Icons != null && _Icons.Count > 0)
            {
                var Found = _Icons.Find(x => x.Name == pName);
                if (Found != null)
                {
                    _ret = Found.Image;
                }
            }
            return _ret;
        }

        public Image? GetIcon(MsgIcon pIcon) => GetIcon(pIcon.ToString());
        public bool AddIcon(string pName, string pFilePath)
        {
            bool _ret = false;
            if (!string.IsNullOrEmpty(pFilePath) && File.Exists(pFilePath))
            {
                var _icon = File.ReadAllBytes(pFilePath);
                if (_icon != null)
                {
                    if (_Icons is null) _Icons = new List<Base64Image>();
                    _Icons.Add(new Base64Image(pName, Convert.ToBase64String(_icon)));
                    _ret = true;
                }
            }
            return _ret;
        }
    }
}

--------------------------------------------------
// Full Path: C:/Users/anon/PROGRAMMING/C#/SimpleFirewall/VS Minimal Firewall/MinimalFirewall-NET8/Backups/v2.5.5 - ws/2.5.5.6 - security vulnerability fix 3/MFWConstants.cs
--------------------------------------------------------------------------------
// MFWConstants.cs
namespace MinimalFirewall
{
    public static class MFWConstants
    {
        public const string MainRuleGroup = "Minimal Firewall - MFW";
        public const string WildcardRuleGroup = "Minimal Firewall (Wildcard) - MFW";
        public const string WildcardDescriptionPrefix = "MFW_Wildcard_Path:[";
        public const string UwpDescriptionPrefix = "UWP App; PFN=";
        public const string MfwRuleSuffix = " - MFW";
    }
}

--------------------------------------------------
// Full Path: C:/Users/anon/PROGRAMMING/C#/SimpleFirewall/VS Minimal Firewall/MinimalFirewall-NET8/Backups/v2.5.5 - ws/2.5.5.6 - security vulnerability fix 3/MinimalFirewall-NET8.csproj
--------------------------------------------------------------------------------
<Project Sdk="Microsoft.NET.Sdk">

	<PropertyGroup>
		<OutputType>WinExe</OutputType>
		<TargetFramework>net8.0-windows8.0</TargetFramework>
		<TargetPlatformVersion>8.0</TargetPlatformVersion>
		<SupportedOSPlatformVersion>8.0</SupportedOSPlatformVersion>
		<RootNamespace>MinimalFirewall</RootNamespace>
		<Nullable>enable</Nullable>
		<ImplicitUsings>enable</ImplicitUsings>
		<UseWindowsForms>true</UseWindowsForms>
		<ApplicationIcon>logo.ico</ApplicationIcon>
		<ApplicationManifest>app.manifest</ApplicationManifest>
		<PlatformTarget>AnyCPU</PlatformTarget>
		<RuntimeIdentifiers>win-x64</RuntimeIdentifiers>
		<AllowUnsafeBlocks>true</AllowUnsafeBlocks>
		<AssemblyVersion>2.5.5.0</AssemblyVersion>
		<FileVersion>2.5.5.0</FileVersion>
		<Company>Deminimis</Company>
		<Product>Minimal Firewall</Product>
		<PackageProjectUrl>https://github.com/deminimis/minimalfirewall</PackageProjectUrl>
		<PackageTags>firewall, security, privacy</PackageTags>
		<StartupObject>MinimalFirewall.Program</StartupObject>
		<Configurations>Debug;Release</Configurations>
		<Platforms>AnyCPU;x64</Platforms>
		<ServerGarbageCollection>false</ServerGarbageCollection>
		<TieredCompilation>false</TieredCompilation>
		<GenerateResourceWarnOnBinaryFormatterUse>false</GenerateResourceWarnOnBinaryFormatterUse>

		<PublishSingleFile>true</PublishSingleFile>
		<IncludeNativeLibrariesForSelfExtract>true</IncludeNativeLibrariesForSelfExtract>
	</PropertyGroup>

	<ItemGroup>
		<None Remove="1 ClubGPT - developer team in one GPT .md" />
		<None Remove="1-adminnhelper-allfiles.txt" />
		<None Remove="1-oldfiles4.8.txt" />
		<None Remove="1allfiles.txt" />
		<None Remove="1file_combiner.py" />
	</ItemGroup>

	<ItemGroup>
		<EmbeddedResource Include="logo.ico" />
		<EmbeddedResource Include="logo.png" />
	</ItemGroup>

	<ItemGroup>
		<COMReference Include="NetFwTypeLib">
			<WrapperTool>tlbimp</WrapperTool>
			<VersionMinor>0</VersionMinor>
			<VersionMajor>1</VersionMajor>
			<Guid>58fbcf7c-e7a9-467c-80b3-fc65e8fcca08</Guid>
			<Lcid>0</Lcid>
			<Isolated>false</Isolated>
			<EmbedInteropTypes>true</EmbedInteropTypes>
		</COMReference>
	</ItemGroup>

	<ItemGroup>
		<PackageReference Include="Microsoft.Extensions.Caching.Memory" Version="10.0.0" />
		<PackageReference Include="System.Management" Version="10.0.0" />
	</ItemGroup>

	<ItemGroup>
		<Compile Update="Properties\Resources.Designer.cs">
			<DesignTime>True</DesignTime>
			<AutoGen>True</AutoGen>
			<DependentUpon>Resources.resx</DependentUpon>
		</Compile>
		<Compile Update="Properties\Settings.Designer.cs">
			<DesignTimeSharedInput>True</DesignTimeSharedInput>
			<AutoGen>True</AutoGen>
			<DependentUpon>Settings.settings</DependentUpon>
		</Compile>
	</ItemGroup>

	<ItemGroup>
		<EmbeddedResource Update="Properties\Resources.resx">
			<Generator>ResXFileCodeGenerator</Generator>
			<LastGenOutput>Resources.Designer.cs</LastGenOutput>
		</EmbeddedResource>
	</ItemGroup>

	<ItemGroup>
		<None Update="Properties\Settings.settings">
			<Generator>SettingsSingleFileGenerator</Generator>
			<LastGenOutput>Settings.Designer.cs</LastGenOutput>
		</None>
	</ItemGroup>

</Project>

--------------------------------------------------
// Full Path: C:/Users/anon/PROGRAMMING/C#/SimpleFirewall/VS Minimal Firewall/MinimalFirewall-NET8/Backups/v2.5.5 - ws/2.5.5.6 - security vulnerability fix 3/MinimalFirewall-WindowsStore.sln
--------------------------------------------------------------------------------

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.14.36511.14
MinimumVisualStudioVersion = 10.0.40219.1
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "MinimalFirewall-NET8", "MinimalFirewall-NET8.csproj", "{6326C497-403B-F991-2F6A-A5FBA67C364C}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Debug|x64 = Debug|x64
		Release|Any CPU = Release|Any CPU
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{6326C497-403B-F991-2F6A-A5FBA67C364C}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{6326C497-403B-F991-2F6A-A5FBA67C364C}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{6326C497-403B-F991-2F6A-A5FBA67C364C}.Debug|x64.ActiveCfg = Debug|x64
		{6326C497-403B-F991-2F6A-A5FBA67C364C}.Debug|x64.Build.0 = Debug|x64
		{6326C497-403B-F991-2F6A-A5FBA67C364C}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{6326C497-403B-F991-2F6A-A5FBA67C364C}.Release|Any CPU.Build.0 = Release|Any CPU
		{6326C497-403B-F991-2F6A-A5FBA67C364C}.Release|x64.ActiveCfg = Release|x64
		{6326C497-403B-F991-2F6A-A5FBA67C364C}.Release|x64.Build.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {7039C681-60B0-48A9-A48C-EB2893D752A3}
	EndGlobalSection
EndGlobal


--------------------------------------------------
// Full Path: C:/Users/anon/PROGRAMMING/C#/SimpleFirewall/VS Minimal Firewall/MinimalFirewall-NET8/Backups/v2.5.5 - ws/2.5.5.6 - security vulnerability fix 3/NotifierForm.cs
--------------------------------------------------------------------------------
// File: NotifierForm.cs
using DarkModeForms;
using System.Drawing;
namespace MinimalFirewall
{
    public partial class NotifierForm : Form
    {
        public enum NotifierResult { Ignore, Allow, Block, TemporaryAllow, CreateWildcard }
        public NotifierResult Result { get; set; } = NotifierResult.Ignore;
        public PendingConnectionViewModel PendingConnection { get; private set; }
        public TimeSpan TemporaryDuration { get; private set; }
        public bool TrustPublisher { get; private set; } = false;
        private readonly DarkModeCS dm;

        public NotifierForm(PendingConnectionViewModel pending, bool isDarkMode)
        {
            InitializeComponent();
            PendingConnection = pending;
            dm = new DarkModeCS(this)
            {
                ColorMode = isDarkMode ? DarkModeCS.DisplayMode.DarkMode : DarkModeCS.DisplayMode.ClearMode
            };
            dm.ApplyTheme(isDarkMode);
            string appName = string.IsNullOrEmpty(pending.ServiceName) ? pending.FileName : $"{pending.FileName} ({pending.ServiceName})";
            this.Text = "Connection Blocked";
            infoLabel.Text = $"Blocked a {pending.Direction} connection for:";
            appNameLabel.Text = appName;
            pathLabel.Text = pending.AppPath;

            allowButton.Text = $"Allow {pending.Direction}";
            blockButton.Text = $"Block {pending.Direction}";

            this.AcceptButton = this.ignoreButton;

            allowButton.FlatStyle = FlatStyle.Flat;
            blockButton.FlatStyle = FlatStyle.Flat;

            Color allowColor = Color.FromArgb(204, 255, 204);
            Color blockColor = Color.FromArgb(255, 204, 204);

            allowButton.BackColor = allowColor;
            blockButton.BackColor = blockColor;

            allowButton.ForeColor = Color.Black;
            blockButton.ForeColor = Color.Black;

            allowButton.FlatAppearance.MouseOverBackColor = ControlPaint.Dark(allowColor, 0.1f);
            blockButton.FlatAppearance.MouseOverBackColor = ControlPaint.Dark(blockColor, 0.1f);
            allowButton.FlatAppearance.MouseDownBackColor = ControlPaint.Dark(allowColor, 0.2f);
            blockButton.FlatAppearance.MouseDownBackColor = ControlPaint.Dark(blockColor, 0.2f);

            allowButton.FlatAppearance.BorderSize = 0;
            blockButton.FlatAppearance.BorderSize = 0;


            SetupTempAllowMenu();
            SetupTrustPublisherCheckBox();
        }

        private void SetupTempAllowMenu()
        {
            tempAllowContextMenu.Items.Add("For 2 minutes").Click += (s, e) => SetTemporaryAllow(TimeSpan.FromMinutes(2));
            tempAllowContextMenu.Items.Add("For 5 minutes").Click += (s, e) => SetTemporaryAllow(TimeSpan.FromMinutes(5));
            tempAllowContextMenu.Items.Add("For 15 minutes").Click += (s, e) => SetTemporaryAllow(TimeSpan.FromMinutes(15));
            tempAllowContextMenu.Items.Add("For 1 hour").Click += (s, e) => SetTemporaryAllow(TimeSpan.FromHours(1));
            tempAllowContextMenu.Items.Add("For 3 hours").Click += (s, e) => SetTemporaryAllow(TimeSpan.FromHours(3));
            tempAllowContextMenu.Items.Add("For 8 hours").Click += (s, e) => SetTemporaryAllow(TimeSpan.FromHours(8));
        }

        private void SetupTrustPublisherCheckBox()
        {
            if (SignatureValidationService.GetPublisherInfo(PendingConnection.AppPath, out var publisherName) && publisherName != null)
            {
                trustPublisherCheckBox.Text = $"Always trust publisher: {publisherName}";
                trustPublisherCheckBox.Visible = true;
            }
            else
            {
                trustPublisherCheckBox.Visible = false;
            }
        }

        private void SetTemporaryAllow(TimeSpan duration)
        {
            Result = NotifierResult.TemporaryAllow;
            TemporaryDuration = duration;
            this.DialogResult = DialogResult.OK;
            this.Close();
        }

        private void allowButton_Click(object sender, EventArgs e)
        {
            Result = NotifierResult.Allow;
            TrustPublisher = trustPublisherCheckBox.Visible && trustPublisherCheckBox.Checked;
            this.DialogResult = DialogResult.OK;
            this.Close();
        }

        private void blockButton_Click(object sender, EventArgs e)
        {
            Result = NotifierResult.Block;
            this.DialogResult = DialogResult.OK;
            this.Close();
        }

        private void ignoreButton_Click(object sender, EventArgs e)
        {
            Result = NotifierResult.Ignore;
            this.DialogResult = DialogResult.Cancel;
            this.Close();
        }

        private void tempAllowButton_Click(object sender, EventArgs e)
        {
            tempAllowContextMenu.Show(tempAllowButton, new Point(0, tempAllowButton.Height));
        }

        private void createWildcardButton_Click(object sender, EventArgs e)
        {
            Result = NotifierResult.CreateWildcard;
            this.DialogResult = DialogResult.OK;
            this.Close();
        }
    }
}


--------------------------------------------------
// Full Path: C:/Users/anon/PROGRAMMING/C#/SimpleFirewall/VS Minimal Firewall/MinimalFirewall-NET8/Backups/v2.5.5 - ws/2.5.5.6 - security vulnerability fix 3/NotifierForm.Designer.cs
--------------------------------------------------------------------------------
// File: NotifierForm.Designer.cs
namespace MinimalFirewall
{
    partial class NotifierForm
    {
        private System.ComponentModel.IContainer components = null;
        private System.Windows.Forms.Label infoLabel;
        private System.Windows.Forms.Label appNameLabel;
        private System.Windows.Forms.Label pathLabel;
        private System.Windows.Forms.Button allowButton;
        private System.Windows.Forms.Button blockButton;
        private System.Windows.Forms.Button ignoreButton;
        private System.Windows.Forms.Button tempAllowButton;
        private System.Windows.Forms.ContextMenuStrip tempAllowContextMenu;
        private System.Windows.Forms.Button createWildcardButton;
        private System.Windows.Forms.CheckBox trustPublisherCheckBox;
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        private void InitializeComponent()
        {
            this.components = new System.ComponentModel.Container();
            this.infoLabel = new System.Windows.Forms.Label();
            this.appNameLabel = new System.Windows.Forms.Label();
            this.pathLabel = new System.Windows.Forms.Label();
            this.allowButton = new System.Windows.Forms.Button();
            this.blockButton = new System.Windows.Forms.Button();
            this.ignoreButton = new System.Windows.Forms.Button();
            this.tempAllowButton = new System.Windows.Forms.Button();
            this.tempAllowContextMenu = new System.Windows.Forms.ContextMenuStrip(this.components);
            this.createWildcardButton = new System.Windows.Forms.Button();
            this.trustPublisherCheckBox = new System.Windows.Forms.CheckBox();
            this.SuspendLayout();
            // 
            // infoLabel
            // 
            this.infoLabel.Location = new System.Drawing.Point(12, 9);
            this.infoLabel.Name = "infoLabel";
            this.infoLabel.Size = new System.Drawing.Size(532, 20);
            this.infoLabel.TabIndex = 0;
            this.infoLabel.Text = "Blocked a connection for:";
            // 
            // appNameLabel
            // 
            this.appNameLabel.Font = new System.Drawing.Font("Segoe UI", 12F, System.Drawing.FontStyle.Bold);
            this.appNameLabel.Location = new System.Drawing.Point(12, 38);
            this.appNameLabel.Name = "appNameLabel";
            this.appNameLabel.Size = new System.Drawing.Size(532, 21);
            this.appNameLabel.TabIndex = 1;
            this.appNameLabel.Text = "Application Name";
            // 
            // pathLabel
            // 
            this.pathLabel.AutoEllipsis = true;
            this.pathLabel.Font = new System.Drawing.Font("Segoe UI", 8F);
            this.pathLabel.Location = new System.Drawing.Point(12, 65);
            this.pathLabel.Name = "pathLabel";
            this.pathLabel.Size = new System.Drawing.Size(532, 20);
            this.pathLabel.TabIndex = 2;
            this.pathLabel.Text = "C:\\Path\\To\\Application.exe";
            // 
            // allowButton
            // 
            this.allowButton.Location = new System.Drawing.Point(16, 104);
            this.allowButton.Name = "allowButton";
            this.allowButton.Size = new System.Drawing.Size(120, 31);
            this.allowButton.TabIndex = 3;
            this.allowButton.Text = "Allow";
            this.allowButton.UseVisualStyleBackColor = true;
            this.allowButton.Click += new System.EventHandler(this.allowButton_Click);
            // 
            // blockButton
            // 
            this.blockButton.Location = new System.Drawing.Point(296, 104);
            this.blockButton.Name = "blockButton";
            this.blockButton.Size = new System.Drawing.Size(120, 31);
            this.blockButton.TabIndex = 4;
            this.blockButton.Text = "Block";
            this.blockButton.UseVisualStyleBackColor = true;
            this.blockButton.Click += new System.EventHandler(this.blockButton_Click);
            // 
            // ignoreButton
            // 
            this.ignoreButton.Location = new System.Drawing.Point(424, 104);
            this.ignoreButton.Name = "ignoreButton";
            this.ignoreButton.Size = new System.Drawing.Size(120, 31);
            this.ignoreButton.TabIndex = 5;
            this.ignoreButton.Text = "Ignore";
            this.ignoreButton.UseVisualStyleBackColor = true;
            this.ignoreButton.Click += new System.EventHandler(this.ignoreButton_Click);
            // 
            // tempAllowButton
            // 
            this.tempAllowButton.Location = new System.Drawing.Point(144, 104);
            this.tempAllowButton.Name = "tempAllowButton";
            this.tempAllowButton.Size = new System.Drawing.Size(144, 31);
            this.tempAllowButton.TabIndex = 6;
            this.tempAllowButton.Text = "Allow Temporarily ";
            this.tempAllowButton.UseVisualStyleBackColor = true;
            this.tempAllowButton.Click += new System.EventHandler(this.tempAllowButton_Click);
            // 
            // tempAllowContextMenu
            // 
            this.tempAllowContextMenu.Name = "tempAllowContextMenu";
            this.tempAllowContextMenu.Size = new System.Drawing.Size(61, 4);
            // 
            // createWildcardButton
            // 
            this.createWildcardButton.Location = new System.Drawing.Point(16, 148);
            this.createWildcardButton.Name = "createWildcardButton";
            this.createWildcardButton.Size = new System.Drawing.Size(170, 31);
            this.createWildcardButton.TabIndex = 7;
            this.createWildcardButton.Text = "Create Wildcard Rule...";
            this.createWildcardButton.UseVisualStyleBackColor = true;
            this.createWildcardButton.Click += new System.EventHandler(this.createWildcardButton_Click);
            // 
            // trustPublisherCheckBox
            // 
            this.trustPublisherCheckBox.AutoSize = true;
            this.trustPublisherCheckBox.Location = new System.Drawing.Point(16, 185);
            this.trustPublisherCheckBox.Name = "trustPublisherCheckBox";
            this.trustPublisherCheckBox.Size = new System.Drawing.Size(138, 17);
            this.trustPublisherCheckBox.TabIndex = 8;
            this.trustPublisherCheckBox.Text = "Always trust publisher";
            this.trustPublisherCheckBox.UseVisualStyleBackColor = true;
            this.trustPublisherCheckBox.Visible = false;
            // 
            // NotifierForm
            // 
            this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.ClientSize = new System.Drawing.Size(556, 225);
            this.Controls.Add(this.trustPublisherCheckBox);
            this.Controls.Add(this.createWildcardButton);
            this.Controls.Add(this.tempAllowButton);
            this.Controls.Add(this.ignoreButton);
            this.Controls.Add(this.blockButton);
            this.Controls.Add(this.allowButton);
            this.Controls.Add(this.pathLabel);
            this.Controls.Add(this.appNameLabel);
            this.Controls.Add(this.infoLabel);
            this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedDialog;
            this.MaximizeBox = false;
            this.MinimizeBox = false;
            this.Name = "NotifierForm";
            this.StartPosition = System.Windows.Forms.FormStartPosition.CenterScreen;
            this.Text = "Connection Blocked";
            this.ResumeLayout(false);
            this.PerformLayout();
        }

        #endregion
    }
}

--------------------------------------------------
// Full Path: C:/Users/anon/PROGRAMMING/C#/SimpleFirewall/VS Minimal Firewall/MinimalFirewall-NET8/Backups/v2.5.5 - ws/2.5.5.6 - security vulnerability fix 3/ObservableViewModel.cs
--------------------------------------------------------------------------------
// File: ObservableViewModel.cs
using System.ComponentModel;
using System.Runtime.CompilerServices;
using System.Collections.Generic;

namespace MinimalFirewall
{
    public class ObservableViewModel : INotifyPropertyChanged
    {
        public event PropertyChangedEventHandler? PropertyChanged;

        protected virtual void OnPropertyChanged([CallerMemberName] string? propertyName = null)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }

        protected bool SetField<T>(ref T field, T value, [CallerMemberName] string? propertyName = null)
        {
            if (EqualityComparer<T>.Default.Equals(field, value)) return false;
            field = value;
            OnPropertyChanged(propertyName);
            return true;
        }
    }
}

--------------------------------------------------
// Full Path: C:/Users/anon/PROGRAMMING/C#/SimpleFirewall/VS Minimal Firewall/MinimalFirewall-NET8/Backups/v2.5.5 - ws/2.5.5.6 - security vulnerability fix 3/Program.cs
--------------------------------------------------------------------------------
// File: Program.cs
using System.Globalization;
using System.Threading;
namespace MinimalFirewall
{
    internal static class Program
    {
        private const string AppGuid = "6326C497-403B-F991-2F6A-A5FBA67C364C";
        [STAThread]
        static void Main()
        {
            using (Mutex mutex = new Mutex(true, AppGuid, out bool createdNew))
            {
                if (createdNew)
                {
                    CultureInfo.DefaultThreadCurrentCulture = CultureInfo.InvariantCulture;
                    CultureInfo.DefaultThreadCurrentUICulture = CultureInfo.InvariantCulture;

                    ApplicationConfiguration.Initialize();

                    var args = Environment.GetCommandLineArgs();
                    bool startMinimized = args.Contains("-tray", StringComparer.OrdinalIgnoreCase);

                    var mainForm = new MainForm(startMinimized);
                    Application.Run(mainForm);
                }
                else
                {
                    MessageBox.Show("Minimal Firewall is already running.", "Application Already Running", MessageBoxButtons.OK, MessageBoxIcon.Information);
                }
            }
        }
    }
}

--------------------------------------------------
// Full Path: C:/Users/anon/PROGRAMMING/C#/SimpleFirewall/VS Minimal Firewall/MinimalFirewall-NET8/Backups/v2.5.5 - ws/2.5.5.6 - security vulnerability fix 3/PublisherWhitelistService.cs
--------------------------------------------------------------------------------
// File: PublisherWhitelistService.cs
using System.Diagnostics;
using System.IO;
using System.Text.Json;
using System.Text.Json.Serialization;

namespace MinimalFirewall
{
    public class PublisherWhitelistService
    {
        private readonly string _configPath;
        private HashSet<string> _trustedPublishers;

        public PublisherWhitelistService()
        {
            _configPath = ConfigPathManager.GetConfigPath("trusted_publishers.json");
            _trustedPublishers = Load();
        }

        private HashSet<string> Load()
        {
            try
            {
                if (File.Exists(_configPath))
                {
                    string json = File.ReadAllText(_configPath);
                    return JsonSerializer.Deserialize(json, WhitelistJsonContext.Default.HashSetString) ?? new HashSet<string>(StringComparer.OrdinalIgnoreCase);
                }
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"[ERROR] Failed to load publisher whitelist: {ex.Message}");
            }
            return new HashSet<string>(StringComparer.OrdinalIgnoreCase);
        }

        private void Save()
        {
            try
            {
                string json = JsonSerializer.Serialize(_trustedPublishers, WhitelistJsonContext.Default.HashSetString);
                File.WriteAllText(_configPath, json);
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"[ERROR] Failed to save publisher whitelist: {ex.Message}");
            }
        }

        public List<string> GetTrustedPublishers()
        {
            return _trustedPublishers.OrderBy(p => p).ToList();
        }

        public bool IsTrusted(string publisherName)
        {
            return !string.IsNullOrEmpty(publisherName) && _trustedPublishers.Contains(publisherName);
        }

        public void Add(string publisherName)
        {
            if (!string.IsNullOrEmpty(publisherName) && _trustedPublishers.Add(publisherName))
            {
                Save();
            }
        }

        public void Remove(string publisherName)
        {
            if (_trustedPublishers.Remove(publisherName))
            {
                Save();
            }
        }
    }

    [JsonSourceGenerationOptions(WriteIndented = true)]
    [JsonSerializable(typeof(HashSet<string>))]
    internal partial class WhitelistJsonContext : JsonSerializerContext { }
}

--------------------------------------------------
// Full Path: C:/Users/anon/PROGRAMMING/C#/SimpleFirewall/VS Minimal Firewall/MinimalFirewall-NET8/Backups/v2.5.5 - ws/2.5.5.6 - security vulnerability fix 3/RulesControl.cs
--------------------------------------------------------------------------------
using NetFwTypeLib;
using MinimalFirewall.TypedObjects;
using System.Data;
using System.ComponentModel;
using DarkModeForms;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using System.Windows.Forms;
using System.Linq;
using System.Diagnostics;
using System.IO;
using System;
using System.Drawing;

namespace MinimalFirewall
{
    public partial class RulesControl : UserControl
    {
        private MainViewModel _mainViewModel = null!;
        private FirewallActionsService _actionsService = null!;
        private WildcardRuleService _wildcardRuleService = null!;
        private BackgroundFirewallTaskService _backgroundTaskService = null!;
        private IconService _iconService = null!;
        private AppSettings _appSettings = null!;
        private DarkModeCS _dm = null!;

        private int _rulesSortColumn = -1;
        private SortOrder _rulesSortOrder = SortOrder.None;
        private BindingSource _bindingSource;
        public event Func<Task> DataRefreshRequested;
        public RulesControl()
        {
            InitializeComponent();
            this.DoubleBuffered = true;
        }

        public void Initialize(
            MainViewModel mainViewModel,
            FirewallActionsService actionsService,
            WildcardRuleService wildcardRuleService,
            BackgroundFirewallTaskService backgroundTaskService,
            IconService iconService,
            AppSettings appSettings,
            ImageList appIconList,
            DarkModeCS dm)
        {
            _mainViewModel = mainViewModel;
            _actionsService = actionsService;
            _wildcardRuleService = wildcardRuleService;
            _backgroundTaskService = backgroundTaskService;
            _iconService = iconService;
            _appSettings = appSettings;
            _dm = dm;

            programFilterCheckBox.Checked = _appSettings.FilterPrograms;
            serviceFilterCheckBox.Checked = _appSettings.FilterServices;
            uwpFilterCheckBox.Checked = _appSettings.FilterUwp;
            wildcardFilterCheckBox.Checked = _appSettings.FilterWildcards;
            systemFilterCheckBox.Checked = _appSettings.FilterSystem;
            rulesSearchTextBox.Text = _appSettings.RulesSearchText;
            _rulesSortColumn = _appSettings.RulesSortColumn;
            _rulesSortOrder = (SortOrder)_appSettings.RulesSortOrder;

            rulesDataGridView.AutoGenerateColumns = false;
            _bindingSource = new BindingSource();
            rulesDataGridView.DataSource = _bindingSource;
            _mainViewModel.RulesListUpdated += OnRulesListUpdated;

            programFilterCheckBox.CheckedChanged += filterCheckBox_CheckedChanged;
            serviceFilterCheckBox.CheckedChanged += filterCheckBox_CheckedChanged;
            uwpFilterCheckBox.CheckedChanged += filterCheckBox_CheckedChanged;
            wildcardFilterCheckBox.CheckedChanged += filterCheckBox_CheckedChanged;
        }

        private void OnRulesListUpdated()
        {
            if (this.InvokeRequired)
            {
                this.Invoke(OnRulesListUpdated);
                return;
            }
            _bindingSource.DataSource = _mainViewModel.VirtualRulesData;
            _bindingSource.ResetBindings(false);
            rulesDataGridView.Refresh();
        }

        public void ApplyThemeFixes()
        {
            if (_dm == null) return;
            createRuleButton.FlatAppearance.BorderSize = 1;
            createRuleButton.FlatAppearance.BorderColor = _dm.OScolors.ControlDark;
            if (_dm.IsDarkMode)
            {
                createRuleButton.ForeColor = Color.White;
            }
            else
            {
                createRuleButton.ForeColor = SystemColors.ControlText;
            }
        }

        public async Task RefreshDataAsync(bool forceUwpScan = false, IProgress<int>? progress = null, CancellationToken token = default)
        {
            await _mainViewModel.RefreshRulesDataAsync(token, progress);
            await DisplayRulesAsync();
        }

        public async Task OnTabSelectedAsync()
        {
            await DisplayRulesAsync();
        }

        public void UpdateIconColumnVisibility()
        {
            if (advIconColumn != null)
            {
                advIconColumn.Visible = _appSettings.ShowAppIcons;
            }
        }

        private async Task DisplayRulesAsync()
        {
            ApplyRulesFilters();
            await Task.CompletedTask;
        }

        private void filterCheckBox_CheckedChanged(object sender, EventArgs e)
        {
            _appSettings.FilterPrograms = programFilterCheckBox.Checked;
            _appSettings.FilterServices = serviceFilterCheckBox.Checked;
            _appSettings.FilterUwp = uwpFilterCheckBox.Checked;
            _appSettings.FilterWildcards = wildcardFilterCheckBox.Checked;
            _appSettings.FilterSystem = systemFilterCheckBox.Checked;
            ApplyRulesFilters();
        }

        private void ApplyRulesFilters()
        {
            var enabledTypes = new HashSet<RuleType>();
            if (programFilterCheckBox.Checked) enabledTypes.Add(RuleType.Program);
            if (serviceFilterCheckBox.Checked) enabledTypes.Add(RuleType.Service);
            if (uwpFilterCheckBox.Checked) enabledTypes.Add(RuleType.UWP);
            if (wildcardFilterCheckBox.Checked) enabledTypes.Add(RuleType.Wildcard);
            enabledTypes.Add(RuleType.Advanced);

            bool showSystemRules = systemFilterCheckBox.Checked;
            _mainViewModel.ApplyRulesFilters(rulesSearchTextBox.Text, enabledTypes, showSystemRules);
        }

        private void rulesDataGridView_CellMouseDown(object sender, DataGridViewCellMouseEventArgs e)
        {
            if (e.Button == MouseButtons.Right && e.RowIndex >= 0)
            {
                var grid = (DataGridView)sender;
                var clickedRow = grid.Rows[e.RowIndex];

                if (!clickedRow.Selected)
                {
                    grid.ClearSelection();
                    clickedRow.Selected = true;
                }
            }
        }

        private void ApplyRuleMenuItem_Click(object sender, EventArgs e)
        {
            if (sender is not ToolStripMenuItem menuItem || menuItem.Tag?.ToString() is not string action || rulesDataGridView.SelectedRows.Count == 0) return;
            var items = new List<AggregatedRuleViewModel>();
            foreach (DataGridViewRow row in rulesDataGridView.SelectedRows)
            {
                if (row.DataBoundItem is AggregatedRuleViewModel vm)
                {
                    items.Add(vm);
                }
            }

            if (items.Count > 0)
            {
                foreach (var item in items)
                {
                    _mainViewModel.ApplyRuleChange(item, action);
                }
            }
        }

        private async void editRuleToolStripMenuItem_Click(object sender, EventArgs e)
        {
            if (rulesDataGridView.SelectedRows.Count == 1 && rulesDataGridView.SelectedRows[0].DataBoundItem is AggregatedRuleViewModel aggRule)
            {
                var originalRule = aggRule.UnderlyingRules.FirstOrDefault();
                if (originalRule == null)
                {
                    DarkModeForms.Messenger.MessageBox("Cannot edit this rule as it has no underlying rule definition.", "Edit Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
                    return;
                }

                using var dialog = new CreateAdvancedRuleForm(_actionsService, originalRule, _appSettings);
                if (dialog.ShowDialog(this.FindForm()) == DialogResult.OK)
                {
                    if (dialog.RuleVm != null)
                    {
                        if (originalRule.HasSameSettings(dialog.RuleVm))
                        {
                            return;
                        }

                        var deletePayload = new DeleteRulesPayload { RuleIdentifiers = aggRule.UnderlyingRules.Select(r => r.Name).ToList() };
                        _backgroundTaskService.EnqueueTask(new FirewallTask(FirewallTaskType.DeleteAdvancedRules, deletePayload));

                        var createPayload = new CreateAdvancedRulePayload { ViewModel = dialog.RuleVm, InterfaceTypes = dialog.RuleVm.InterfaceTypes, IcmpTypesAndCodes = dialog.RuleVm.IcmpTypesAndCodes };
                        _backgroundTaskService.EnqueueTask(new FirewallTask(FirewallTaskType.CreateAdvancedRule, createPayload));

                        await Task.Delay(500);
                        DataRefreshRequested?.Invoke();
                    }
                }
            }
        }

        private void DeleteRuleMenuItem_Click(object sender, EventArgs e)
        {
            if (rulesDataGridView.SelectedRows.Count == 0) return;
            var items = new List<AggregatedRuleViewModel>();
            foreach (DataGridViewRow row in rulesDataGridView.SelectedRows)
            {
                if (row.DataBoundItem is AggregatedRuleViewModel vm)
                {
                    items.Add(vm);
                }
            }

            if (items.Count > 0)
            {
                var result = DarkModeForms.Messenger.MessageBox($"Are you sure you want to delete the {items.Count} selected rule(s)?", "Confirm Deletion", MessageBoxButtons.YesNo, MessageBoxIcon.Warning);
                if (result == DialogResult.No) return;

                _mainViewModel.DeleteRules(items);
                ApplyRulesFilters();
            }
        }

        private void CreateRuleButton_Click(object sender, EventArgs e)
        {
            using var dialog = new RuleWizardForm(_actionsService, _wildcardRuleService, _backgroundTaskService, _appSettings);
            if (dialog.ShowDialog(this.FindForm()) == DialogResult.OK)
            {
            }
        }

        private async void SearchTextBox_TextChanged(object sender, EventArgs e)
        {
            _appSettings.RulesSearchText = rulesSearchTextBox.Text;
            await DisplayRulesAsync();
        }

        private void rulesContextMenu_Opening(object sender, CancelEventArgs e)
        {
            if (rulesDataGridView.SelectedRows.Count == 0)
            {
                e.Cancel = true;
                return;
            }

            if (rulesDataGridView.SelectedRows[0].DataBoundItem is not AggregatedRuleViewModel rule)
            {
                e.Cancel = true;
                return;
            }

            string? appPath = rule.ApplicationName;
            openFileLocationToolStripMenuItem.Enabled = !string.IsNullOrEmpty(appPath) && File.Exists(appPath);

            var firstUnderlyingRule = rule.UnderlyingRules.FirstOrDefault();
            bool isEditableType = rule.Type == RuleType.Program || rule.Type == RuleType.Service ||
                                  rule.Type == RuleType.Advanced;
            bool hasTarget = firstUnderlyingRule != null &&
                             ((!string.IsNullOrEmpty(firstUnderlyingRule.ApplicationName) && firstUnderlyingRule.ApplicationName != "*") ||
                              !string.IsNullOrEmpty(firstUnderlyingRule.ServiceName));
            editRuleToolStripMenuItem.Enabled = rulesDataGridView.SelectedRows.Count == 1 && isEditableType && hasTarget;
        }


        private void openFileLocationToolStripMenuItem_Click(object sender, EventArgs e)
        {
            if (rulesDataGridView.SelectedRows.Count > 0 && rulesDataGridView.SelectedRows[0].DataBoundItem is AggregatedRuleViewModel rule)
            {
                string?
                appPath = rule.ApplicationName;

                if (!string.IsNullOrEmpty(appPath) && File.Exists(appPath))
                {
                    try
                    {
                        Process.Start("explorer.exe", $"/select, \"{appPath}\"");
                    }
                    catch (Exception ex) when (ex is Win32Exception or FileNotFoundException)
                    {
                        DarkModeForms.Messenger.MessageBox($"Could not open file location.\n\nError: {ex.Message}", "Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
                    }
                }
                else
                {
                    DarkModeForms.Messenger.MessageBox("The path for this item is not available or does not exist.", "Path Not Found", MessageBoxButtons.OK, MessageBoxIcon.Error);
                }
            }
        }

        private void copyDetailsToolStripMenuItem_Click(object sender, EventArgs e)
        {
            if (rulesDataGridView.SelectedRows.Count > 0)
            {
                var details = new System.Text.StringBuilder();

                foreach (DataGridViewRow row in rulesDataGridView.SelectedRows)
                {
                    if (row.DataBoundItem is AggregatedRuleViewModel rule)
                    {
                        if (details.Length > 0)
                        {
                            details.AppendLine();
                            details.AppendLine();
                        }

                        details.AppendLine($"Rule Name: {rule.Name}");
                        details.AppendLine($"Type: {rule.Type}");
                        details.AppendLine($"Inbound: {rule.InboundStatus}");
                        details.AppendLine($"Outbound: {rule.OutboundStatus}");
                        details.AppendLine($"Application: {rule.ApplicationName}");
                        details.AppendLine($"Service: {rule.ServiceName}");
                        details.AppendLine($"Protocol: {rule.ProtocolName}");
                        details.AppendLine($"Local Ports: {rule.LocalPorts}");
                        details.AppendLine($"Remote Ports: {rule.RemotePorts}");
                        details.AppendLine($"Local Addresses: {rule.LocalAddresses}");
                        details.AppendLine($"Remote Addresses: {rule.RemoteAddresses}");
                        details.AppendLine($"Profiles: {rule.Profiles}");
                        details.AppendLine($"Group: {rule.Grouping}");
                        details.AppendLine($"Description: {rule.Description}");
                    }
                }

                if (details.Length > 0)
                {
                    Clipboard.SetText(details.ToString());
                }
            }
        }

        private void rulesDataGridView_CellFormatting(object sender, DataGridViewCellFormattingEventArgs e)
        {
            if (e.RowIndex < 0) return;
            var grid = (DataGridView)sender;

            if (grid.Rows[e.RowIndex].DataBoundItem is not AggregatedRuleViewModel rule) return;
            if (grid.Columns[e.ColumnIndex].Name == "advIconColumn")
            {
                if (_appSettings.ShowAppIcons && !string.IsNullOrEmpty(rule.ApplicationName))
                {
                    int iconIndex = _iconService.GetIconIndex(rule.ApplicationName);
                    if (iconIndex != -1 && _iconService.ImageList != null)
                    {
                        e.Value = _iconService.ImageList.Images[iconIndex];
                    }
                }
                return;
            }

            bool hasAllow = rule.InboundStatus.Contains("Allow") || rule.OutboundStatus.Contains("Allow");
            bool hasBlock = rule.InboundStatus.Contains("Block") || rule.OutboundStatus.Contains("Block");

            if (hasAllow && hasBlock)
            {
                e.CellStyle.BackColor = Color.FromArgb(255, 255, 204);
            }
            else if (hasAllow)
            {
                e.CellStyle.BackColor = Color.FromArgb(204, 255, 204);
            }
            else if (hasBlock)
            {
                e.CellStyle.BackColor = Color.FromArgb(255, 204, 204);
            }

            if (hasAllow || hasBlock)
            {
                e.CellStyle.ForeColor = Color.Black;
            }

            if (grid.Rows[e.RowIndex].Selected)
            {
                e.CellStyle.SelectionBackColor = SystemColors.Highlight;
                e.CellStyle.SelectionForeColor = SystemColors.HighlightText;
            }
            else
            {
                e.CellStyle.SelectionBackColor = e.CellStyle.BackColor;
                e.CellStyle.SelectionForeColor = e.CellStyle.ForeColor;
            }
        }

        private void rulesDataGridView_ColumnHeaderMouseClick(object sender, DataGridViewCellMouseEventArgs e)
        {
            var column = rulesDataGridView.Columns[e.ColumnIndex];
            string propertyName = column.DataPropertyName;
            if (string.IsNullOrEmpty(propertyName)) return;

            var sortDirection = ListSortDirection.Ascending;
            if (rulesDataGridView.SortedColumn?.Name == column.Name && rulesDataGridView.SortOrder == SortOrder.Ascending)
            {
                sortDirection = ListSortDirection.Descending;
            }

            if (_bindingSource.DataSource is SortableBindingList<AggregatedRuleViewModel> list)
            {
                list.Sort(propertyName, sortDirection);
            }

            rulesDataGridView.Sort(column, sortDirection);

            _appSettings.RulesSortColumn = e.ColumnIndex;
            _appSettings.RulesSortOrder = (int)(sortDirection == ListSortDirection.Ascending ? SortOrder.Ascending : SortOrder.Descending);
        }

        private void rulesDataGridView_RowPostPaint(object sender, DataGridViewRowPostPaintEventArgs e)
        {
            var grid = (DataGridView)sender;
            var row = grid.Rows[e.RowIndex];

            if (row.Selected) return;
            var mouseOverRow = grid.HitTest(grid.PointToClient(MousePosition).X, grid.PointToClient(MousePosition).Y).RowIndex;
            if (e.RowIndex == mouseOverRow)
            {
                using var overlayBrush = new SolidBrush(Color.FromArgb(25, Color.Black));
                e.Graphics.FillRectangle(overlayBrush, e.RowBounds);
            }
        }

        private void rulesDataGridView_CellMouseEnter(object sender, DataGridViewCellEventArgs e)
        {
            if (e.RowIndex >= 0)
            {
                var grid = (DataGridView)sender;
                grid.InvalidateRow(e.RowIndex);
            }
        }

        private void rulesDataGridView_CellMouseLeave(object sender, DataGridViewCellEventArgs e)
        {
            if (e.RowIndex >= 0)
            {
                var grid = (DataGridView)sender;
                grid.InvalidateRow(e.RowIndex);
            }
        }
    }
}



--------------------------------------------------
// Full Path: C:/Users/anon/PROGRAMMING/C#/SimpleFirewall/VS Minimal Firewall/MinimalFirewall-NET8/Backups/v2.5.5 - ws/2.5.5.6 - security vulnerability fix 3/RulesControl.Designer.cs
--------------------------------------------------------------------------------
// File: RulesControl.Designer.cs
namespace MinimalFirewall
{
    partial class RulesControl
    {
        private System.ComponentModel.IContainer components = null;
        private System.Windows.Forms.Button createRuleButton;
        private System.Windows.Forms.TextBox rulesSearchTextBox;
        private System.Windows.Forms.ContextMenuStrip rulesContextMenu;
        private System.Windows.Forms.ToolStripMenuItem allowToolStripMenuItem;
        private System.Windows.Forms.ToolStripMenuItem allowOutboundToolStripMenuItem;
        private System.Windows.Forms.ToolStripMenuItem allowInboundToolStripMenuItem;
        private System.Windows.Forms.ToolStripMenuItem allowAllToolStripMenuItem;
        private System.Windows.Forms.ToolStripMenuItem blockToolStripMenuItem;
        private System.Windows.Forms.ToolStripMenuItem blockOutboundToolStripMenuItem;
        private System.Windows.Forms.ToolStripMenuItem blockInboundToolStripMenuItem;
        private System.Windows.Forms.ToolStripMenuItem blockAllToolStripMenuItem;
        private System.Windows.Forms.ToolStripSeparator toolStripSeparator1;
        private System.Windows.Forms.ToolStripMenuItem deleteRuleToolStripMenuItem;
        private System.Windows.Forms.ToolStripSeparator toolStripSeparator2;
        private System.Windows.Forms.ToolStripMenuItem openFileLocationToolStripMenuItem;
        private System.Windows.Forms.ToolStripSeparator toolStripSeparator3;
        private System.Windows.Forms.ToolStripMenuItem copyDetailsToolStripMenuItem;
        private System.Windows.Forms.DataGridView rulesDataGridView;
        private System.Windows.Forms.DataGridViewImageColumn advIconColumn;
        private System.Windows.Forms.DataGridViewTextBoxColumn advNameColumn;
        private System.Windows.Forms.DataGridViewTextBoxColumn inboundStatusColumn;
        private System.Windows.Forms.DataGridViewTextBoxColumn outboundStatusColumn;
        private System.Windows.Forms.DataGridViewTextBoxColumn advProtocolColumn;
        private System.Windows.Forms.DataGridViewTextBoxColumn advLocalPortsColumn;
        private System.Windows.Forms.DataGridViewTextBoxColumn advRemotePortsColumn;
        private System.Windows.Forms.DataGridViewTextBoxColumn advLocalAddressColumn;
        private System.Windows.Forms.DataGridViewTextBoxColumn advRemoteAddressColumn;
        private System.Windows.Forms.DataGridViewTextBoxColumn advProgramColumn;
        private System.Windows.Forms.DataGridViewTextBoxColumn advServiceColumn;
        private System.Windows.Forms.DataGridViewTextBoxColumn advProfilesColumn;
        private System.Windows.Forms.DataGridViewTextBoxColumn advGroupingColumn;
        private System.Windows.Forms.DataGridViewTextBoxColumn advDescColumn;
        private System.Windows.Forms.FlowLayoutPanel filterPanel;
        private System.Windows.Forms.CheckBox programFilterCheckBox;
        private System.Windows.Forms.CheckBox serviceFilterCheckBox;
        private System.Windows.Forms.CheckBox uwpFilterCheckBox;
        private System.Windows.Forms.CheckBox wildcardFilterCheckBox;
        private System.Windows.Forms.TableLayoutPanel topPanel;
        private System.Windows.Forms.ToolStripMenuItem editRuleToolStripMenuItem;
        private System.Windows.Forms.CheckBox systemFilterCheckBox;
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        private void InitializeComponent()
        {
            this.components = new System.ComponentModel.Container();
            System.Windows.Forms.DataGridViewCellStyle dataGridViewCellStyle1 = new System.Windows.Forms.DataGridViewCellStyle();
            this.rulesSearchTextBox = new System.Windows.Forms.TextBox();
            this.createRuleButton = new System.Windows.Forms.Button();
            this.rulesContextMenu = new System.Windows.Forms.ContextMenuStrip(this.components);
            this.allowToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.allowOutboundToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.allowInboundToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.allowAllToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.blockToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.blockOutboundToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.blockInboundToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.blockAllToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.toolStripSeparator1 = new System.Windows.Forms.ToolStripSeparator();
            this.editRuleToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.deleteRuleToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.toolStripSeparator2 = new System.Windows.Forms.ToolStripSeparator();
            this.openFileLocationToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.toolStripSeparator3 = new System.Windows.Forms.ToolStripSeparator();
            this.copyDetailsToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.rulesDataGridView = new System.Windows.Forms.DataGridView();
            this.advIconColumn = new System.Windows.Forms.DataGridViewImageColumn();
            this.advNameColumn = new System.Windows.Forms.DataGridViewTextBoxColumn();
            this.inboundStatusColumn = new System.Windows.Forms.DataGridViewTextBoxColumn();
            this.outboundStatusColumn = new System.Windows.Forms.DataGridViewTextBoxColumn();
            this.advProtocolColumn = new System.Windows.Forms.DataGridViewTextBoxColumn();
            this.advLocalPortsColumn = new System.Windows.Forms.DataGridViewTextBoxColumn();
            this.advRemotePortsColumn = new System.Windows.Forms.DataGridViewTextBoxColumn();
            this.advLocalAddressColumn = new System.Windows.Forms.DataGridViewTextBoxColumn();
            this.advRemoteAddressColumn = new System.Windows.Forms.DataGridViewTextBoxColumn();
            this.advProgramColumn = new System.Windows.Forms.DataGridViewTextBoxColumn();
            this.advServiceColumn = new System.Windows.Forms.DataGridViewTextBoxColumn();
            this.advProfilesColumn = new System.Windows.Forms.DataGridViewTextBoxColumn();
            this.advGroupingColumn = new System.Windows.Forms.DataGridViewTextBoxColumn();
            this.advDescColumn = new System.Windows.Forms.DataGridViewTextBoxColumn();
            this.filterPanel = new System.Windows.Forms.FlowLayoutPanel();
            this.programFilterCheckBox = new System.Windows.Forms.CheckBox();
            this.serviceFilterCheckBox = new System.Windows.Forms.CheckBox();
            this.uwpFilterCheckBox = new System.Windows.Forms.CheckBox();
            this.wildcardFilterCheckBox = new System.Windows.Forms.CheckBox();
            this.systemFilterCheckBox = new System.Windows.Forms.CheckBox();
            this.topPanel = new System.Windows.Forms.TableLayoutPanel();
            this.rulesContextMenu.SuspendLayout();
            ((System.ComponentModel.ISupportInitialize)(this.rulesDataGridView)).BeginInit();
            this.filterPanel.SuspendLayout();
            this.topPanel.SuspendLayout();
            this.SuspendLayout();
            // 
            // rulesSearchTextBox
            // 
            this.rulesSearchTextBox.Anchor = System.Windows.Forms.AnchorStyles.Right;
            this.rulesSearchTextBox.Location = new System.Drawing.Point(714, 18);
            this.rulesSearchTextBox.Margin = new System.Windows.Forms.Padding(3, 4, 3, 4);
            this.rulesSearchTextBox.Name = "rulesSearchTextBox";
            this.rulesSearchTextBox.PlaceholderText = "Search rules...";
            this.rulesSearchTextBox.Size = new System.Drawing.Size(285, 27);
            this.rulesSearchTextBox.TabIndex = 16;
            this.rulesSearchTextBox.TextChanged += new System.EventHandler(this.SearchTextBox_TextChanged);
            // 
            // createRuleButton
            // 
            this.createRuleButton.Anchor = System.Windows.Forms.AnchorStyles.Left;
            this.createRuleButton.Location = new System.Drawing.Point(3, 7);
            this.createRuleButton.Margin = new System.Windows.Forms.Padding(3, 4, 3, 4);
            this.createRuleButton.Name = "createRuleButton";
            this.createRuleButton.Size = new System.Drawing.Size(180, 48);
            this.createRuleButton.TabIndex = 9;
            this.createRuleButton.Text = "Create New Rule...";
            this.createRuleButton.UseVisualStyleBackColor = true;
            this.createRuleButton.Click += new System.EventHandler(this.CreateRuleButton_Click);
            // 
            // rulesContextMenu
            // 
            this.rulesContextMenu.ImageScalingSize = new System.Drawing.Size(20, 20);
            this.rulesContextMenu.Items.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.allowToolStripMenuItem,
            this.blockToolStripMenuItem,
            this.toolStripSeparator1,
            this.editRuleToolStripMenuItem,
            this.deleteRuleToolStripMenuItem,
            this.toolStripSeparator2,
            this.openFileLocationToolStripMenuItem,
            this.toolStripSeparator3,
            this.copyDetailsToolStripMenuItem});
            this.rulesContextMenu.Name = "rulesContextMenu";
            this.rulesContextMenu.Size = new System.Drawing.Size(207, 194);
            this.rulesContextMenu.Opening += new System.ComponentModel.CancelEventHandler(this.rulesContextMenu_Opening);
            // 
            // allowToolStripMenuItem
            // 
            this.allowToolStripMenuItem.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.allowOutboundToolStripMenuItem,
            this.allowInboundToolStripMenuItem,
            this.allowAllToolStripMenuItem});
            this.allowToolStripMenuItem.Name = "allowToolStripMenuItem";
            this.allowToolStripMenuItem.Size = new System.Drawing.Size(206, 24);
            this.allowToolStripMenuItem.Text = "Allow";
            // 
            // allowOutboundToolStripMenuItem
            // 
            this.allowOutboundToolStripMenuItem.Name = "allowOutboundToolStripMenuItem";
            this.allowOutboundToolStripMenuItem.Size = new System.Drawing.Size(159, 26);
            this.allowOutboundToolStripMenuItem.Tag = "Allow (Outbound)";
            this.allowOutboundToolStripMenuItem.Text = "Outbound";
            this.allowOutboundToolStripMenuItem.Click += new System.EventHandler(this.ApplyRuleMenuItem_Click);
            // 
            // allowInboundToolStripMenuItem
            // 
            this.allowInboundToolStripMenuItem.Name = "allowInboundToolStripMenuItem";
            this.allowInboundToolStripMenuItem.Size = new System.Drawing.Size(159, 26);
            this.allowInboundToolStripMenuItem.Tag = "Allow (Inbound)";
            this.allowInboundToolStripMenuItem.Text = "Inbound";
            this.allowInboundToolStripMenuItem.Click += new System.EventHandler(this.ApplyRuleMenuItem_Click);
            // 
            // allowAllToolStripMenuItem
            // 
            this.allowAllToolStripMenuItem.Name = "allowAllToolStripMenuItem";
            this.allowAllToolStripMenuItem.Size = new System.Drawing.Size(159, 26);
            this.allowAllToolStripMenuItem.Tag = "Allow (All)";
            this.allowAllToolStripMenuItem.Text = "All";
            this.allowAllToolStripMenuItem.Click += new System.EventHandler(this.ApplyRuleMenuItem_Click);
            // 
            // blockToolStripMenuItem
            // 
            this.blockToolStripMenuItem.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.blockOutboundToolStripMenuItem,
            this.blockInboundToolStripMenuItem,
            this.blockAllToolStripMenuItem});
            this.blockToolStripMenuItem.Name = "blockToolStripMenuItem";
            this.blockToolStripMenuItem.Size = new System.Drawing.Size(206, 24);
            this.blockToolStripMenuItem.Text = "Block";
            // 
            // blockOutboundToolStripMenuItem
            // 
            this.blockOutboundToolStripMenuItem.Name = "blockOutboundToolStripMenuItem";
            this.blockOutboundToolStripMenuItem.Size = new System.Drawing.Size(159, 26);
            this.blockOutboundToolStripMenuItem.Tag = "Block (Outbound)";
            this.blockOutboundToolStripMenuItem.Text = "Outbound";
            this.blockOutboundToolStripMenuItem.Click += new System.EventHandler(this.ApplyRuleMenuItem_Click);
            // 
            // blockInboundToolStripMenuItem
            // 
            this.blockInboundToolStripMenuItem.Name = "blockInboundToolStripMenuItem";
            this.blockInboundToolStripMenuItem.Size = new System.Drawing.Size(159, 26);
            this.blockInboundToolStripMenuItem.Tag = "Block (Inbound)";
            this.blockInboundToolStripMenuItem.Text = "Inbound";
            this.blockInboundToolStripMenuItem.Click += new System.EventHandler(this.ApplyRuleMenuItem_Click);
            // 
            // blockAllToolStripMenuItem
            // 
            this.blockAllToolStripMenuItem.Name = "blockAllToolStripMenuItem";
            this.blockAllToolStripMenuItem.Size = new System.Drawing.Size(159, 26);
            this.blockAllToolStripMenuItem.Tag = "Block (All)";
            this.blockAllToolStripMenuItem.Text = "All";
            this.blockAllToolStripMenuItem.Click += new System.EventHandler(this.ApplyRuleMenuItem_Click);
            // 
            // toolStripSeparator1
            // 
            this.toolStripSeparator1.Name = "toolStripSeparator1";
            this.toolStripSeparator1.Size = new System.Drawing.Size(203, 6);
            // 
            // editRuleToolStripMenuItem
            // 
            this.editRuleToolStripMenuItem.Name = "editRuleToolStripMenuItem";
            this.editRuleToolStripMenuItem.Size = new System.Drawing.Size(206, 24);
            this.editRuleToolStripMenuItem.Text = "Edit Rule...";
            this.editRuleToolStripMenuItem.Click += new System.EventHandler(this.editRuleToolStripMenuItem_Click);
            // 
            // deleteRuleToolStripMenuItem
            // 
            this.deleteRuleToolStripMenuItem.Name = "deleteRuleToolStripMenuItem";
            this.deleteRuleToolStripMenuItem.Size = new System.Drawing.Size(206, 24);
            this.deleteRuleToolStripMenuItem.Text = "Delete Rule(s)";
            this.deleteRuleToolStripMenuItem.Click += new System.EventHandler(this.DeleteRuleMenuItem_Click);
            // 
            // toolStripSeparator2
            // 
            this.toolStripSeparator2.Name = "toolStripSeparator2";
            this.toolStripSeparator2.Size = new System.Drawing.Size(203, 6);
            // 
            // openFileLocationToolStripMenuItem
            // 
            this.openFileLocationToolStripMenuItem.Name = "openFileLocationToolStripMenuItem";
            this.openFileLocationToolStripMenuItem.Size = new System.Drawing.Size(206, 24);
            this.openFileLocationToolStripMenuItem.Text = "Open File Location";
            this.openFileLocationToolStripMenuItem.Click += new System.EventHandler(this.openFileLocationToolStripMenuItem_Click);
            // 
            // toolStripSeparator3
            // 
            this.toolStripSeparator3.Name = "toolStripSeparator3";
            this.toolStripSeparator3.Size = new System.Drawing.Size(203, 6);
            // 
            // copyDetailsToolStripMenuItem
            // 
            this.copyDetailsToolStripMenuItem.Name = "copyDetailsToolStripMenuItem";
            this.copyDetailsToolStripMenuItem.Size = new System.Drawing.Size(206, 24);
            this.copyDetailsToolStripMenuItem.Text = "Copy Details";
            this.copyDetailsToolStripMenuItem.Click += new System.EventHandler(this.copyDetailsToolStripMenuItem_Click);
            // 
            // rulesDataGridView
            // 
            this.rulesDataGridView.AllowUserToAddRows = false;
            this.rulesDataGridView.AllowUserToDeleteRows = false;
            this.rulesDataGridView.AllowUserToResizeRows = false;
            this.rulesDataGridView.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
            | System.Windows.Forms.AnchorStyles.Left)
            | System.Windows.Forms.AnchorStyles.Right)));
            this.rulesDataGridView.AutoSizeColumnsMode = System.Windows.Forms.DataGridViewAutoSizeColumnsMode.Fill;
            this.rulesDataGridView.BackgroundColor = System.Drawing.SystemColors.Control;
            this.rulesDataGridView.BorderStyle = System.Windows.Forms.BorderStyle.None;
            this.rulesDataGridView.CellBorderStyle = System.Windows.Forms.DataGridViewCellBorderStyle.None;
            this.rulesDataGridView.ColumnHeadersBorderStyle = System.Windows.Forms.DataGridViewHeaderBorderStyle.None;
            dataGridViewCellStyle1.Alignment = System.Windows.Forms.DataGridViewContentAlignment.MiddleLeft;
            dataGridViewCellStyle1.BackColor = System.Drawing.SystemColors.Control;
            dataGridViewCellStyle1.Font = new System.Drawing.Font("Segoe UI", 9F);
            dataGridViewCellStyle1.ForeColor = System.Drawing.SystemColors.WindowText;
            dataGridViewCellStyle1.SelectionBackColor = System.Drawing.SystemColors.Highlight;
            dataGridViewCellStyle1.SelectionForeColor = System.Drawing.SystemColors.HighlightText;
            dataGridViewCellStyle1.WrapMode = System.Windows.Forms.DataGridViewTriState.True;
            this.rulesDataGridView.ColumnHeadersDefaultCellStyle = dataGridViewCellStyle1;
            this.rulesDataGridView.ColumnHeadersHeightSizeMode = System.Windows.Forms.DataGridViewColumnHeadersHeightSizeMode.AutoSize;
            this.rulesDataGridView.Columns.AddRange(new System.Windows.Forms.DataGridViewColumn[] {
            this.advIconColumn,
            this.advNameColumn,
            this.inboundStatusColumn,
            this.outboundStatusColumn,
            this.advProtocolColumn,
            this.advLocalPortsColumn,
            this.advRemotePortsColumn,
            this.advLocalAddressColumn,
            this.advRemoteAddressColumn,
            this.advProgramColumn,
            this.advServiceColumn,
            this.advProfilesColumn,
            this.advGroupingColumn,
            this.advDescColumn});
            this.rulesDataGridView.ContextMenuStrip = this.rulesContextMenu;
            this.rulesDataGridView.EnableHeadersVisualStyles = false;
            this.rulesDataGridView.GridColor = System.Drawing.SystemColors.Control;
            this.rulesDataGridView.Location = new System.Drawing.Point(3, 69);
            this.rulesDataGridView.Name = "rulesDataGridView";
            this.rulesDataGridView.ReadOnly = true;
            this.rulesDataGridView.RowHeadersVisible = false;
            this.rulesDataGridView.RowTemplate.Height = 28;
            this.rulesDataGridView.SelectionMode = System.Windows.Forms.DataGridViewSelectionMode.FullRowSelect;
            this.rulesDataGridView.ShowCellToolTips = true;
            this.rulesDataGridView.Size = new System.Drawing.Size(996, 839);
            this.rulesDataGridView.TabIndex = 18;
            this.rulesDataGridView.CellFormatting += new System.Windows.Forms.DataGridViewCellFormattingEventHandler(this.rulesDataGridView_CellFormatting);
            this.rulesDataGridView.CellMouseDown += new System.Windows.Forms.DataGridViewCellMouseEventHandler(this.rulesDataGridView_CellMouseDown);
            this.rulesDataGridView.CellMouseEnter += new System.Windows.Forms.DataGridViewCellEventHandler(this.rulesDataGridView_CellMouseEnter);
            this.rulesDataGridView.CellMouseLeave += new System.Windows.Forms.DataGridViewCellEventHandler(this.rulesDataGridView_CellMouseLeave);
            this.rulesDataGridView.ColumnHeaderMouseClick += new System.Windows.Forms.DataGridViewCellMouseEventHandler(this.rulesDataGridView_ColumnHeaderMouseClick);
            this.rulesDataGridView.RowPostPaint += new System.Windows.Forms.DataGridViewRowPostPaintEventHandler(this.rulesDataGridView_RowPostPaint);
            // 
            // advIconColumn
            // 
            this.advIconColumn.AutoSizeMode = System.Windows.Forms.DataGridViewAutoSizeColumnMode.None;
            this.advIconColumn.FillWeight = 3F;
            this.advIconColumn.HeaderText = "";
            this.advIconColumn.ImageLayout = System.Windows.Forms.DataGridViewImageCellLayout.Zoom;
            this.advIconColumn.MinimumWidth = 32;
            this.advIconColumn.Name = "advIconColumn";
            this.advIconColumn.ReadOnly = true;
            this.advIconColumn.Resizable = System.Windows.Forms.DataGridViewTriState.False;
            this.advIconColumn.Width = 32;
            // 
            // advNameColumn
            // 
            this.advNameColumn.DataPropertyName = "Name";
            this.advNameColumn.FillWeight = 20F;
            this.advNameColumn.HeaderText = "Name";
            this.advNameColumn.Name = "advNameColumn";
            this.advNameColumn.ReadOnly = true;
            // 
            // inboundStatusColumn
            // 
            this.inboundStatusColumn.DataPropertyName = "InboundStatus";
            this.inboundStatusColumn.FillWeight = 10F;
            this.inboundStatusColumn.HeaderText = "Inbound";
            this.inboundStatusColumn.Name = "inboundStatusColumn";
            this.inboundStatusColumn.ReadOnly = true;
            // 
            // outboundStatusColumn
            // 
            this.outboundStatusColumn.DataPropertyName = "OutboundStatus";
            this.outboundStatusColumn.FillWeight = 10F;
            this.outboundStatusColumn.HeaderText = "Outbound";
            this.outboundStatusColumn.Name = "outboundStatusColumn";
            this.outboundStatusColumn.ReadOnly = true;
            // 
            // advProtocolColumn
            // 
            this.advProtocolColumn.DataPropertyName = "ProtocolName";
            this.advProtocolColumn.FillWeight = 8F;
            this.advProtocolColumn.HeaderText = "Protocol";
            this.advProtocolColumn.Name = "advProtocolColumn";
            this.advProtocolColumn.ReadOnly = true;
            // 
            // advLocalPortsColumn
            // 
            this.advLocalPortsColumn.DataPropertyName = "LocalPorts";
            this.advLocalPortsColumn.FillWeight = 12F;
            this.advLocalPortsColumn.HeaderText = "Local Ports";
            this.advLocalPortsColumn.Name = "advLocalPortsColumn";
            this.advLocalPortsColumn.ReadOnly = true;
            // 
            // advRemotePortsColumn
            // 
            this.advRemotePortsColumn.DataPropertyName = "RemotePorts";
            this.advRemotePortsColumn.FillWeight = 12F;
            this.advRemotePortsColumn.HeaderText = "Remote Ports";
            this.advRemotePortsColumn.Name = "advRemotePortsColumn";
            this.advRemotePortsColumn.ReadOnly = true;
            // 
            // advLocalAddressColumn
            // 
            this.advLocalAddressColumn.DataPropertyName = "LocalAddresses";
            this.advLocalAddressColumn.FillWeight = 15F;
            this.advLocalAddressColumn.HeaderText = "Local Address";
            this.advLocalAddressColumn.Name = "advLocalAddressColumn";
            this.advLocalAddressColumn.ReadOnly = true;
            // 
            // advRemoteAddressColumn
            // 
            this.advRemoteAddressColumn.DataPropertyName = "RemoteAddresses";
            this.advRemoteAddressColumn.FillWeight = 15F;
            this.advRemoteAddressColumn.HeaderText = "Remote Address";
            this.advRemoteAddressColumn.Name = "advRemoteAddressColumn";
            this.advRemoteAddressColumn.ReadOnly = true;
            // 
            // advProgramColumn
            // 
            this.advProgramColumn.DataPropertyName = "ApplicationName";
            this.advProgramColumn.FillWeight = 25F;
            this.advProgramColumn.HeaderText = "Program";
            this.advProgramColumn.Name = "advProgramColumn";
            this.advProgramColumn.ReadOnly = true;
            // 
            // advServiceColumn
            // 
            this.advServiceColumn.DataPropertyName = "ServiceName";
            this.advServiceColumn.FillWeight = 15F;
            this.advServiceColumn.HeaderText = "Service";
            this.advServiceColumn.Name = "advServiceColumn";
            this.advServiceColumn.ReadOnly = true;
            // 
            // advProfilesColumn
            // 
            this.advProfilesColumn.DataPropertyName = "Profiles";
            this.advProfilesColumn.FillWeight = 10F;
            this.advProfilesColumn.HeaderText = "Profiles";
            this.advProfilesColumn.Name = "advProfilesColumn";
            this.advProfilesColumn.ReadOnly = true;
            // 
            // advGroupingColumn
            // 
            this.advGroupingColumn.DataPropertyName = "Grouping";
            this.advGroupingColumn.FillWeight = 15F;
            this.advGroupingColumn.HeaderText = "Group";
            this.advGroupingColumn.Name = "advGroupingColumn";
            this.advGroupingColumn.ReadOnly = true;
            // 
            // advDescColumn
            // 
            this.advDescColumn.DataPropertyName = "Description";
            this.advDescColumn.FillWeight = 30F;
            this.advDescColumn.HeaderText = "Description";
            this.advDescColumn.Name = "advDescColumn";
            this.advDescColumn.ReadOnly = true;
            // 
            // filterPanel
            // 
            this.filterPanel.Anchor = System.Windows.Forms.AnchorStyles.Left;
            this.filterPanel.AutoSize = true;
            this.filterPanel.Controls.Add(this.programFilterCheckBox);
            this.filterPanel.Controls.Add(this.serviceFilterCheckBox);
            this.filterPanel.Controls.Add(this.uwpFilterCheckBox);
            this.filterPanel.Controls.Add(this.wildcardFilterCheckBox);
            this.filterPanel.Controls.Add(this.systemFilterCheckBox);
            this.filterPanel.Location = new System.Drawing.Point(189, 15);
            this.filterPanel.Name = "filterPanel";
            this.filterPanel.Size = new System.Drawing.Size(421, 32);
            this.filterPanel.TabIndex = 19;
            this.filterPanel.WrapContents = false;
            // 
            // programFilterCheckBox
            // 
            this.programFilterCheckBox.AutoSize = true;
            this.programFilterCheckBox.Checked = true;
            this.programFilterCheckBox.CheckState = System.Windows.Forms.CheckState.Checked;
            this.programFilterCheckBox.Location = new System.Drawing.Point(3, 3);
            this.programFilterCheckBox.Name = "programFilterCheckBox";
            this.programFilterCheckBox.Size = new System.Drawing.Size(91, 24);
            this.programFilterCheckBox.TabIndex = 0;
            this.programFilterCheckBox.Text = "Program";
            this.programFilterCheckBox.UseVisualStyleBackColor = true;
            // 
            // serviceFilterCheckBox
            // 
            this.serviceFilterCheckBox.AutoSize = true;
            this.serviceFilterCheckBox.Checked = true;
            this.serviceFilterCheckBox.CheckState = System.Windows.Forms.CheckState.Checked;
            this.serviceFilterCheckBox.Location = new System.Drawing.Point(100, 3);
            this.serviceFilterCheckBox.Name = "serviceFilterCheckBox";
            this.serviceFilterCheckBox.Size = new System.Drawing.Size(78, 24);
            this.serviceFilterCheckBox.TabIndex = 1;
            this.serviceFilterCheckBox.Text = "Service";
            this.serviceFilterCheckBox.UseVisualStyleBackColor = true;
            // 
            // uwpFilterCheckBox
            // 
            this.uwpFilterCheckBox.AutoSize = true;
            this.uwpFilterCheckBox.Checked = true;
            this.uwpFilterCheckBox.CheckState = System.Windows.Forms.CheckState.Checked;
            this.uwpFilterCheckBox.Location = new System.Drawing.Point(184, 3);
            this.uwpFilterCheckBox.Name = "uwpFilterCheckBox";
            this.uwpFilterCheckBox.Size = new System.Drawing.Size(64, 24);
            this.uwpFilterCheckBox.TabIndex = 2;
            this.uwpFilterCheckBox.Text = "UWP";
            this.uwpFilterCheckBox.UseVisualStyleBackColor = true;
            // 
            // wildcardFilterCheckBox
            // 
            this.wildcardFilterCheckBox.AutoSize = true;
            this.wildcardFilterCheckBox.Checked = true;
            this.wildcardFilterCheckBox.CheckState = System.Windows.Forms.CheckState.Checked;
            this.wildcardFilterCheckBox.Location = new System.Drawing.Point(254, 3);
            this.wildcardFilterCheckBox.Name = "wildcardFilterCheckBox";
            this.wildcardFilterCheckBox.Size = new System.Drawing.Size(88, 24);
            this.wildcardFilterCheckBox.TabIndex = 3;
            this.wildcardFilterCheckBox.Text = "Wildcard";
            this.wildcardFilterCheckBox.UseVisualStyleBackColor = true;
            // 
            // systemFilterCheckBox
            // 
            this.systemFilterCheckBox.AutoSize = true;
            this.systemFilterCheckBox.Location = new System.Drawing.Point(348, 3);
            this.systemFilterCheckBox.Name = "systemFilterCheckBox";
            this.systemFilterCheckBox.Size = new System.Drawing.Size(79, 24);
            this.systemFilterCheckBox.TabIndex = 5;
            this.systemFilterCheckBox.Text = "System";
            this.systemFilterCheckBox.UseVisualStyleBackColor = true;
            this.systemFilterCheckBox.CheckedChanged += new System.EventHandler(this.filterCheckBox_CheckedChanged);
            // 
            // topPanel
            // 
            this.topPanel.ColumnCount = 3;
            this.topPanel.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle());
            this.topPanel.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle(System.Windows.Forms.SizeType.Percent, 100F));
            this.topPanel.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle());
            this.topPanel.Controls.Add(this.createRuleButton, 0, 0);
            this.topPanel.Controls.Add(this.rulesSearchTextBox, 2, 0);
            this.topPanel.Controls.Add(this.filterPanel, 1, 0);
            this.topPanel.Dock = System.Windows.Forms.DockStyle.Top;
            this.topPanel.Location = new System.Drawing.Point(0, 0);
            this.topPanel.Name = "topPanel";
            this.topPanel.RowCount = 1;
            this.topPanel.RowStyles.Add(new System.Windows.Forms.RowStyle(System.Windows.Forms.SizeType.Percent, 100F));
            this.topPanel.Size = new System.Drawing.Size(1002, 63);
            this.topPanel.TabIndex = 20;
            // 
            // RulesControl
            // 
            this.Controls.Add(this.topPanel);
            this.Controls.Add(this.rulesDataGridView);
            this.Name = "RulesControl";
            this.Size = new System.Drawing.Size(1002, 911);
            this.rulesContextMenu.ResumeLayout(false);
            ((System.ComponentModel.ISupportInitialize)(this.rulesDataGridView)).EndInit();
            this.filterPanel.ResumeLayout(false);
            this.filterPanel.PerformLayout();
            this.topPanel.ResumeLayout(false);
            this.topPanel.PerformLayout();
            this.ResumeLayout(false);
        }
    }
}


--------------------------------------------------
// Full Path: C:/Users/anon/PROGRAMMING/C#/SimpleFirewall/VS Minimal Firewall/MinimalFirewall-NET8/Backups/v2.5.5 - ws/2.5.5.6 - security vulnerability fix 3/RuleWizardForm.cs
--------------------------------------------------------------------------------
using DarkModeForms;
using MinimalFirewall.TypedObjects;
using System.IO;
using NetFwTypeLib;
using System.Net;

namespace MinimalFirewall
{
    public partial class RuleWizardForm : Form
    {
        private enum WizardStep { Selection, GetAction, GetProgram, GetDirection, GetPorts, GetProtocol, GetName, Summary, GetService, GetFileShareIP, GetBlockDeviceIP, GetRestrictApp, GetFolder }
        private enum RuleTemplate { None, ProgramRule, PortRule, BlockService, AllowFileShare, BlockDevice, RestrictApp, BatchProgramRule }

        private WizardStep _currentStep = WizardStep.Selection;
        private RuleTemplate _selectedTemplate = RuleTemplate.None;
        private readonly Stack<WizardStep> _history = new Stack<WizardStep>();

        private readonly FirewallActionsService _actionsService;
        private readonly WildcardRuleService _wildcardRuleService;
        private readonly BackgroundFirewallTaskService _backgroundTaskService;
        private readonly DarkModeCS dm;
        private readonly AppSettings _appSettings;

        private string _wizardAppPath = "";
        private string _wizardFolderPath = "";
        private string _wizardPorts = "";
        private int _wizardProtocol = 0;
        private string _wizardRuleName = "";
        private Actions _wizardAction = Actions.Allow;
        private Directions _wizardDirection = Directions.Outgoing;
        private string _wizardServiceName = "";
        private string _wizardRemoteIP = "";
        public RuleWizardForm(FirewallActionsService actionsService, WildcardRuleService wildcardRuleService, BackgroundFirewallTaskService backgroundTaskService, AppSettings appSettings)
        {
            InitializeComponent();
            dm = new DarkModeCS(this);
            dm.ColorMode = appSettings.Theme == "Dark" ? DarkModeCS.DisplayMode.DarkMode : DarkModeCS.DisplayMode.ClearMode;
            dm.ApplyTheme(appSettings.Theme == "Dark");

            _actionsService = actionsService;
            _wildcardRuleService = wildcardRuleService;
            _backgroundTaskService = backgroundTaskService;
            _appSettings = appSettings;

            GoToStep(WizardStep.Selection);
        }

        private void GoForwardTo(WizardStep newStep)
        {
            _history.Push(_currentStep);
            GoToStep(newStep);
        }

        private void GoBack()
        {
            if (_history.Count > 0)
            {
                var previousStep = _history.Pop();
                GoToStep(previousStep);
            }
        }

        private void GoToStep(WizardStep newStep)
        {
            _currentStep = newStep;
            pnlSelection.Visible = _currentStep == WizardStep.Selection;
            pnlGetAction.Visible = _currentStep == WizardStep.GetAction;
            pnlGetProgram.Visible = _currentStep == WizardStep.GetProgram;
            pnlGetFolder.Visible = _currentStep == WizardStep.GetFolder;
            pnlGetDirection.Visible = _currentStep == WizardStep.GetDirection;
            pnlGetPorts.Visible = _currentStep == WizardStep.GetPorts;
            pnlGetProtocol.Visible = _currentStep == WizardStep.GetProtocol;
            pnlGetName.Visible = _currentStep == WizardStep.GetName;
            pnlSummary.Visible = _currentStep == WizardStep.Summary;
            pnlGetService.Visible = _currentStep == WizardStep.GetService;
            pnlGetFileShareIP.Visible = _currentStep == WizardStep.GetFileShareIP;
            pnlGetBlockDeviceIP.Visible = _currentStep == WizardStep.GetBlockDeviceIP;
            pnlGetRestrictApp.Visible = _currentStep == WizardStep.GetRestrictApp;
            backButton.Enabled = _history.Count > 0;
            nextButton.Text = "Next";

            switch (_currentStep)
            {
                case WizardStep.Selection:
                    this.Text = "Create New Rule";
                    mainHeaderLabel.Text = "What would you like to do?";
                    backButton.Enabled = false;
                    nextButton.Visible = false;
                    break;
                case WizardStep.GetFolder:
                    this.Text = "Step 1: Select a Folder";
                    mainHeaderLabel.Text = "Select a folder to apply rules to all programs within it";
                    nextButton.Visible = true;
                    break;
                case WizardStep.GetAction:
                    this.Text = "Step 1: Choose Action";
                    if (_selectedTemplate == RuleTemplate.BatchProgramRule)
                    {
                        this.Text = "Step 2: Choose Action";
                    }
                    mainHeaderLabel.Text = "Do you want to allow or block the program(s)?";
                    nextButton.Visible = true;
                    break;
                case WizardStep.GetProgram:
                    this.Text = "Step 2: Select a Program";
                    mainHeaderLabel.Text = "Select the program's main executable file (.exe)";
                    nextButton.Visible = true;
                    break;
                case WizardStep.GetDirection:
                    this.Text = "Step 3: Choose Direction";
                    mainHeaderLabel.Text = "Apply this rule to which connection direction?";
                    nextButton.Text = "Finish";
                    break;
                case WizardStep.GetPorts:
                    this.Text = "Step 1: Enter Ports";
                    mainHeaderLabel.Text = "What port or port range is needed?";
                    nextButton.Visible = true;
                    break;
                case WizardStep.GetProtocol:
                    this.Text = "Step 2: Select Protocol";
                    mainHeaderLabel.Text = "What protocol does it use?";
                    break;
                case WizardStep.GetName:
                    this.Text = "Step 3: Name Your Rule";
                    mainHeaderLabel.Text = "Give your new rule a descriptive name.";
                    nextButton.Text = "Finish";
                    break;
                case WizardStep.GetService:
                    this.Text = "Step 1: Select a Service";
                    mainHeaderLabel.Text = "Select a Windows Service to block";
                    nextButton.Visible = true;
                    if (serviceListBox.Items.Count == 0)
                    {
                        var services = SystemDiscoveryService.GetServicesWithExePaths();
                        foreach (var service in services.OrderBy(s => s.DisplayName))
                        {
                            serviceListBox.Items.Add($"{service.DisplayName} ({service.ServiceName})");
                        }
                    }
                    break;
                case WizardStep.GetFileShareIP:
                    this.Text = "Step 1: Enter IP Address";
                    mainHeaderLabel.Text = "Enter the local IP of the trusted computer";
                    nextButton.Visible = true;
                    nextButton.Text = "Finish";
                    break;
                case WizardStep.GetBlockDeviceIP:
                    this.Text = "Step 1: Enter IP Address";
                    mainHeaderLabel.Text = "Enter the local IP of the device to block";
                    nextButton.Visible = true;
                    nextButton.Text = "Finish";
                    break;
                case WizardStep.GetRestrictApp:
                    this.Text = "Step 1: Select a Program";
                    mainHeaderLabel.Text = "Select the program to restrict to your local network";
                    nextButton.Visible = true;
                    nextButton.Text = "Finish";
                    break;
                case WizardStep.Summary:
                    this.Text = "Summary";
                    mainHeaderLabel.Text = "The following rule will be created:";
                    BuildSummary();
                    nextButton.Text = "Finish";
                    break;
            }
        }

        private void nextButton_Click(object sender, EventArgs e)
        {
            if (!ValidateStep()) return;
            ProcessStepLogic();
        }

        private void backButton_Click(object sender, EventArgs e)
        {
            GoBack();
        }

        private void cancelButton_Click(object sender, EventArgs e)
        {
            this.DialogResult = DialogResult.Cancel;
            this.Close();
        }

        private void programRuleButton_Click(object sender, EventArgs e)
        {
            _selectedTemplate = RuleTemplate.ProgramRule;
            GoForwardTo(WizardStep.GetAction);
        }

        private void batchProgramRuleButton_Click(object sender, EventArgs e)
        {
            _selectedTemplate = RuleTemplate.BatchProgramRule;
            GoForwardTo(WizardStep.GetFolder);
        }

        private void portRuleButton_Click(object sender, EventArgs e)
        {
            _selectedTemplate = RuleTemplate.PortRule;
            GoForwardTo(WizardStep.GetPorts);
        }

        private void browseButton_Click(object sender, EventArgs e)
        {
            using var openFileDialog = new OpenFileDialog
            {
                Filter = "Executables (*.exe)|*.exe|All files (*.*)|*.*",
                Title = "Select a program"
            };
            if (openFileDialog.ShowDialog() == DialogResult.OK)
            {
                programPathTextBox.Text = openFileDialog.FileName;
            }
        }

        private void batchBrowseFolderButton_Click(object sender, EventArgs e)
        {
            using (var dialog = new FolderBrowserDialog())
            {
                if (dialog.ShowDialog() == DialogResult.OK)
                {
                    batchFolderPathTextBox.Text = dialog.SelectedPath;
                }
            }
        }

        private void portsBrowseButton_Click(object sender, EventArgs e)
        {
            using var openFileDialog = new OpenFileDialog
            {
                Filter = "Executables (*.exe)|*.exe|All files (*.*)|*.*",
                Title = "Select a program"
            };
            if (openFileDialog.ShowDialog() == DialogResult.OK)
            {
                portsProgramPathTextBox.Text = openFileDialog.FileName;
            }
        }

        private void restrictAppBrowseButton_Click(object sender, EventArgs e)
        {
            using var openFileDialog = new OpenFileDialog
            {
                Filter = "Executables (*.exe)|*.exe|All files (*.*)|*.*",
                Title = "Select a program"
            };
            if (openFileDialog.ShowDialog() == DialogResult.OK)
            {
                restrictAppPathTextBox.Text = openFileDialog.FileName;
            }
        }


        private void wildcardRuleButton_Click(object sender, EventArgs e)
        {
            using var wildcardDialog = new WildcardCreatorForm(_wildcardRuleService, _appSettings);
            if (wildcardDialog.ShowDialog(this) == DialogResult.OK)
            {
                var newRule = wildcardDialog.NewRule;
                _backgroundTaskService.EnqueueTask(new FirewallTask(FirewallTaskType.AddWildcardRule, newRule));
                this.DialogResult = DialogResult.OK;
                this.Close();
            }
        }

        private void advancedRuleButton_Click(object sender, EventArgs e)
        {
            using var dialog = new CreateAdvancedRuleForm(_actionsService, _appSettings);
            if (dialog.ShowDialog(this) == DialogResult.OK)
            {
                if (dialog.RuleVm != null)
                {
                    var payload = new CreateAdvancedRulePayload { ViewModel = dialog.RuleVm, InterfaceTypes = dialog.RuleVm.InterfaceTypes, IcmpTypesAndCodes = dialog.RuleVm.IcmpTypesAndCodes };
                    _backgroundTaskService.EnqueueTask(new FirewallTask(FirewallTaskType.CreateAdvancedRule, payload));
                }
                this.DialogResult = DialogResult.OK;
                this.Close();
            }
        }

        private void blockServiceButton_Click(object sender, EventArgs e)
        {
            _selectedTemplate = RuleTemplate.BlockService;
            GoForwardTo(WizardStep.GetService);
        }

        private void allowFileShareButton_Click(object sender, EventArgs e)
        {
            _selectedTemplate = RuleTemplate.AllowFileShare;
            GoForwardTo(WizardStep.GetFileShareIP);
        }

        private void blockDeviceButton_Click(object sender, EventArgs e)
        {
            _selectedTemplate = RuleTemplate.BlockDevice;
            GoForwardTo(WizardStep.GetBlockDeviceIP);
        }

        private void restrictAppButton_Click(object sender, EventArgs e)
        {
            _selectedTemplate = RuleTemplate.RestrictApp;
            GoForwardTo(WizardStep.GetRestrictApp);
        }

        private void restrictToProgramCheckBox_CheckedChanged(object sender, EventArgs e)
        {
            bool isChecked = restrictToProgramCheckBox.Checked;
            portsProgramPathTextBox.Visible = isChecked;
            portsBrowseButton.Visible = isChecked;
            if (!isChecked)
            {
                portsProgramPathTextBox.Text = string.Empty;
            }
        }

        private bool ValidatePortString(string portString, out string errorMessage)
        {
            errorMessage = string.Empty;
            if (string.IsNullOrWhiteSpace(portString) || portString == "*") return true;

            var parts = portString.Split(',');
            foreach (var part in parts)
            {
                var trimmedPart = part.Trim();
                if (string.IsNullOrEmpty(trimmedPart)) continue;

                if (trimmedPart.Contains('-'))
                {
                    var rangeParts = trimmedPart.Split('-');
                    if (rangeParts.Length != 2 ||
                        !ushort.TryParse(rangeParts[0], out ushort start) ||
                        !ushort.TryParse(rangeParts[1], out ushort end) ||
                        start > end)
                    {
                        errorMessage = $"Invalid port range '{trimmedPart}'. Must be in the format 'start-end' (e.g., 80-88).";
                        return false;
                    }
                }
                else if (!ushort.TryParse(trimmedPart, out _))
                {
                    errorMessage = $"Invalid port number '{trimmedPart}'. Must be a number between 0 and 65535.";
                    return false;
                }
            }
            return true;
        }

        private bool ValidateStep()
        {
            switch (_currentStep)
            {
                case WizardStep.GetFolder:
                    if (string.IsNullOrWhiteSpace(batchFolderPathTextBox.Text) || !Directory.Exists(Environment.ExpandEnvironmentVariables(batchFolderPathTextBox.Text)))
                    {
                        Messenger.MessageBox("Please select a valid folder.", "Invalid Folder", MessageBoxButtons.OK, MessageBoxIcon.Error);
                        return false;
                    }
                    if (!exeCheckBox.Checked && !dllCheckBox.Checked)
                    {
                        Messenger.MessageBox("Please select at least one file type to apply rules to (.exe or .dll).", "No File Type Selected", MessageBoxButtons.OK, MessageBoxIcon.Error);
                        return false;
                    }
                    break;
                case WizardStep.GetProgram:
                    if (string.IsNullOrWhiteSpace(programPathTextBox.Text) || !File.Exists(Environment.ExpandEnvironmentVariables(programPathTextBox.Text)))
                    {
                        Messenger.MessageBox("Please select a valid program file.", "Invalid File", MessageBoxButtons.OK, MessageBoxIcon.Error);
                        return false;
                    }
                    break;
                case WizardStep.GetPorts:
                    if (!ValidatePortString(portsTextBox.Text, out string portError))
                    {
                        Messenger.MessageBox(portError, "Invalid Port", MessageBoxButtons.OK, MessageBoxIcon.Error);
                        return false;
                    }
                    if (restrictToProgramCheckBox.Checked && (string.IsNullOrWhiteSpace(portsProgramPathTextBox.Text) || !File.Exists(Environment.ExpandEnvironmentVariables(portsProgramPathTextBox.Text))))
                    {
                        Messenger.MessageBox("Please select a valid program file.", "Invalid File", MessageBoxButtons.OK, MessageBoxIcon.Error);
                        return false;
                    }
                    break;
                case WizardStep.GetName:
                    if (string.IsNullOrWhiteSpace(ruleNameTextBox.Text))
                    {
                        Messenger.MessageBox("Please enter a name for the rule.", "Invalid Name", MessageBoxButtons.OK, MessageBoxIcon.Error);
                        return false;
                    }
                    break;
                case WizardStep.GetService:
                    string serviceName = serviceNameTextBox.Text;
                    if (serviceListBox.SelectedItem != null)
                    {
                        string selected = serviceListBox.SelectedItem.ToString()!;
                        serviceName = selected.Substring(selected.LastIndexOf('(') + 1).TrimEnd(')');
                    }

                    if (string.IsNullOrWhiteSpace(serviceName))
                    {
                        Messenger.MessageBox("Please select a service from the list or enter a service name.", "No Service Selected", MessageBoxButtons.OK, MessageBoxIcon.Error);
                        return false;
                    }

                    var services = SystemDiscoveryService.GetServicesWithExePaths();
                    if (!services.Any(s => s.ServiceName.Equals(serviceName, StringComparison.OrdinalIgnoreCase)))
                    {
                        Messenger.MessageBox($"Service '{serviceName}' not found on this system.", "Invalid Service", MessageBoxButtons.OK, MessageBoxIcon.Error);
                        return false;
                    }

                    break;
                case WizardStep.GetFileShareIP:
                    if (string.IsNullOrWhiteSpace(fileShareIpTextBox.Text) || !IPAddress.TryParse(fileShareIpTextBox.Text, out _))
                    {
                        Messenger.MessageBox("Please enter a valid IP address.", "Invalid IP Address", MessageBoxButtons.OK, MessageBoxIcon.Error);
                        return false;
                    }
                    break;
                case WizardStep.GetBlockDeviceIP:
                    if (string.IsNullOrWhiteSpace(blockDeviceIpTextBox.Text) || !IPAddress.TryParse(blockDeviceIpTextBox.Text, out _))
                    {
                        Messenger.MessageBox("Please enter a valid IP address.", "Invalid IP Address", MessageBoxButtons.OK, MessageBoxIcon.Error);
                        return false;
                    }
                    break;
                case WizardStep.GetRestrictApp:
                    if (string.IsNullOrWhiteSpace(restrictAppPathTextBox.Text) || !File.Exists(Environment.ExpandEnvironmentVariables(restrictAppPathTextBox.Text)))
                    {
                        Messenger.MessageBox("Please select a valid program file.", "Invalid File", MessageBoxButtons.OK, MessageBoxIcon.Error);
                        return false;
                    }
                    break;
            }
            return true;
        }

        private void ProcessStepLogic()
        {
            switch (_currentStep)
            {
                case WizardStep.GetFolder:
                    _wizardFolderPath = batchFolderPathTextBox.Text;
                    GoForwardTo(WizardStep.GetAction);
                    break;
                case WizardStep.GetAction:
                    _wizardAction = allowActionRadioButton.Checked ? Actions.Allow : Actions.Block;
                    if (_selectedTemplate == RuleTemplate.BatchProgramRule)
                    {
                        GoForwardTo(WizardStep.GetDirection);
                    }
                    else
                    {
                        GoForwardTo(WizardStep.GetProgram);
                    }
                    break;
                case WizardStep.GetProgram:
                    _wizardAppPath = programPathTextBox.Text;
                    GoForwardTo(WizardStep.GetDirection);
                    break;
                case WizardStep.GetDirection:
                    if (inboundRadioButton.Checked) _wizardDirection = Directions.Incoming;
                    else if (outboundRadioButton.Checked) _wizardDirection = Directions.Outgoing;
                    else _wizardDirection = Directions.Incoming | Directions.Outgoing;

                    if (_selectedTemplate == RuleTemplate.BatchProgramRule)
                    {
                        CreateRule();
                        this.DialogResult = DialogResult.OK;
                        this.Close();
                    }
                    else
                    {
                        GoForwardTo(WizardStep.Summary);
                    }
                    break;
                case WizardStep.GetPorts:
                    _wizardPorts = portsTextBox.Text;
                    _wizardAppPath = restrictToProgramCheckBox.Checked ? portsProgramPathTextBox.Text : string.Empty;
                    GoForwardTo(WizardStep.GetProtocol);
                    break;

                case WizardStep.GetProtocol:
                    if (tcpRadioButton.Checked) _wizardProtocol = 6;
                    else if (udpRadioButton.Checked) _wizardProtocol = 17;
                    else _wizardProtocol = 256;
                    ruleNameTextBox.Text = string.IsNullOrEmpty(_wizardAppPath)
                        ? $"Allow Port {_wizardPorts}"
                        : $"Allow {Path.GetFileNameWithoutExtension(_wizardAppPath)} Port {_wizardPorts}";
                    GoForwardTo(WizardStep.GetName);
                    break;

                case WizardStep.GetName:
                    _wizardRuleName = ruleNameTextBox.Text;
                    GoForwardTo(WizardStep.Summary);
                    break;

                case WizardStep.GetService:
                    if (serviceListBox.SelectedItem != null)
                    {
                        string selected = serviceListBox.SelectedItem.ToString()!;
                        _wizardServiceName = selected.Substring(selected.LastIndexOf('(') + 1).TrimEnd(')');
                    }
                    else
                    {
                        _wizardServiceName = serviceNameTextBox.Text;
                    }
                    GoForwardTo(WizardStep.Summary);
                    break;

                case WizardStep.GetFileShareIP:
                    _wizardRemoteIP = fileShareIpTextBox.Text;
                    GoForwardTo(WizardStep.Summary);
                    break;

                case WizardStep.GetBlockDeviceIP:
                    _wizardRemoteIP = blockDeviceIpTextBox.Text;
                    GoForwardTo(WizardStep.Summary);
                    break;

                case WizardStep.GetRestrictApp:
                    _wizardAppPath = restrictAppPathTextBox.Text;
                    GoForwardTo(WizardStep.Summary);
                    break;

                case WizardStep.Summary:
                    CreateRule();
                    this.DialogResult = DialogResult.OK;
                    this.Close();
                    break;
            }
        }

        private void BuildSummary()
        {
            var sb = new System.Text.StringBuilder();
            switch (_selectedTemplate)
            {
                case RuleTemplate.ProgramRule:
                    sb.AppendLine($"Action: {_wizardAction}");
                    sb.AppendLine($"Direction: {_wizardDirection}");
                    sb.AppendLine($"Program: {_wizardAppPath}");
                    sb.AppendLine($"Details: All protocols, all ports");
                    break;
                case RuleTemplate.PortRule:
                    sb.AppendLine($"Rule Name: {_wizardRuleName}");
                    sb.AppendLine($"Action: Allow");
                    sb.AppendLine($"Direction: Incoming & Outgoing");
                    if (!string.IsNullOrEmpty(_wizardAppPath))
                    {
                        sb.AppendLine($"Program: {_wizardAppPath}");
                    }
                    sb.AppendLine($"Ports: {_wizardPorts}");
                    sb.AppendLine($"Protocol: {(_wizardProtocol == 6 ? "TCP" : _wizardProtocol == 17 ? "UDP" : "TCP & UDP")}");
                    break;
                case RuleTemplate.BlockService:
                    sb.AppendLine("Action: Block");
                    sb.AppendLine("Direction: Incoming & Outgoing");
                    sb.AppendLine($"Service: {_wizardServiceName}");
                    break;
                case RuleTemplate.AllowFileShare:
                    sb.AppendLine("Action: Allow");
                    sb.AppendLine("Direction: Inbound");
                    sb.AppendLine("Protocol: TCP");
                    sb.AppendLine("Local Port: 445 (File Sharing)");
                    sb.AppendLine($"From IP Address: {_wizardRemoteIP}");
                    break;
                case RuleTemplate.BlockDevice:
                    sb.AppendLine("Action: Block");
                    sb.AppendLine("Direction: Inbound");
                    sb.AppendLine("Protocol: Any");
                    sb.AppendLine($"From IP Address: {_wizardRemoteIP}");
                    break;
                case RuleTemplate.RestrictApp:
                    sb.AppendLine("Action: Allow on Local Network Only");
                    sb.AppendLine("(Note: This requires 'Lockdown Mode' to be active to block internet access.)");
                    sb.AppendLine("Direction: Inbound & Outbound");
                    sb.AppendLine($"Program: {_wizardAppPath}");
                    break;
            }
            summaryLabel.Text = sb.ToString();
        }

        private void CreateRule()
        {
            switch (_selectedTemplate)
            {
                case RuleTemplate.BatchProgramRule:
                    var searchPatterns = new List<string>();
                    if (exeCheckBox.Checked)
                    {
                        searchPatterns.Add("*.exe");
                    }
                    if (dllCheckBox.Checked)
                    {
                        searchPatterns.Add("*.dll");
                    }

                    var executables = SystemDiscoveryService.GetFilesInFolder(_wizardFolderPath, searchPatterns);
                    if (executables.Count == 0)
                    {
                        Messenger.MessageBox($"No matching files found in '{_wizardFolderPath}' or its subfolders.", "No Files Found", MessageBoxButtons.OK, MessageBoxIcon.None);
                        return;
                    }
                    string batchAction = $"{_wizardAction} ({_wizardDirection})";
                    var batchPayload = new ApplyApplicationRulePayload { AppPaths = executables, Action = batchAction };
                    _backgroundTaskService.EnqueueTask(new FirewallTask(FirewallTaskType.ApplyApplicationRule, batchPayload));
                    Messenger.MessageBox($"{executables.Count} rules have been queued for creation.", "Task Queued", MessageBoxButtons.OK, MessageBoxIcon.None);
                    break;
                case RuleTemplate.ProgramRule:
                    string action = $"{_wizardAction} ({_wizardDirection})";
                    var payload = new ApplyApplicationRulePayload { AppPaths = { _wizardAppPath }, Action = action };
                    _backgroundTaskService.EnqueueTask(new FirewallTask(FirewallTaskType.ApplyApplicationRule, payload));
                    break;
                case RuleTemplate.PortRule:
                    var vm = new AdvancedRuleViewModel
                    {
                        Name = _wizardRuleName,
                        IsEnabled = true,
                        Status = "Allow",
                        Direction = Directions.Incoming | Directions.Outgoing,
                        Protocol = (short)_wizardProtocol,
                        LocalPorts = _wizardPorts,
                        ApplicationName = string.IsNullOrEmpty(_wizardAppPath) ? "*" : _wizardAppPath,
                        Grouping = MFWConstants.MainRuleGroup,
                        RemotePorts = "*",
                        LocalAddresses = "*",
                        RemoteAddresses = "*",
                        Profiles = "All",
                        Type = RuleType.Advanced
                    };
                    var advPayload = new CreateAdvancedRulePayload { ViewModel = vm, InterfaceTypes = "All", IcmpTypesAndCodes = "" };
                    _backgroundTaskService.EnqueueTask(new FirewallTask(FirewallTaskType.CreateAdvancedRule, advPayload));
                    break;
                case RuleTemplate.BlockService:
                    var servicePayload = new ApplyServiceRulePayload { ServiceName = _wizardServiceName, Action = "Block (All)" };
                    _backgroundTaskService.EnqueueTask(new FirewallTask(FirewallTaskType.ApplyServiceRule, servicePayload));
                    break;
                case RuleTemplate.AllowFileShare:
                    var fileShareVm = new AdvancedRuleViewModel
                    {
                        Name = $"Allow File Sharing from {_wizardRemoteIP}",
                        Description = "Allows inbound file sharing (SMB)",
                        IsEnabled = true,
                        Status = "Allow",
                        Direction = Directions.Incoming,
                        Protocol = 6,
                        LocalPorts = "445",
                        RemoteAddresses = _wizardRemoteIP,
                        Grouping = MFWConstants.MainRuleGroup,
                        Type = RuleType.Advanced,
                        RemotePorts = "*",
                        LocalAddresses = "*",
                        Profiles = "All"
                    };
                    var fileSharePayload = new CreateAdvancedRulePayload { ViewModel = fileShareVm, InterfaceTypes = "All", IcmpTypesAndCodes = "" };
                    _backgroundTaskService.EnqueueTask(new FirewallTask(FirewallTaskType.CreateAdvancedRule, fileSharePayload));
                    break;
                case RuleTemplate.BlockDevice:
                    var blockDeviceVm = new AdvancedRuleViewModel
                    {
                        Name = $"Block Inbound from {_wizardRemoteIP}",
                        Description = "Blocks all inbound traffic from a specific local IP",
                        IsEnabled = true,
                        Status = "Block",
                        Direction = Directions.Incoming,
                        Protocol = 256,
                        RemoteAddresses = _wizardRemoteIP,
                        Grouping = MFWConstants.MainRuleGroup,
                        Type = RuleType.Advanced,
                        LocalPorts = "*",
                        RemotePorts = "*",
                        LocalAddresses = "*",
                        Profiles = "All"
                    };
                    var blockDevicePayload = new CreateAdvancedRulePayload { ViewModel = blockDeviceVm, InterfaceTypes = "All", IcmpTypesAndCodes = "" };
                    _backgroundTaskService.EnqueueTask(new FirewallTask(FirewallTaskType.CreateAdvancedRule, blockDevicePayload));
                    break;
                case RuleTemplate.RestrictApp:
                    string appName = Path.GetFileNameWithoutExtension(_wizardAppPath);
                    var allowLocalVm = new AdvancedRuleViewModel
                    {
                        Name = $"{appName} - Allow Local Network",
                        Description = "Allows communication only within the local network. This rule only works as intended if Lockdown Mode is active.",
                        IsEnabled = true,
                        Status = "Allow",
                        Direction = Directions.Incoming | Directions.Outgoing,
                        ApplicationName = _wizardAppPath,
                        Protocol = 256,
                        RemoteAddresses = "10.0.0.0/8,172.16.0.0/12,192.168.0.0/16,LocalSubnet",
                        Grouping = MFWConstants.MainRuleGroup,
                        Type = RuleType.Advanced,
                        LocalPorts = "*",
                        RemotePorts = "*",
                        LocalAddresses = "*",
                        Profiles = "All"
                    };
                    var allowPayload = new CreateAdvancedRulePayload { ViewModel = allowLocalVm, InterfaceTypes = "All", IcmpTypesAndCodes = "" };
                    _backgroundTaskService.EnqueueTask(new FirewallTask(FirewallTaskType.CreateAdvancedRule, allowPayload));
                    break;
            }
        }
    }
}



--------------------------------------------------
// Full Path: C:/Users/anon/PROGRAMMING/C#/SimpleFirewall/VS Minimal Firewall/MinimalFirewall-NET8/Backups/v2.5.5 - ws/2.5.5.6 - security vulnerability fix 3/RuleWizardForm.Designer.cs
--------------------------------------------------------------------------------
// File: RuleWizardForm.Designer.cs
namespace MinimalFirewall
{
    partial class RuleWizardForm
    {
        private System.ComponentModel.IContainer components = null;
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        private void InitializeComponent()
        {
            this.pnlSelection = new System.Windows.Forms.Panel();
            this.restrictAppButton = new System.Windows.Forms.Button();
            this.blockDeviceButton = new System.Windows.Forms.Button();
            this.allowFileShareButton = new System.Windows.Forms.Button();
            this.blockServiceButton = new System.Windows.Forms.Button();
            this.advancedRuleButton = new System.Windows.Forms.Button();
            this.wildcardRuleButton = new System.Windows.Forms.Button();
            this.portRuleButton = new System.Windows.Forms.Button();
            this.programRuleButton = new System.Windows.Forms.Button();
            this.batchProgramRuleButton = new System.Windows.Forms.Button();
            this.pnlGetProgram = new System.Windows.Forms.Panel();
            this.browseButton = new System.Windows.Forms.Button();
            this.programPathTextBox = new System.Windows.Forms.TextBox();
            this.pnlGetFolder = new System.Windows.Forms.Panel();
            this.dllCheckBox = new System.Windows.Forms.CheckBox();
            this.exeCheckBox = new System.Windows.Forms.CheckBox();
            this.batchBrowseFolderButton = new System.Windows.Forms.Button();
            this.batchFolderPathTextBox = new System.Windows.Forms.TextBox();
            this.pnlGetPorts = new System.Windows.Forms.Panel();
            this.portsProgramPathTextBox = new System.Windows.Forms.TextBox();
            this.portsBrowseButton = new System.Windows.Forms.Button();
            this.restrictToProgramCheckBox = new System.Windows.Forms.CheckBox();
            this.portsTextBox = new System.Windows.Forms.TextBox();
            this.portsLabel = new System.Windows.Forms.Label();
            this.pnlGetProtocol = new System.Windows.Forms.Panel();
            this.bothProtocolRadioButton = new System.Windows.Forms.RadioButton();
            this.udpRadioButton = new System.Windows.Forms.RadioButton();
            this.tcpRadioButton = new System.Windows.Forms.RadioButton();
            this.pnlSummary = new System.Windows.Forms.Panel();
            this.summaryLabel = new System.Windows.Forms.Label();
            this.pnlGetName = new System.Windows.Forms.Panel();
            this.ruleNameTextBox = new System.Windows.Forms.TextBox();
            this.bottomPanel = new System.Windows.Forms.Panel();
            this.cancelButton = new System.Windows.Forms.Button();
            this.nextButton = new System.Windows.Forms.Button();
            this.backButton = new System.Windows.Forms.Button();
            this.topPanel = new System.Windows.Forms.Panel();
            this.mainHeaderLabel = new System.Windows.Forms.Label();
            this.pnlGetAction = new System.Windows.Forms.Panel();
            this.blockActionRadioButton = new System.Windows.Forms.RadioButton();
            this.allowActionRadioButton = new System.Windows.Forms.RadioButton();
            this.pnlGetDirection = new System.Windows.Forms.Panel();
            this.bothDirRadioButton = new System.Windows.Forms.RadioButton();
            this.inboundRadioButton = new System.Windows.Forms.RadioButton();
            this.outboundRadioButton = new System.Windows.Forms.RadioButton();
            this.pnlGetService = new System.Windows.Forms.Panel();
            this.serviceNameTextBox = new System.Windows.Forms.TextBox();
            this.serviceListBox = new System.Windows.Forms.ListBox();
            this.serviceInstructionLabel = new System.Windows.Forms.Label();
            this.pnlGetFileShareIP = new System.Windows.Forms.Panel();
            this.fileShareIpTextBox = new System.Windows.Forms.TextBox();
            this.fileShareWarningLabel = new System.Windows.Forms.Label();
            this.pnlGetBlockDeviceIP = new System.Windows.Forms.Panel();
            this.blockDeviceIpTextBox = new System.Windows.Forms.TextBox();
            this.pnlGetRestrictApp = new System.Windows.Forms.Panel();
            this.restrictAppPathTextBox = new System.Windows.Forms.TextBox();
            this.restrictAppBrowseButton = new System.Windows.Forms.Button();
            this.pnlSelection.SuspendLayout();
            this.pnlGetProgram.SuspendLayout();
            this.pnlGetFolder.SuspendLayout();
            this.pnlGetPorts.SuspendLayout();
            this.pnlGetProtocol.SuspendLayout();
            this.pnlSummary.SuspendLayout();
            this.pnlGetName.SuspendLayout();
            this.bottomPanel.SuspendLayout();
            this.topPanel.SuspendLayout();
            this.pnlGetAction.SuspendLayout();
            this.pnlGetDirection.SuspendLayout();
            this.pnlGetService.SuspendLayout();
            this.pnlGetFileShareIP.SuspendLayout();
            this.pnlGetBlockDeviceIP.SuspendLayout();
            this.pnlGetRestrictApp.SuspendLayout();
            this.SuspendLayout();
            // 
            // pnlSelection
            // 
            this.pnlSelection.Controls.Add(this.restrictAppButton);
            this.pnlSelection.Controls.Add(this.blockDeviceButton);
            this.pnlSelection.Controls.Add(this.allowFileShareButton);
            this.pnlSelection.Controls.Add(this.blockServiceButton);
            this.pnlSelection.Controls.Add(this.advancedRuleButton);
            this.pnlSelection.Controls.Add(this.wildcardRuleButton);
            this.pnlSelection.Controls.Add(this.portRuleButton);
            this.pnlSelection.Controls.Add(this.batchProgramRuleButton);
            this.pnlSelection.Controls.Add(this.programRuleButton);
            this.pnlSelection.Location = new System.Drawing.Point(0, 58);
            this.pnlSelection.Name = "pnlSelection";
            this.pnlSelection.Size = new System.Drawing.Size(534, 340);
            this.pnlSelection.TabIndex = 0;
            // 
            // restrictAppButton
            // 
            this.restrictAppButton.Location = new System.Drawing.Point(50, 284);
            this.restrictAppButton.Name = "restrictAppButton";
            this.restrictAppButton.Size = new System.Drawing.Size(434, 28);
            this.restrictAppButton.TabIndex = 7;
            this.restrictAppButton.Text = "Restrict an App to My Local Network Only";
            this.restrictAppButton.UseVisualStyleBackColor = true;
            this.restrictAppButton.Click += new System.EventHandler(this.restrictAppButton_Click);
            // 
            // blockDeviceButton
            // 
            this.blockDeviceButton.Location = new System.Drawing.Point(50, 246);
            this.blockDeviceButton.Name = "blockDeviceButton";
            this.blockDeviceButton.Size = new System.Drawing.Size(434, 28);
            this.blockDeviceButton.TabIndex = 6;
            this.blockDeviceButton.Text = "Block a Specific Device on My Network";
            this.blockDeviceButton.UseVisualStyleBackColor = true;
            this.blockDeviceButton.Click += new System.EventHandler(this.blockDeviceButton_Click);
            // 
            // allowFileShareButton
            // 
            this.allowFileShareButton.Location = new System.Drawing.Point(50, 208);
            this.allowFileShareButton.Name = "allowFileShareButton";
            this.allowFileShareButton.Size = new System.Drawing.Size(434, 28);
            this.allowFileShareButton.TabIndex = 5;
            this.allowFileShareButton.Text = "Allow Another PC to Access My Files";
            this.allowFileShareButton.UseVisualStyleBackColor = true;
            this.allowFileShareButton.Click += new System.EventHandler(this.allowFileShareButton_Click);
            // 
            // blockServiceButton
            // 
            this.blockServiceButton.Location = new System.Drawing.Point(50, 170);
            this.blockServiceButton.Name = "blockServiceButton";
            this.blockServiceButton.Size = new System.Drawing.Size(434, 28);
            this.blockServiceButton.TabIndex = 4;
            this.blockServiceButton.Text = "Block a Windows Service";
            this.blockServiceButton.UseVisualStyleBackColor = true;
            this.blockServiceButton.Click += new System.EventHandler(this.blockServiceButton_Click);
            // 
            // advancedRuleButton
            // 
            this.advancedRuleButton.Location = new System.Drawing.Point(50, 322);
            this.advancedRuleButton.Name = "advancedRuleButton";
            this.advancedRuleButton.Size = new System.Drawing.Size(434, 28);
            this.advancedRuleButton.TabIndex = 3;
            this.advancedRuleButton.Text = "Create a Custom Advanced Rule...";
            this.advancedRuleButton.UseVisualStyleBackColor = true;
            this.advancedRuleButton.Click += new System.EventHandler(this.advancedRuleButton_Click);
            // 
            // wildcardRuleButton
            // 
            this.wildcardRuleButton.Location = new System.Drawing.Point(50, 132);
            this.wildcardRuleButton.Name = "wildcardRuleButton";
            this.wildcardRuleButton.Size = new System.Drawing.Size(434, 28);
            this.wildcardRuleButton.TabIndex = 2;
            this.wildcardRuleButton.Text = "Create a Wildcard Rule for a Folder...";
            this.wildcardRuleButton.UseVisualStyleBackColor = true;
            this.wildcardRuleButton.Click += new System.EventHandler(this.wildcardRuleButton_Click);
            // 
            // portRuleButton
            // 
            this.portRuleButton.Location = new System.Drawing.Point(50, 94);
            this.portRuleButton.Name = "portRuleButton";
            this.portRuleButton.Size = new System.Drawing.Size(434, 28);
            this.portRuleButton.TabIndex = 1;
            this.portRuleButton.Text = "Open a Port";
            this.portRuleButton.UseVisualStyleBackColor = true;
            this.portRuleButton.Click += new System.EventHandler(this.portRuleButton_Click);
            // 
            // programRuleButton
            // 
            this.programRuleButton.Location = new System.Drawing.Point(50, 18);
            this.programRuleButton.Name = "programRuleButton";
            this.programRuleButton.Size = new System.Drawing.Size(434, 28);
            this.programRuleButton.TabIndex = 0;
            this.programRuleButton.Text = "Allow or Block a Program";
            this.programRuleButton.UseVisualStyleBackColor = true;
            this.programRuleButton.Click += new System.EventHandler(this.programRuleButton_Click);
            // 
            // batchProgramRuleButton
            // 
            this.batchProgramRuleButton.Location = new System.Drawing.Point(50, 56);
            this.batchProgramRuleButton.Name = "batchProgramRuleButton";
            this.batchProgramRuleButton.Size = new System.Drawing.Size(434, 28);
            this.batchProgramRuleButton.TabIndex = 8;
            this.batchProgramRuleButton.Text = "Allow or Block All Programs in a Folder";
            this.batchProgramRuleButton.UseVisualStyleBackColor = true;
            this.batchProgramRuleButton.Click += new System.EventHandler(this.batchProgramRuleButton_Click);
            // 
            // pnlGetProgram
            // 
            this.pnlGetProgram.Controls.Add(this.browseButton);
            this.pnlGetProgram.Controls.Add(this.programPathTextBox);
            this.pnlGetProgram.Location = new System.Drawing.Point(0, 58);
            this.pnlGetProgram.Name = "pnlGetProgram";
            this.pnlGetProgram.Size = new System.Drawing.Size(534, 340);
            this.pnlGetProgram.TabIndex = 1;
            // 
            // browseButton
            // 
            this.browseButton.Location = new System.Drawing.Point(422, 149);
            this.browseButton.Name = "browseButton";
            this.browseButton.Size = new System.Drawing.Size(90, 23);
            this.browseButton.TabIndex = 1;
            this.browseButton.Text = "Browse...";
            this.browseButton.UseVisualStyleBackColor = true;
            this.browseButton.Click += new System.EventHandler(this.browseButton_Click);
            // 
            // programPathTextBox
            // 
            this.programPathTextBox.Location = new System.Drawing.Point(23, 149);
            this.programPathTextBox.Name = "programPathTextBox";
            this.programPathTextBox.Size = new System.Drawing.Size(393, 23);
            this.programPathTextBox.TabIndex = 0;
            this.programPathTextBox.PlaceholderText = "Path to application executable";
            // 
            // pnlGetFolder
            // 
            this.pnlGetFolder.Controls.Add(this.dllCheckBox);
            this.pnlGetFolder.Controls.Add(this.exeCheckBox);
            this.pnlGetFolder.Controls.Add(this.batchBrowseFolderButton);
            this.pnlGetFolder.Controls.Add(this.batchFolderPathTextBox);
            this.pnlGetFolder.Location = new System.Drawing.Point(0, 58);
            this.pnlGetFolder.Name = "pnlGetFolder";
            this.pnlGetFolder.Size = new System.Drawing.Size(534, 340);
            this.pnlGetFolder.TabIndex = 14;
            // 
            // dllCheckBox
            // 
            this.dllCheckBox.AutoSize = true;
            this.dllCheckBox.Location = new System.Drawing.Point(112, 178);
            this.dllCheckBox.Name = "dllCheckBox";
            this.dllCheckBox.Size = new System.Drawing.Size(74, 19);
            this.dllCheckBox.TabIndex = 3;
            this.dllCheckBox.Text = ".dll files";
            this.dllCheckBox.UseVisualStyleBackColor = true;
            // 
            // exeCheckBox
            // 
            this.exeCheckBox.AutoSize = true;
            this.exeCheckBox.Checked = true;
            this.exeCheckBox.CheckState = System.Windows.Forms.CheckState.Checked;
            this.exeCheckBox.Location = new System.Drawing.Point(23, 178);
            this.exeCheckBox.Name = "exeCheckBox";
            this.exeCheckBox.Size = new System.Drawing.Size(83, 19);
            this.exeCheckBox.TabIndex = 2;
            this.exeCheckBox.Text = ".exe files";
            this.exeCheckBox.UseVisualStyleBackColor = true;
            // 
            // batchBrowseFolderButton
            // 
            this.batchBrowseFolderButton.Location = new System.Drawing.Point(422, 149);
            this.batchBrowseFolderButton.Name = "batchBrowseFolderButton";
            this.batchBrowseFolderButton.Size = new System.Drawing.Size(90, 23);
            this.batchBrowseFolderButton.TabIndex = 1;
            this.batchBrowseFolderButton.Text = "Browse...";
            this.batchBrowseFolderButton.UseVisualStyleBackColor = true;
            this.batchBrowseFolderButton.Click += new System.EventHandler(this.batchBrowseFolderButton_Click);
            // 
            // batchFolderPathTextBox
            // 
            this.batchFolderPathTextBox.Location = new System.Drawing.Point(23, 149);
            this.batchFolderPathTextBox.Name = "batchFolderPathTextBox";
            this.batchFolderPathTextBox.PlaceholderText = "Path to folder";
            this.batchFolderPathTextBox.Size = new System.Drawing.Size(393, 23);
            this.batchFolderPathTextBox.TabIndex = 0;
            // 
            // pnlGetPorts
            // 
            this.pnlGetPorts.Controls.Add(this.portsProgramPathTextBox);
            this.pnlGetPorts.Controls.Add(this.portsBrowseButton);
            this.pnlGetPorts.Controls.Add(this.restrictToProgramCheckBox);
            this.pnlGetPorts.Controls.Add(this.portsTextBox);
            this.pnlGetPorts.Controls.Add(this.portsLabel);
            this.pnlGetPorts.Location = new System.Drawing.Point(0, 58);
            this.pnlGetPorts.Name = "pnlGetPorts";
            this.pnlGetPorts.Size = new System.Drawing.Size(534, 340);
            this.pnlGetPorts.TabIndex = 2;
            // 
            // portsProgramPathTextBox
            // 
            this.portsProgramPathTextBox.Location = new System.Drawing.Point(62, 234);
            this.portsProgramPathTextBox.Name = "portsProgramPathTextBox";
            this.portsProgramPathTextBox.Size = new System.Drawing.Size(354, 23);
            this.portsProgramPathTextBox.TabIndex = 3;
            this.portsProgramPathTextBox.Visible = false;
            // 
            // portsBrowseButton
            // 
            this.portsBrowseButton.Location = new System.Drawing.Point(422, 234);
            this.portsBrowseButton.Name = "portsBrowseButton";
            this.portsBrowseButton.Size = new System.Drawing.Size(90, 23);
            this.portsBrowseButton.TabIndex = 4;
            this.portsBrowseButton.Text = "Browse...";
            this.portsBrowseButton.UseVisualStyleBackColor = true;
            this.portsBrowseButton.Visible = false;
            this.portsBrowseButton.Click += new System.EventHandler(this.portsBrowseButton_Click);
            // 
            // restrictToProgramCheckBox
            // 
            this.restrictToProgramCheckBox.AutoSize = true;
            this.restrictToProgramCheckBox.Location = new System.Drawing.Point(117, 209);
            this.restrictToProgramCheckBox.Name = "restrictToProgramCheckBox";
            this.restrictToProgramCheckBox.Size = new System.Drawing.Size(217, 19);
            this.restrictToProgramCheckBox.TabIndex = 2;
            this.restrictToProgramCheckBox.Text = "Also restrict this rule to a program?";
            this.restrictToProgramCheckBox.UseVisualStyleBackColor = true;
            this.restrictToProgramCheckBox.CheckedChanged += new System.EventHandler(this.restrictToProgramCheckBox_CheckedChanged);
            // 
            // portsTextBox
            // 
            this.portsTextBox.Location = new System.Drawing.Point(117, 122);
            this.portsTextBox.Name = "portsTextBox";
            this.portsTextBox.Size = new System.Drawing.Size(300, 23);
            this.portsTextBox.TabIndex = 0;
            // 
            // portsLabel
            // 
            this.portsLabel.AutoSize = true;
            this.portsLabel.Location = new System.Drawing.Point(117, 148);
            this.portsLabel.Name = "portsLabel";
            this.portsLabel.Size = new System.Drawing.Size(161, 15);
            this.portsLabel.TabIndex = 1;
            this.portsLabel.Text = "e.g., 80, 443 or 27015-27030";
            // 
            // pnlGetProtocol
            // 
            this.pnlGetProtocol.Controls.Add(this.bothProtocolRadioButton);
            this.pnlGetProtocol.Controls.Add(this.udpRadioButton);
            this.pnlGetProtocol.Controls.Add(this.tcpRadioButton);
            this.pnlGetProtocol.Location = new System.Drawing.Point(0, 58);
            this.pnlGetProtocol.Name = "pnlGetProtocol";
            this.pnlGetProtocol.Size = new System.Drawing.Size(534, 340);
            this.pnlGetProtocol.TabIndex = 3;
            // 
            // bothProtocolRadioButton
            // 
            this.bothProtocolRadioButton.AutoSize = true;
            this.bothProtocolRadioButton.Location = new System.Drawing.Point(230, 200);
            this.bothProtocolRadioButton.Name = "bothProtocolRadioButton";
            this.bothProtocolRadioButton.Size = new System.Drawing.Size(76, 19);
            this.bothProtocolRadioButton.TabIndex = 2;
            this.bothProtocolRadioButton.Text = "TCP & UDP";
            this.bothProtocolRadioButton.UseVisualStyleBackColor = true;
            // 
            // udpRadioButton
            // 
            this.udpRadioButton.AutoSize = true;
            this.udpRadioButton.Location = new System.Drawing.Point(230, 165);
            this.udpRadioButton.Name = "udpRadioButton";
            this.udpRadioButton.Size = new System.Drawing.Size(48, 19);
            this.udpRadioButton.TabIndex = 1;
            this.udpRadioButton.Text = "UDP";
            this.udpRadioButton.UseVisualStyleBackColor = true;
            // 
            // tcpRadioButton
            // 
            this.tcpRadioButton.AutoSize = true;
            this.tcpRadioButton.Checked = true;
            this.tcpRadioButton.Location = new System.Drawing.Point(230, 130);
            this.tcpRadioButton.Name = "tcpRadioButton";
            this.tcpRadioButton.Size = new System.Drawing.Size(44, 19);
            this.tcpRadioButton.TabIndex = 0;
            this.tcpRadioButton.TabStop = true;
            this.tcpRadioButton.Text = "TCP";
            this.tcpRadioButton.UseVisualStyleBackColor = true;
            // 
            // pnlSummary
            // 
            this.pnlSummary.Controls.Add(this.summaryLabel);
            this.pnlSummary.Location = new System.Drawing.Point(0, 58);
            this.pnlSummary.Name = "pnlSummary";
            this.pnlSummary.Size = new System.Drawing.Size(534, 340);
            this.pnlSummary.TabIndex = 4;
            // 
            // summaryLabel
            // 
            this.summaryLabel.Font = new System.Drawing.Font("Segoe UI", 10F);
            this.summaryLabel.Location = new System.Drawing.Point(23, 80);
            this.summaryLabel.Name = "summaryLabel";
            this.summaryLabel.Size = new System.Drawing.Size(489, 200);
            this.summaryLabel.TabIndex = 0;
            this.summaryLabel.Text = "Summary Text";
            // 
            // pnlGetName
            // 
            this.pnlGetName.Controls.Add(this.ruleNameTextBox);
            this.pnlGetName.Location = new System.Drawing.Point(0, 58);
            this.pnlGetName.Name = "pnlGetName";
            this.pnlGetName.Size = new System.Drawing.Size(534, 340);
            this.pnlGetName.TabIndex = 5;
            // 
            // ruleNameTextBox
            // 
            this.ruleNameTextBox.Location = new System.Drawing.Point(117, 149);
            this.ruleNameTextBox.Name = "ruleNameTextBox";
            this.ruleNameTextBox.Size = new System.Drawing.Size(300, 23);
            this.ruleNameTextBox.TabIndex = 0;
            // 
            // bottomPanel
            // 
            this.bottomPanel.Controls.Add(this.cancelButton);
            this.bottomPanel.Controls.Add(this.nextButton);
            this.bottomPanel.Controls.Add(this.backButton);
            this.bottomPanel.Dock = System.Windows.Forms.DockStyle.Bottom;
            this.bottomPanel.Location = new System.Drawing.Point(0, 401);
            this.bottomPanel.Name = "bottomPanel";
            this.bottomPanel.Size = new System.Drawing.Size(534, 60);
            this.bottomPanel.TabIndex = 6;
            // 
            // cancelButton
            // 
            this.cancelButton.Location = new System.Drawing.Point(422, 12);
            this.cancelButton.Name = "cancelButton";
            this.cancelButton.Size = new System.Drawing.Size(100, 36);
            this.cancelButton.TabIndex = 2;
            this.cancelButton.Text = "Cancel";
            this.cancelButton.UseVisualStyleBackColor = true;
            this.cancelButton.Click += new System.EventHandler(this.cancelButton_Click);
            // 
            // nextButton
            // 
            this.nextButton.Location = new System.Drawing.Point(316, 12);
            this.nextButton.Name = "nextButton";
            this.nextButton.Size = new System.Drawing.Size(100, 36);
            this.nextButton.TabIndex = 1;
            this.nextButton.Text = "Next";
            this.nextButton.UseVisualStyleBackColor = true;
            this.nextButton.Click += new System.EventHandler(this.nextButton_Click);
            // 
            // backButton
            // 
            this.backButton.Location = new System.Drawing.Point(210, 12);
            this.backButton.Name = "backButton";
            this.backButton.Size = new System.Drawing.Size(100, 36);
            this.backButton.TabIndex = 0;
            this.backButton.Text = "< Back";
            this.backButton.UseVisualStyleBackColor = true;
            this.backButton.Click += new System.EventHandler(this.backButton_Click);
            // 
            // topPanel
            // 
            this.topPanel.Controls.Add(this.mainHeaderLabel);
            this.topPanel.Dock = System.Windows.Forms.DockStyle.Top;
            this.topPanel.Location = new System.Drawing.Point(0, 0);
            this.topPanel.Name = "topPanel";
            this.topPanel.Size = new System.Drawing.Size(534, 55);
            this.topPanel.TabIndex = 7;
            // 
            // mainHeaderLabel
            // 
            this.mainHeaderLabel.Dock = System.Windows.Forms.DockStyle.Fill;
            this.mainHeaderLabel.Font = new System.Drawing.Font("Segoe UI", 12F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point);
            this.mainHeaderLabel.Location = new System.Drawing.Point(0, 0);
            this.mainHeaderLabel.Name = "mainHeaderLabel";
            this.mainHeaderLabel.Size = new System.Drawing.Size(534, 55);
            this.mainHeaderLabel.TabIndex = 0;
            this.mainHeaderLabel.Text = "Header Label";
            this.mainHeaderLabel.TextAlign = System.Drawing.ContentAlignment.MiddleCenter;
            // 
            // pnlGetAction
            // 
            this.pnlGetAction.Controls.Add(this.blockActionRadioButton);
            this.pnlGetAction.Controls.Add(this.allowActionRadioButton);
            this.pnlGetAction.Location = new System.Drawing.Point(0, 58);
            this.pnlGetAction.Name = "pnlGetAction";
            this.pnlGetAction.Size = new System.Drawing.Size(534, 340);
            this.pnlGetAction.TabIndex = 8;
            // 
            // blockActionRadioButton
            // 
            this.blockActionRadioButton.AutoSize = true;
            this.blockActionRadioButton.Location = new System.Drawing.Point(230, 182);
            this.blockActionRadioButton.Name = "blockActionRadioButton";
            this.blockActionRadioButton.Size = new System.Drawing.Size(53, 19);
            this.blockActionRadioButton.TabIndex = 1;
            this.blockActionRadioButton.Text = "Block";
            this.blockActionRadioButton.UseVisualStyleBackColor = true;
            // 
            // allowActionRadioButton
            // 
            this.allowActionRadioButton.AutoSize = true;
            this.allowActionRadioButton.Checked = true;
            this.allowActionRadioButton.Location = new System.Drawing.Point(230, 147);
            this.allowActionRadioButton.Name = "allowActionRadioButton";
            this.allowActionRadioButton.Size = new System.Drawing.Size(54, 19);
            this.allowActionRadioButton.TabIndex = 0;
            this.allowActionRadioButton.TabStop = true;
            this.allowActionRadioButton.Text = "Allow";
            this.allowActionRadioButton.UseVisualStyleBackColor = true;
            // 
            // pnlGetDirection
            // 
            this.pnlGetDirection.Controls.Add(this.bothDirRadioButton);
            this.pnlGetDirection.Controls.Add(this.inboundRadioButton);
            this.pnlGetDirection.Controls.Add(this.outboundRadioButton);
            this.pnlGetDirection.Location = new System.Drawing.Point(0, 58);
            this.pnlGetDirection.Name = "pnlGetDirection";
            this.pnlGetDirection.Size = new System.Drawing.Size(534, 340);
            this.pnlGetDirection.TabIndex = 9;
            // 
            // bothDirRadioButton
            // 
            this.bothDirRadioButton.AutoSize = true;
            this.bothDirRadioButton.Location = new System.Drawing.Point(230, 200);
            this.bothDirRadioButton.Name = "bothDirRadioButton";
            this.bothDirRadioButton.Size = new System.Drawing.Size(50, 19);
            this.bothDirRadioButton.TabIndex = 2;
            this.bothDirRadioButton.Text = "Both";
            this.bothDirRadioButton.UseVisualStyleBackColor = true;
            // 
            // inboundRadioButton
            // 
            this.inboundRadioButton.AutoSize = true;
            this.inboundRadioButton.Location = new System.Drawing.Point(230, 165);
            this.inboundRadioButton.Name = "inboundRadioButton";
            this.inboundRadioButton.Size = new System.Drawing.Size(70, 19);
            this.inboundRadioButton.TabIndex = 1;
            this.inboundRadioButton.Text = "Inbound";
            this.inboundRadioButton.UseVisualStyleBackColor = true;
            // 
            // outboundRadioButton
            // 
            this.outboundRadioButton.AutoSize = true;
            this.outboundRadioButton.Checked = true;
            this.outboundRadioButton.Location = new System.Drawing.Point(230, 130);
            this.outboundRadioButton.Name = "outboundRadioButton";
            this.outboundRadioButton.Size = new System.Drawing.Size(78, 19);
            this.outboundRadioButton.TabIndex = 0;
            this.outboundRadioButton.TabStop = true;
            this.outboundRadioButton.Text = "Outbound";
            this.outboundRadioButton.UseVisualStyleBackColor = true;
            // 
            // pnlGetService
            // 
            this.pnlGetService.Controls.Add(this.serviceNameTextBox);
            this.pnlGetService.Controls.Add(this.serviceListBox);
            this.pnlGetService.Controls.Add(this.serviceInstructionLabel);
            this.pnlGetService.Location = new System.Drawing.Point(0, 58);
            this.pnlGetService.Name = "pnlGetService";
            this.pnlGetService.Size = new System.Drawing.Size(534, 340);
            this.pnlGetService.TabIndex = 10;
            // 
            // serviceNameTextBox
            // 
            this.serviceNameTextBox.Location = new System.Drawing.Point(23, 290);
            this.serviceNameTextBox.Name = "serviceNameTextBox";
            this.serviceNameTextBox.Size = new System.Drawing.Size(489, 23);
            this.serviceNameTextBox.TabIndex = 2;
            this.serviceNameTextBox.PlaceholderText = "Or enter service name (e.g. DiagTrack)";
            // 
            // serviceListBox
            // 
            this.serviceListBox.FormattingEnabled = true;
            this.serviceListBox.ItemHeight = 15;
            this.serviceListBox.Location = new System.Drawing.Point(23, 40);
            this.serviceListBox.Name = "serviceListBox";
            this.serviceListBox.Size = new System.Drawing.Size(489, 244);
            this.serviceListBox.TabIndex = 1;
            // 
            // serviceInstructionLabel
            // 
            this.serviceInstructionLabel.AutoSize = true;
            this.serviceInstructionLabel.Location = new System.Drawing.Point(23, 12);
            this.serviceInstructionLabel.Name = "serviceInstructionLabel";
            this.serviceInstructionLabel.Size = new System.Drawing.Size(306, 15);
            this.serviceInstructionLabel.TabIndex = 0;
            this.serviceInstructionLabel.Text = "Select a service from the list below, or enter its name.";
            // 
            // pnlGetFileShareIP
            // 
            this.pnlGetFileShareIP.Controls.Add(this.fileShareIpTextBox);
            this.pnlGetFileShareIP.Controls.Add(this.fileShareWarningLabel);
            this.pnlGetFileShareIP.Location = new System.Drawing.Point(0, 58);
            this.pnlGetFileShareIP.Name = "pnlGetFileShareIP";
            this.pnlGetFileShareIP.Size = new System.Drawing.Size(534, 340);
            this.pnlGetFileShareIP.TabIndex = 11;
            // 
            // fileShareIpTextBox
            // 
            this.fileShareIpTextBox.Location = new System.Drawing.Point(117, 180);
            this.fileShareIpTextBox.Name = "fileShareIpTextBox";
            this.fileShareIpTextBox.PlaceholderText = "e.g., 192.168.1.50";
            this.fileShareIpTextBox.Size = new System.Drawing.Size(300, 23);
            this.fileShareIpTextBox.TabIndex = 1;
            // 
            // fileShareWarningLabel
            // 
            this.fileShareWarningLabel.Font = new System.Drawing.Font("Segoe UI", 9F, System.Drawing.FontStyle.Bold);
            this.fileShareWarningLabel.ForeColor = System.Drawing.Color.Red;
            this.fileShareWarningLabel.Location = new System.Drawing.Point(23, 60);
            this.fileShareWarningLabel.Name = "fileShareWarningLabel";
            this.fileShareWarningLabel.Size = new System.Drawing.Size(489, 84);
            this.fileShareWarningLabel.TabIndex = 0;
            this.fileShareWarningLabel.Text = "Warning: Opening port 445 for file sharing can be a security risk. Ensure you tr" +
    "ust the computer at the IP address you are about to enter and that your network" +
    " is secure.";
            this.fileShareWarningLabel.TextAlign = System.Drawing.ContentAlignment.MiddleCenter;
            // 
            // pnlGetBlockDeviceIP
            // 
            this.pnlGetBlockDeviceIP.Controls.Add(this.blockDeviceIpTextBox);
            this.pnlGetBlockDeviceIP.Location = new System.Drawing.Point(0, 58);
            this.pnlGetBlockDeviceIP.Name = "pnlGetBlockDeviceIP";
            this.pnlGetBlockDeviceIP.Size = new System.Drawing.Size(534, 340);
            this.pnlGetBlockDeviceIP.TabIndex = 12;
            // 
            // blockDeviceIpTextBox
            // 
            this.blockDeviceIpTextBox.Location = new System.Drawing.Point(117, 149);
            this.blockDeviceIpTextBox.Name = "blockDeviceIpTextBox";
            this.blockDeviceIpTextBox.PlaceholderText = "e.g., 192.168.1.101";
            this.blockDeviceIpTextBox.Size = new System.Drawing.Size(300, 23);
            this.blockDeviceIpTextBox.TabIndex = 0;
            // 
            // pnlGetRestrictApp
            // 
            this.pnlGetRestrictApp.Controls.Add(this.restrictAppPathTextBox);
            this.pnlGetRestrictApp.Controls.Add(this.restrictAppBrowseButton);
            this.pnlGetRestrictApp.Location = new System.Drawing.Point(0, 58);
            this.pnlGetRestrictApp.Name = "pnlGetRestrictApp";
            this.pnlGetRestrictApp.Size = new System.Drawing.Size(534, 340);
            this.pnlGetRestrictApp.TabIndex = 13;
            // 
            // restrictAppPathTextBox
            // 
            this.restrictAppPathTextBox.Location = new System.Drawing.Point(23, 149);
            this.restrictAppPathTextBox.Name = "restrictAppPathTextBox";
            this.restrictAppPathTextBox.PlaceholderText = "Path to application executable";
            this.restrictAppPathTextBox.Size = new System.Drawing.Size(393, 23);
            this.restrictAppPathTextBox.TabIndex = 1;
            // 
            // restrictAppBrowseButton
            // 
            this.restrictAppBrowseButton.Location = new System.Drawing.Point(422, 149);
            this.restrictAppBrowseButton.Name = "restrictAppBrowseButton";
            this.restrictAppBrowseButton.Size = new System.Drawing.Size(90, 23);
            this.restrictAppBrowseButton.TabIndex = 2;
            this.restrictAppBrowseButton.Text = "Browse...";
            this.restrictAppBrowseButton.UseVisualStyleBackColor = true;
            this.restrictAppBrowseButton.Click += new System.EventHandler(this.restrictAppBrowseButton_Click);
            // 
            // RuleWizardForm
            // 
            this.AutoScaleDimensions = new System.Drawing.SizeF(7F, 15F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.CancelButton = this.cancelButton;
            this.ClientSize = new System.Drawing.Size(534, 461);
            this.Controls.Add(this.topPanel);
            this.Controls.Add(this.bottomPanel);
            this.Controls.Add(this.pnlGetFolder);
            this.Controls.Add(this.pnlSelection);
            this.Controls.Add(this.pnlGetRestrictApp);
            this.Controls.Add(this.pnlGetBlockDeviceIP);
            this.Controls.Add(this.pnlGetFileShareIP);
            this.Controls.Add(this.pnlGetService);
            this.Controls.Add(this.pnlGetName);
            this.Controls.Add(this.pnlSummary);
            this.Controls.Add(this.pnlGetProtocol);
            this.Controls.Add(this.pnlGetPorts);
            this.Controls.Add(this.pnlGetProgram);
            this.Controls.Add(this.pnlGetAction);
            this.Controls.Add(this.pnlGetDirection);
            this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedDialog;
            this.MaximizeBox = false;
            this.MinimizeBox = false;
            this.Name = "RuleWizardForm";
            this.StartPosition = System.Windows.Forms.FormStartPosition.CenterParent;
            this.Text = "Create New Rule";
            this.pnlSelection.ResumeLayout(false);
            this.pnlGetProgram.ResumeLayout(false);
            this.pnlGetProgram.PerformLayout();
            this.pnlGetFolder.ResumeLayout(false);
            this.pnlGetFolder.PerformLayout();
            this.pnlGetPorts.ResumeLayout(false);
            this.pnlGetPorts.PerformLayout();
            this.pnlGetProtocol.ResumeLayout(false);
            this.pnlGetProtocol.PerformLayout();
            this.pnlSummary.ResumeLayout(false);
            this.pnlGetName.ResumeLayout(false);
            this.pnlGetName.PerformLayout();
            this.bottomPanel.ResumeLayout(false);
            this.topPanel.ResumeLayout(false);
            this.pnlGetAction.ResumeLayout(false);
            this.pnlGetAction.PerformLayout();
            this.pnlGetDirection.ResumeLayout(false);
            this.pnlGetDirection.PerformLayout();
            this.pnlGetService.ResumeLayout(false);
            this.pnlGetService.PerformLayout();
            this.pnlGetFileShareIP.ResumeLayout(false);
            this.pnlGetFileShareIP.PerformLayout();
            this.pnlGetBlockDeviceIP.ResumeLayout(false);
            this.pnlGetBlockDeviceIP.PerformLayout();
            this.pnlGetRestrictApp.ResumeLayout(false);
            this.pnlGetRestrictApp.PerformLayout();
            this.ResumeLayout(false);

        }

        #endregion

        private System.Windows.Forms.Panel pnlSelection;
        private System.Windows.Forms.Button advancedRuleButton;
        private System.Windows.Forms.Button wildcardRuleButton;
        private System.Windows.Forms.Button portRuleButton;
        private System.Windows.Forms.Button programRuleButton;
        private System.Windows.Forms.Button batchProgramRuleButton;
        private System.Windows.Forms.Panel pnlGetProgram;
        private System.Windows.Forms.Panel pnlGetFolder;
        private System.Windows.Forms.Panel pnlGetPorts;
        private System.Windows.Forms.Panel pnlGetProtocol;
        private System.Windows.Forms.Panel pnlSummary;
        private System.Windows.Forms.Panel pnlGetName;
        private System.Windows.Forms.Panel bottomPanel;
        private System.Windows.Forms.Button cancelButton;
        private System.Windows.Forms.Button nextButton;
        private System.Windows.Forms.Button backButton;
        private System.Windows.Forms.Panel topPanel;
        private System.Windows.Forms.Label mainHeaderLabel;
        private System.Windows.Forms.Button browseButton;
        private System.Windows.Forms.TextBox programPathTextBox;
        private System.Windows.Forms.Button batchBrowseFolderButton;
        private System.Windows.Forms.TextBox batchFolderPathTextBox;
        private System.Windows.Forms.TextBox portsTextBox;
        private System.Windows.Forms.Label portsLabel;
        private System.Windows.Forms.RadioButton bothProtocolRadioButton;
        private System.Windows.Forms.RadioButton udpRadioButton;
        private System.Windows.Forms.RadioButton tcpRadioButton;
        private System.Windows.Forms.TextBox ruleNameTextBox;
        private System.Windows.Forms.Label summaryLabel;
        private System.Windows.Forms.Panel pnlGetAction;
        private System.Windows.Forms.RadioButton blockActionRadioButton;
        private System.Windows.Forms.RadioButton allowActionRadioButton;
        private System.Windows.Forms.Panel pnlGetDirection;
        private System.Windows.Forms.RadioButton bothDirRadioButton;
        private System.Windows.Forms.RadioButton inboundRadioButton;
        private System.Windows.Forms.RadioButton outboundRadioButton;
        private System.Windows.Forms.CheckBox restrictToProgramCheckBox;
        private System.Windows.Forms.Button portsBrowseButton;
        private System.Windows.Forms.TextBox portsProgramPathTextBox;
        private Button blockServiceButton;
        private Button allowFileShareButton;
        private Button blockDeviceButton;
        private Button restrictAppButton;
        private Panel pnlGetService;
        private Panel pnlGetFileShareIP;
        private Panel pnlGetBlockDeviceIP;
        private Panel pnlGetRestrictApp;
        private TextBox serviceNameTextBox;
        private ListBox serviceListBox;
        private Label serviceInstructionLabel;
        private TextBox fileShareIpTextBox;
        private Label fileShareWarningLabel;
        private TextBox blockDeviceIpTextBox;
        private TextBox restrictAppPathTextBox;
        private Button restrictAppBrowseButton;
        private CheckBox dllCheckBox;
        private CheckBox exeCheckBox;
    }
}



--------------------------------------------------
// Full Path: C:/Users/anon/PROGRAMMING/C#/SimpleFirewall/VS Minimal Firewall/MinimalFirewall-NET8/Backups/v2.5.5 - ws/2.5.5.6 - security vulnerability fix 3/SettingsControl.cs
--------------------------------------------------------------------------------
using DarkModeForms;
using Firewall.Traffic.ViewModels;
using System.ComponentModel;
using System.Diagnostics;
using System.IO;
using System;
using System.Windows.Forms;
using System.Threading.Tasks;
using System.Drawing;
using System.IO.Compression;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Text;
using MinimalFirewall.TypedObjects;


namespace MinimalFirewall
{
    public partial class SettingsControl : UserControl
    {
        private AppSettings _appSettings;
        private StartupService _startupService;
        private PublisherWhitelistService _whitelistService;
        private FirewallActionsService _actionsService;
        private UserActivityLogger _activityLogger;
        private MainViewModel _mainViewModel;
        private ImageList _appImageList;
        private DarkModeCS _dm;

        public event Action ThemeChanged;
        public event Action IconVisibilityChanged;
        public event Func<Task> DataRefreshRequested;
        public event Action AutoRefreshTimerChanged;
        public event Action? TrafficMonitorSettingChanged;
        public SettingsControl()
        {
            InitializeComponent();
        }

        public void Initialize(
            AppSettings appSettings,
            StartupService startupService,
            PublisherWhitelistService whitelistService,
            FirewallActionsService actionsService,
            UserActivityLogger activityLogger,
            MainViewModel mainViewModel,
            ImageList appImageList,
            string version,
            DarkModeCS dm)
        {
            _appSettings = appSettings;
            _startupService = startupService;
            _whitelistService = whitelistService;
            _actionsService = actionsService;
            _activityLogger = activityLogger;
            _mainViewModel = mainViewModel;
            _appImageList = appImageList;
            _dm = dm;

            versionLabel.Text = version;
            coffeePictureBox.Image = _appImageList.Images["coffee.png"];
        }

        public void ApplyThemeFixes()
        {
            if (_dm == null) return;
            deleteAllRulesButton.FlatAppearance.BorderSize = 1;
            deleteAllRulesButton.FlatAppearance.BorderColor = _dm.OScolors.ControlDark;
            revertFirewallButton.FlatAppearance.BorderSize = 1;
            revertFirewallButton.FlatAppearance.BorderColor = _dm.OScolors.ControlDark;
            managePublishersButton.FlatAppearance.BorderSize = 1;
            managePublishersButton.FlatAppearance.BorderColor = _dm.OScolors.ControlDark;
            openFirewallButton.FlatAppearance.BorderSize = 1;
            openFirewallButton.FlatAppearance.BorderColor = _dm.OScolors.ControlDark;
            checkForUpdatesButton.FlatAppearance.BorderSize = 1;
            checkForUpdatesButton.FlatAppearance.BorderColor = _dm.OScolors.ControlDark;
            cleanUpOrphanedRulesButton.FlatAppearance.BorderSize = 1;
            cleanUpOrphanedRulesButton.FlatAppearance.BorderColor = _dm.OScolors.ControlDark;
            exportRulesButton.FlatAppearance.BorderSize = 1;
            exportRulesButton.FlatAppearance.BorderColor = _dm.OScolors.ControlDark;
            importMergeButton.FlatAppearance.BorderSize = 1;
            importMergeButton.FlatAppearance.BorderColor = _dm.OScolors.ControlDark;
            importReplaceButton.FlatAppearance.BorderSize = 1;
            importReplaceButton.FlatAppearance.BorderColor = _dm.OScolors.ControlDark;
            exportDiagnosticButton.FlatAppearance.BorderSize = 1;
            exportDiagnosticButton.FlatAppearance.BorderColor = _dm.OScolors.ControlDark;



            if (_dm.IsDarkMode)
            {
                deleteAllRulesButton.ForeColor = Color.White;
                revertFirewallButton.ForeColor = Color.White;
                managePublishersButton.ForeColor = Color.White;
                openFirewallButton.ForeColor = Color.White;
                checkForUpdatesButton.ForeColor = Color.White;
                cleanUpOrphanedRulesButton.ForeColor = Color.White;
                exportRulesButton.ForeColor = Color.White;
                importMergeButton.ForeColor = Color.White;
                importReplaceButton.ForeColor = Color.White;
                exportDiagnosticButton.ForeColor = Color.White;
            }
            else
            {
                deleteAllRulesButton.ForeColor = SystemColors.ControlText;
                revertFirewallButton.ForeColor = SystemColors.ControlText;
                managePublishersButton.ForeColor = SystemColors.ControlText;
                openFirewallButton.ForeColor = SystemColors.ControlText;
                checkForUpdatesButton.ForeColor = SystemColors.ControlText;
                cleanUpOrphanedRulesButton.ForeColor = SystemColors.ControlText;
                exportRulesButton.ForeColor = SystemColors.ControlText;
                importMergeButton.ForeColor = SystemColors.ControlText;
                importReplaceButton.ForeColor = SystemColors.ControlText;
                exportDiagnosticButton.ForeColor = SystemColors.ControlText;
            }
        }

        public void LoadSettingsToUI()
        {
            closeToTraySwitch.Checked = _appSettings.CloseToTray;
            startOnStartupSwitch.Checked = _appSettings.StartOnSystemStartup;
            darkModeSwitch.Checked = _appSettings.Theme == "Dark";
            popupsSwitch.Checked = _appSettings.IsPopupsEnabled;
            loggingSwitch.Checked = _appSettings.IsLoggingEnabled;
            useAppDataSwitch.Checked = _appSettings.UseAppDataStorage;
            autoRefreshTextBox.Text = _appSettings.AutoRefreshIntervalMinutes.ToString();
            trafficMonitorSwitch.Checked = _appSettings.IsTrafficMonitorEnabled;
            showAppIconsSwitch.Checked = _appSettings.ShowAppIcons;
            autoAllowSystemTrustedCheck.Checked = _appSettings.AutoAllowSystemTrusted;
            auditAlertsSwitch.Checked = _appSettings.AlertOnForeignRules;
            managePublishersButton.Enabled = true;
        }

        public void SaveSettingsFromUI()
        {
            _appSettings.CloseToTray = closeToTraySwitch.Checked;
            _appSettings.StartOnSystemStartup = startOnStartupSwitch.Checked;
            _appSettings.Theme = darkModeSwitch.Checked ? "Dark" : "Light";
            _appSettings.IsPopupsEnabled = popupsSwitch.Checked;
            _appSettings.IsLoggingEnabled = loggingSwitch.Checked;
            if (int.TryParse(autoRefreshTextBox.Text, out int val) && val >= 1)
            {
                _appSettings.AutoRefreshIntervalMinutes = val;
            }
            _appSettings.IsTrafficMonitorEnabled = trafficMonitorSwitch.Checked;
            _appSettings.ShowAppIcons = showAppIconsSwitch.Checked;
            _appSettings.AutoAllowSystemTrusted = autoAllowSystemTrustedCheck.Checked;
            _appSettings.AlertOnForeignRules = auditAlertsSwitch.Checked;


            bool appDataSettingChanged = _appSettings.UseAppDataStorage != useAppDataSwitch.Checked;
            if (appDataSettingChanged)
            {

                CopyConfigFiles(useAppDataSwitch.Checked);
                _appSettings.UseAppDataStorage = useAppDataSwitch.Checked;
            }


            _activityLogger.IsEnabled = _appSettings.IsLoggingEnabled;

            if (!_appSettings.IsTrafficMonitorEnabled)
            {
                _mainViewModel.TrafficMonitorViewModel.StopMonitoring();
            }

            IconVisibilityChanged?.Invoke();
            _appSettings.Save();
        }

        public void ApplyTheme(bool isDark, DarkModeCS dm)
        {
            var linkColor = isDark ?
                Color.SkyBlue : SystemColors.HotTrack;
            helpLink.LinkColor = linkColor;
            reportProblemLink.LinkColor = linkColor;
            forumLink.LinkColor = linkColor;
            coffeeLinkLabel.LinkColor = linkColor;
            helpLink.VisitedLinkColor = linkColor;
            reportProblemLink.VisitedLinkColor = linkColor;
            forumLink.VisitedLinkColor = linkColor;
            coffeeLinkLabel.VisitedLinkColor = linkColor;

            Image? coffeeImage = _appImageList.Images["coffee.png"];
            if (coffeeImage != null)
            {
                Color coffeeColor = isDark ?
                    Color.LightGray : Color.Black;
                Image? oldImage = coffeePictureBox.Image;
                coffeePictureBox.Image = DarkModeCS.RecolorImage(coffeeImage, coffeeColor);
                oldImage?.Dispose();
            }
        }

        private void DarkModeSwitch_CheckedChanged(object sender, EventArgs e)
        {
            _appSettings.Theme = darkModeSwitch.Checked ?
                "Dark" : "Light";
            ThemeChanged?.Invoke();
        }

        private void startOnStartupSwitch_CheckedChanged(object sender, EventArgs e)
        {
            if (_appSettings != null && _startupService != null)
            {
                _appSettings.StartOnSystemStartup = startOnStartupSwitch.Checked;
                _startupService.SetStartup(_appSettings.StartOnSystemStartup);
            }
        }

        private void PopupsSwitch_CheckedChanged(object sender, EventArgs e)
        {
            if (_appSettings != null)
            {
                _appSettings.IsPopupsEnabled = popupsSwitch.Checked;
            }
        }

        private void TrafficMonitorSwitch_CheckedChanged(object sender, EventArgs e)
        {
            _appSettings.IsTrafficMonitorEnabled = trafficMonitorSwitch.Checked;
            TrafficMonitorSettingChanged?.Invoke();
        }

        private void ShowAppIconsSwitch_CheckedChanged(object sender, EventArgs e)
        {
            _appSettings.ShowAppIcons = showAppIconsSwitch.Checked;
            IconVisibilityChanged?.Invoke();
        }

        private void managePublishersButton_Click(object sender, EventArgs e)
        {
            using var form = new ManagePublishersForm(_whitelistService, _appSettings);
            form.ShowDialog(this.FindForm());
        }

        private void OpenFirewallButton_Click(object sender, EventArgs e)
        {
            try
            {
                string wfPath = Path.Combine(Environment.SystemDirectory, "wf.msc");
                var startInfo = new ProcessStartInfo(wfPath)
                {
                    UseShellExecute = true
                };
                Process.Start(startInfo);
            }
            catch (Exception ex) when (ex is Win32Exception or FileNotFoundException)
            {
                Messenger.MessageBox($"Could not open Windows Firewall console.\n\nError: {ex.Message}", "Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
            }
        }

        private void CheckForUpdatesButton_Click(object sender, EventArgs e)
        {
            try
            {
                Process.Start(new ProcessStartInfo("https://github.com/deminimis/minimalfirewall/releases") { UseShellExecute = true });
            }
            catch (Exception ex) when (ex is Win32Exception or InvalidOperationException)
            {
                Messenger.MessageBox($"Could not open the link.\n\nError: {ex.Message}", "Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
            }
        }

        private void LinkLabel_LinkClicked(object sender, LinkLabelLinkClickedEventArgs e)
        {
            if (sender is not LinkLabel { Tag: string url }) return;
            try
            {
                Process.Start(new ProcessStartInfo(url) { UseShellExecute = true });
            }
            catch (Exception ex) when (ex is Win32Exception or InvalidOperationException)
            {
                Messenger.MessageBox($"Could not open the link.\n\nError: {ex.Message}", "Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
            }
        }

        private void CoffeeLink_Click(object sender, EventArgs e)
        {
            try
            {
                Process.Start(new ProcessStartInfo("https://www.buymeacoffee.com/deminimis") { UseShellExecute = true });
            }
            catch (Exception ex) when (ex is Win32Exception or InvalidOperationException)
            {
                Messenger.MessageBox($"Could not open the link.\n\nError: {ex.Message}", "Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
            }
        }

        private void CoffeePictureBox_MouseEnter(object? sender, EventArgs e)
        {
        }

        private void CoffeePictureBox_MouseLeave(object? sender, EventArgs e)
        {
        }

        private async void deleteAllRulesButton_Click(object sender, EventArgs e)
        {
            var result = Messenger.MessageBox("This will permanently delete all firewall rules created by this application. This action cannot be undone. Are you sure you want to continue?",
                "Delete All Rules", MessageBoxButtons.YesNo, MessageBoxIcon.Warning);
            if (result == DialogResult.Yes)
            {
                _actionsService.DeleteAllMfwRules();
                await (DataRefreshRequested?.Invoke() ?? Task.CompletedTask);
                Messenger.MessageBox("All Minimal Firewall rules have been deleted.", "Operation Complete", MessageBoxButtons.OK, MessageBoxIcon.None);
            }
        }

        private async void revertFirewallButton_Click(object sender, EventArgs e)
        {
            var result = Messenger.MessageBox("WARNING: This will reset your ENTIRE Windows Firewall configuration to its default state. " +
                "All custom rules, including those not created by this application, will be deleted. This action is irreversible.\n\n" +
                "Are you absolutely sure you want to continue?",
                "Revert Windows Firewall Confirmation", MessageBoxButtons.YesNo, MessageBoxIcon.Warning);
            if (result == DialogResult.Yes)
            {
                AdminTaskService.ResetFirewall();
                await (DataRefreshRequested?.Invoke() ?? Task.CompletedTask);
                Messenger.MessageBox("Windows Firewall has been reset to its default settings. It is recommended to restart the application.",
                    "Operation Complete", MessageBoxButtons.OK, MessageBoxIcon.None);
            }
        }

        private async void cleanUpOrphanedRulesButton_Click(object sender, EventArgs e)
        {
            var result = Messenger.MessageBox(
                "This will scan for rules whose associated application no longer exists on disk and delete them.\n\nAre you sure you want to continue?",
                "Clean Up Orphaned Rules",
                MessageBoxButtons.YesNo,
                MessageBoxIcon.Question);

            if (result == DialogResult.Yes)
            {
                await _mainViewModel.CleanUpOrphanedRulesAsync();
            }
        }

        private async void exportRulesButton_Click(object sender, EventArgs e)
        {
            using var saveDialog = new SaveFileDialog
            {
                Filter = "JSON files (*.json)|*.json|All files (*.*)|*.*",
                Title = "Export Minimal Firewall Rules",
                FileName = $"mfw_rules_backup_{DateTime.Now:yyyyMMdd}.json"
            };

            if (saveDialog.ShowDialog() == DialogResult.OK)
            {
                try
                {
                    string jsonContent = await _actionsService.ExportAllMfwRulesAsync();
                    await File.WriteAllTextAsync(saveDialog.FileName, jsonContent);
                    Messenger.MessageBox("All rules have been successfully exported.", "Export Complete", MessageBoxButtons.OK, MsgIcon.Success);
                }
                catch (Exception ex)
                {
                    Messenger.MessageBox($"An error occurred during export: {ex.Message}", "Export Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
                }
            }
        }

        private async void importMergeButton_Click(object sender, EventArgs e)
        {
            using var openDialog = new OpenFileDialog
            {
                Filter = "JSON files (*.json)|*.json|All files (*.*)|*.*",
                Title = "Import and Add Rules"
            };

            if (openDialog.ShowDialog() == DialogResult.OK)
            {
                try
                {
                    string jsonContent = await File.ReadAllTextAsync(openDialog.FileName);
                    await _actionsService.ImportRulesAsync(jsonContent, replace: false);
                    await (DataRefreshRequested?.Invoke() ?? Task.CompletedTask);
                    Messenger.MessageBox("Rules have been successfully imported and added.", "Import Complete", MessageBoxButtons.OK, MsgIcon.Success);
                }
                catch (Exception ex)
                {
                    Messenger.MessageBox($"An error occurred during import: {ex.Message}", "Import Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
                }
            }
        }

        private async void importReplaceButton_Click(object sender, EventArgs e)
        {
            var confirmResult = Messenger.MessageBox(
                "WARNING: This will delete ALL current Minimal Firewall rules before importing the new ones. This action cannot be undone.\n\nAre you sure you want to continue?",
                "Confirm Replace", MessageBoxButtons.YesNo, MessageBoxIcon.Warning);

            if (confirmResult == DialogResult.Yes)
            {
                using var openDialog = new OpenFileDialog
                {
                    Filter = "JSON files (*.json)|*.json|All files (*.*)|*.*",
                    Title = "Import and Replace Rules"
                };

                if (openDialog.ShowDialog() == DialogResult.OK)
                {
                    try
                    {
                        string jsonContent = await File.ReadAllTextAsync(openDialog.FileName);
                        await _actionsService.ImportRulesAsync(jsonContent, replace: true);
                        await (DataRefreshRequested?.Invoke() ?? Task.CompletedTask);
                        Messenger.MessageBox("All rules have been replaced successfully.", "Import Complete", MessageBoxButtons.OK, MsgIcon.Success);
                    }
                    catch (Exception ex)
                    {
                        Messenger.MessageBox($"An error occurred during import: {ex.Message}", "Import Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
                    }
                }
            }
        }

        private void useAppDataSwitch_CheckedChanged(object sender, EventArgs e)
        {
            bool settingChanged = _appSettings.UseAppDataStorage != useAppDataSwitch.Checked;

            if (settingChanged)
            {
                _appSettings.UseAppDataStorage = useAppDataSwitch.Checked;
                CopyConfigFiles(_appSettings.UseAppDataStorage);
                Messenger.MessageBox("You must restart the application for the configuration location change to take full effect.", "Restart Required", MessageBoxButtons.OK, MessageBoxIcon.Information);
            }
        }



        private void CopyConfigFiles(bool useAppData)
        {
            string sourceDir = useAppData ? ConfigPathManager.GetExeDirectory() : ConfigPathManager.GetAppDataDirectory();
            string destDir = useAppData ? ConfigPathManager.GetAppDataDirectory() : ConfigPathManager.GetExeDirectory();
            _activityLogger.LogDebug($"[Config Move] Copying files from {sourceDir} to {destDir}");

            try
            {
                if (useAppData && !Directory.Exists(destDir))
                {
                    Directory.CreateDirectory(destDir);
                    _activityLogger.LogDebug($"[Config Move] Created destination directory: {destDir}");
                }

                foreach (string fileName in ConfigPathManager.GetManagedConfigFileNames())
                {
                    string sourcePath = Path.Combine(sourceDir, fileName);
                    string destPath = Path.Combine(destDir, fileName);

                    if (File.Exists(sourcePath))
                    {
                        try
                        {
                            File.Copy(sourcePath, destPath, true);
                            _activityLogger.LogDebug($"[Config Move] Copied '{fileName}' to {destDir}");
                        }
                        catch (IOException ioEx)
                        {
                            _activityLogger.LogException($"CopyConfigFiles-Copy-{fileName}", ioEx);
                            MessageBox.Show($"Could not copy '{fileName}' to the new location. It might be in use.\nPlease restart the application.\nError: {ioEx.Message}",
                                            "File Copy Error", MessageBoxButtons.OK, MessageBoxIcon.Warning);
                        }
                        catch (UnauthorizedAccessException uaEx)
                        {
                            _activityLogger.LogException($"CopyConfigFiles-Access-{fileName}", uaEx);
                            MessageBox.Show($"Could not copy '{fileName}' due to permissions.\nPlease restart the application.\nError: {uaEx.Message}",
                                            "File Permission Error", MessageBoxButtons.OK, MessageBoxIcon.Warning);
                        }
                    }
                    else
                    {
                        _activityLogger.LogDebug($"[Config Move] Source file not found, skipping: {sourcePath}");
                    }
                }
            }
            catch (Exception ex)
            {
                _activityLogger.LogException("CopyConfigFiles-General", ex);
                MessageBox.Show($"An unexpected error occurred while preparing config file locations:\n{ex.Message}",
                                "Config Location Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
            }
        }

        private async Task<string> ReadLastNLinesAsync(string filePath, int n)
        {
            if (!File.Exists(filePath))
            {
                return $"{Path.GetFileName(filePath)} not found.";
            }

            try
            {
                var lines = await File.ReadAllLinesAsync(filePath);
                var lastNLines = lines.Skip(Math.Max(0, lines.Length - n));
                return string.Join(Environment.NewLine, lastNLines);
            }
            catch (Exception ex)
            {
                return $"Error reading {Path.GetFileName(filePath)}: {ex.Message}";
            }
        }
        private async void exportDiagnosticButton_Click(object sender, EventArgs e)
        {
            using var saveDialog = new SaveFileDialog
            {
                Filter = "Zip files (*.zip)|*.zip",
                Title = "Export Diagnostic Package",
                FileName = $"mfw_diagnostics_{DateTime.Now:yyyyMMdd_HHmmss}.zip"
            };

            if (saveDialog.ShowDialog() == DialogResult.OK)
            {
                string zipPath = saveDialog.FileName;
                var statusForm = new StatusForm("Gathering diagnostic data...", _appSettings);
                statusForm.Show(this.FindForm());
                Application.DoEvents();

                try
                {

                    if (File.Exists(zipPath)) File.Delete(zipPath);
                    using (var archive = ZipFile.Open(zipPath, ZipArchiveMode.Create))
                    {

                        statusForm.UpdateStatus("Adding configuration files...");
                        var configFiles = new List<string>
                        {
                            "settings.json",
                            "wildcard_rules.json",
                            "trusted_publishers.json",
                            "foreign_rules_baseline.json",
                            "temporary_rules.json",
                            "uwp_apps.json"
                        };

                        foreach (var fileName in configFiles)
                        {
                            string filePath = (fileName == "settings.json")
                                ? ConfigPathManager.GetSettingsPath()
                                : ConfigPathManager.GetConfigPath(fileName);

                            if (File.Exists(filePath))
                            {
                                archive.CreateEntryFromFile(filePath, fileName);
                            }
                        }
                        statusForm.UpdateProgress(20);


                        statusForm.UpdateStatus("Adding debug log...");
                        string debugLogPath = ConfigPathManager.GetConfigPath("debug_log.txt");
                        string logContent = await ReadLastNLinesAsync(debugLogPath, 1500);
                        var logEntry = archive.CreateEntry("debug_log_last500.txt");
                        using (var writer = new StreamWriter(logEntry.Open()))
                        {
                            await writer.WriteAsync(logContent);
                        }
                        statusForm.UpdateProgress(40);


                        statusForm.UpdateStatus("Exporting current rules...");
                        string rulesJson = await _actionsService.ExportAllMfwRulesAsync();
                        var rulesEntry = archive.CreateEntry("current_mfw_rules.json");
                        using (var writer = new StreamWriter(rulesEntry.Open()))
                        {
                            await writer.WriteAsync(rulesJson);
                        }
                        statusForm.UpdateProgress(60);


                        statusForm.UpdateStatus("Gathering system info...");
                        var sysInfo = new StringBuilder();
                        sysInfo.AppendLine($"OS Version: {Environment.OSVersion}");
                        sysInfo.AppendLine($".NET Runtime: {RuntimeInformation.FrameworkDescription}");
                        sysInfo.AppendLine($"App Version: {Assembly.GetExecutingAssembly().GetName()?.Version}");
                        sysInfo.AppendLine($"Timestamp: {DateTime.Now}");


                        var sysInfoEntry = archive.CreateEntry("system_info.txt");
                        using (var writer = new StreamWriter(sysInfoEntry.Open()))
                        {
                            await writer.WriteAsync(sysInfo.ToString());
                        }
                        statusForm.UpdateProgress(80);
                    }

                    statusForm.UpdateStatus("Finalizing package...");
                    statusForm.UpdateProgress(100);
                    statusForm.Close();
                    Messenger.MessageBox($"Diagnostic package exported successfully to:\n{zipPath}", "Export Complete", MessageBoxButtons.OK, MsgIcon.Success);
                }
                catch (Exception ex)
                {
                    statusForm?.Close();
                    _activityLogger.LogException("ExportDiagnosticPackage", ex);
                    Messenger.MessageBox($"An error occurred while exporting diagnostics:\n{ex.Message}", "Export Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
                }
            }
        }
    }
}



--------------------------------------------------
// Full Path: C:/Users/anon/PROGRAMMING/C#/SimpleFirewall/VS Minimal Firewall/MinimalFirewall-NET8/Backups/v2.5.5 - ws/2.5.5.6 - security vulnerability fix 3/SettingsControl.Designer.cs
--------------------------------------------------------------------------------
namespace MinimalFirewall
{
    partial class SettingsControl
    {
        private System.ComponentModel.IContainer components = null;

        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
                exportDiagnosticButton?.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Component Designer generated code

        private void InitializeComponent()
        {
            this.deleteAllRulesButton = new System.Windows.Forms.Button();
            this.revertFirewallButton = new System.Windows.Forms.Button();
            this.auditAlertsSwitch = new System.Windows.Forms.CheckBox();
            this.managePublishersButton = new System.Windows.Forms.Button();
            this.autoAllowSystemTrustedCheck = new System.Windows.Forms.CheckBox();
            this.showAppIconsSwitch = new System.Windows.Forms.CheckBox();
            this.trafficMonitorSwitch = new System.Windows.Forms.CheckBox();
            this.autoRefreshLabel1 = new System.Windows.Forms.Label();
            this.autoRefreshLabel2 = new System.Windows.Forms.Label();
            this.coffeePanel = new System.Windows.Forms.Panel();
            this.coffeeLinkLabel = new System.Windows.Forms.LinkLabel();
            this.coffeePictureBox = new System.Windows.Forms.PictureBox();
            this.versionLabel = new System.Windows.Forms.Label();
            this.checkForUpdatesButton = new System.Windows.Forms.Button();
            this.openFirewallButton = new System.Windows.Forms.Button();
            this.forumLink = new System.Windows.Forms.LinkLabel();
            this.reportProblemLink = new System.Windows.Forms.LinkLabel();
            this.helpLink = new System.Windows.Forms.LinkLabel();
            this.autoRefreshTextBox = new System.Windows.Forms.TextBox();
            this.loggingSwitch = new System.Windows.Forms.CheckBox();
            this.popupsSwitch = new System.Windows.Forms.CheckBox();
            this.darkModeSwitch = new System.Windows.Forms.CheckBox();
            this.startOnStartupSwitch = new System.Windows.Forms.CheckBox();
            this.closeToTraySwitch = new System.Windows.Forms.CheckBox();
            this.mainSettingsPanel = new System.Windows.Forms.Panel();
            this.exportDiagnosticButton = new System.Windows.Forms.Button();
            this.useAppDataSwitch = new System.Windows.Forms.CheckBox();
            this.importReplaceButton = new System.Windows.Forms.Button();
            this.importMergeButton = new System.Windows.Forms.Button();
            this.exportRulesButton = new System.Windows.Forms.Button();
            this.cleanUpOrphanedRulesButton = new System.Windows.Forms.Button();
            this.coffeePanel.SuspendLayout();
            ((System.ComponentModel.ISupportInitialize)(this.coffeePictureBox)).BeginInit();
            this.mainSettingsPanel.SuspendLayout();
            this.SuspendLayout();
            // 
            // deleteAllRulesButton
            // 
            this.deleteAllRulesButton.FlatAppearance.BorderSize = 0;
            this.deleteAllRulesButton.FlatStyle = System.Windows.Forms.FlatStyle.Flat;
            this.deleteAllRulesButton.Location = new System.Drawing.Point(29, 700);
            this.deleteAllRulesButton.Margin = new System.Windows.Forms.Padding(3, 4, 3, 4);
            this.deleteAllRulesButton.Name = "deleteAllRulesButton";
            this.deleteAllRulesButton.Size = new System.Drawing.Size(240, 37);
            this.deleteAllRulesButton.TabIndex = 25;
            this.deleteAllRulesButton.Text = "Delete all Minimal Firewall rules";
            this.deleteAllRulesButton.UseVisualStyleBackColor = true;
            this.deleteAllRulesButton.Click += new System.EventHandler(this.deleteAllRulesButton_Click);
            // 
            // revertFirewallButton
            // 
            this.revertFirewallButton.FlatAppearance.BorderSize = 0;
            this.revertFirewallButton.FlatStyle = System.Windows.Forms.FlatStyle.Flat;
            this.revertFirewallButton.Location = new System.Drawing.Point(280, 700);
            this.revertFirewallButton.Margin = new System.Windows.Forms.Padding(3, 4, 3, 4);
            this.revertFirewallButton.Name = "revertFirewallButton";
            this.revertFirewallButton.Size = new System.Drawing.Size(240, 37);
            this.revertFirewallButton.TabIndex = 26;
            this.revertFirewallButton.Text = "Revert Windows Firewall";
            this.revertFirewallButton.UseVisualStyleBackColor = true;
            this.revertFirewallButton.Click += new System.EventHandler(this.revertFirewallButton_Click);
            // 
            // auditAlertsSwitch
            // 
            this.auditAlertsSwitch.AutoSize = true;
            this.auditAlertsSwitch.Location = new System.Drawing.Point(350, 153);
            this.auditAlertsSwitch.Margin = new System.Windows.Forms.Padding(3, 4, 3, 4);
            this.auditAlertsSwitch.Name = "auditAlertsSwitch";
            this.auditAlertsSwitch.Size = new System.Drawing.Size(211, 24);
            this.auditAlertsSwitch.TabIndex = 24;
            this.auditAlertsSwitch.Text = "Alert on new system rules";
            this.auditAlertsSwitch.UseVisualStyleBackColor = true;
            // 
            // managePublishersButton
            // 
            this.managePublishersButton.FlatAppearance.BorderSize = 0;
            this.managePublishersButton.FlatStyle = System.Windows.Forms.FlatStyle.Flat;
            this.managePublishersButton.Location = new System.Drawing.Point(29, 350);
            this.managePublishersButton.Margin = new System.Windows.Forms.Padding(3, 4, 3, 4);
            this.managePublishersButton.Name = "managePublishersButton";
            this.managePublishersButton.Size = new System.Drawing.Size(200, 37);
            this.managePublishersButton.TabIndex = 23;
            this.managePublishersButton.Text = "Manage Trusted Publishers";
            this.managePublishersButton.UseVisualStyleBackColor = true;
            this.managePublishersButton.Click += new System.EventHandler(this.managePublishersButton_Click);
            // 
            // autoAllowSystemTrustedCheck
            // 
            this.autoAllowSystemTrustedCheck.AutoSize = true;
            this.autoAllowSystemTrustedCheck.Location = new System.Drawing.Point(350, 200);
            this.autoAllowSystemTrustedCheck.Margin = new System.Windows.Forms.Padding(3, 4, 3, 4);
            this.autoAllowSystemTrustedCheck.Name = "autoAllowSystemTrustedCheck";
            this.autoAllowSystemTrustedCheck.Size = new System.Drawing.Size(276, 24);
            this.autoAllowSystemTrustedCheck.TabIndex = 22;
            this.autoAllowSystemTrustedCheck.Text = "Auto-allow apps trusted by Windows";
            this.autoAllowSystemTrustedCheck.UseVisualStyleBackColor = true;
            // 
            // showAppIconsSwitch
            // 
            this.showAppIconsSwitch.AutoSize = true;
            this.showAppIconsSwitch.Location = new System.Drawing.Point(350, 107);
            this.showAppIconsSwitch.Margin = new System.Windows.Forms.Padding(3, 4, 3, 4);
            this.showAppIconsSwitch.Name = "showAppIconsSwitch";
            this.showAppIconsSwitch.Size = new System.Drawing.Size(177, 24);
            this.showAppIconsSwitch.TabIndex = 21;
            this.showAppIconsSwitch.Text = "Show application icons";
            this.showAppIconsSwitch.UseVisualStyleBackColor = true;
            this.showAppIconsSwitch.CheckedChanged += new System.EventHandler(this.ShowAppIconsSwitch_CheckedChanged);
            // 
            // trafficMonitorSwitch
            // 
            this.trafficMonitorSwitch.AutoSize = true;
            this.trafficMonitorSwitch.Location = new System.Drawing.Point(350, 60);
            this.trafficMonitorSwitch.Margin = new System.Windows.Forms.Padding(3, 4, 3, 4);
            this.trafficMonitorSwitch.Name = "trafficMonitorSwitch";
            this.trafficMonitorSwitch.Size = new System.Drawing.Size(191, 24);
            this.trafficMonitorSwitch.TabIndex = 20;
            this.trafficMonitorSwitch.Text = "Enable Live Connections";
            this.trafficMonitorSwitch.UseVisualStyleBackColor = true;
            this.trafficMonitorSwitch.CheckedChanged += new System.EventHandler(this.TrafficMonitorSwitch_CheckedChanged);
            // 
            // autoRefreshLabel1
            // 
            this.autoRefreshLabel1.AutoSize = true;
            this.autoRefreshLabel1.Location = new System.Drawing.Point(29, 299);
            this.autoRefreshLabel1.Name = "autoRefreshLabel1";
            this.autoRefreshLabel1.Size = new System.Drawing.Size(117, 20);
            this.autoRefreshLabel1.TabIndex = 18;
            this.autoRefreshLabel1.Text = "List refresh time:";
            // 
            // autoRefreshLabel2
            // 
            this.autoRefreshLabel2.AutoSize = true;
            this.autoRefreshLabel2.Location = new System.Drawing.Point(251, 299);
            this.autoRefreshLabel2.Name = "autoRefreshLabel2";
            this.autoRefreshLabel2.Size = new System.Drawing.Size(61, 20);
            this.autoRefreshLabel2.TabIndex = 19;
            this.autoRefreshLabel2.Text = "minutes";
            // 
            // coffeePanel
            // 
            this.coffeePanel.BackColor = System.Drawing.Color.Transparent;
            this.coffeePanel.Controls.Add(this.coffeeLinkLabel);
            this.coffeePanel.Controls.Add(this.coffeePictureBox);
            this.coffeePanel.Cursor = System.Windows.Forms.Cursors.Hand;
            this.coffeePanel.Location = new System.Drawing.Point(21, 570);
            this.coffeePanel.Margin = new System.Windows.Forms.Padding(3, 4, 3, 4);
            this.coffeePanel.Name = "coffeePanel";
            this.coffeePanel.Size = new System.Drawing.Size(434, 107);
            this.coffeePanel.TabIndex = 17;
            this.coffeePanel.Click += new System.EventHandler(this.CoffeeLink_Click);
            // 
            // coffeeLinkLabel
            // 
            this.coffeeLinkLabel.ActiveLinkColor = System.Drawing.Color.DodgerBlue;
            this.coffeeLinkLabel.AutoSize = true;
            this.coffeeLinkLabel.Location = new System.Drawing.Point(69, 24);
            this.coffeeLinkLabel.MaximumSize = new System.Drawing.Size(366, 0);
            this.coffeeLinkLabel.Name = "coffeeLinkLabel";
            this.coffeeLinkLabel.Size = new System.Drawing.Size(335, 20);
            this.coffeeLinkLabel.TabIndex = 15;
            this.coffeeLinkLabel.TabStop = true;
            this.coffeeLinkLabel.Tag = "https://www.buymeacoffee.com/deminimis";
            this.coffeeLinkLabel.Text = "Support my caffeine addiction if you like this app";
            this.coffeeLinkLabel.Click += new System.EventHandler(this.CoffeeLink_Click);
            // 
            // coffeePictureBox
            // 
            this.coffeePictureBox.Cursor = System.Windows.Forms.Cursors.Hand;
            this.coffeePictureBox.Location = new System.Drawing.Point(0, 0);
            this.coffeePictureBox.Margin = new System.Windows.Forms.Padding(3, 4, 3, 4);
            this.coffeePictureBox.Name = "coffeePictureBox";
            this.coffeePictureBox.Size = new System.Drawing.Size(62, 72);
            this.coffeePictureBox.SizeMode = System.Windows.Forms.PictureBoxSizeMode.CenterImage;
            this.coffeePictureBox.TabIndex = 13;
            this.coffeePictureBox.TabStop = false;
            this.coffeePictureBox.Click += new System.EventHandler(this.CoffeeLink_Click);
            this.coffeePictureBox.MouseEnter += new System.EventHandler(this.CoffeePictureBox_MouseEnter);
            this.coffeePictureBox.MouseLeave += new System.EventHandler(this.CoffeePictureBox_MouseLeave);
            // 
            // versionLabel
            // 
            this.versionLabel.AutoSize = true;
            this.versionLabel.Font = new System.Drawing.Font("Segoe UI", 9F);
            this.versionLabel.Location = new System.Drawing.Point(223, 470);
            this.versionLabel.Name = "versionLabel";
            this.versionLabel.Size = new System.Drawing.Size(57, 20);
            this.versionLabel.TabIndex = 12;
            this.versionLabel.Text = "Version";
            // 
            // checkForUpdatesButton
            // 
            this.checkForUpdatesButton.FlatAppearance.BorderSize = 0;
            this.checkForUpdatesButton.FlatStyle = System.Windows.Forms.FlatStyle.Flat;
            this.checkForUpdatesButton.Location = new System.Drawing.Point(29, 460);
            this.checkForUpdatesButton.Margin = new System.Windows.Forms.Padding(3, 4, 3, 4);
            this.checkForUpdatesButton.Name = "checkForUpdatesButton";
            this.checkForUpdatesButton.Size = new System.Drawing.Size(183, 37);
            this.checkForUpdatesButton.TabIndex = 11;
            this.checkForUpdatesButton.Text = "Check for Updates";
            this.checkForUpdatesButton.Click += new System.EventHandler(this.CheckForUpdatesButton_Click);
            // 
            // openFirewallButton
            // 
            this.openFirewallButton.FlatAppearance.BorderSize = 0;
            this.openFirewallButton.FlatStyle = System.Windows.Forms.FlatStyle.Flat;
            this.openFirewallButton.Location = new System.Drawing.Point(29, 420);
            this.openFirewallButton.Margin = new System.Windows.Forms.Padding(3, 4, 3, 4);
            this.openFirewallButton.Name = "openFirewallButton";
            this.openFirewallButton.Size = new System.Drawing.Size(183, 37);
            this.openFirewallButton.TabIndex = 10;
            this.openFirewallButton.Text = "Open Windows Firewall";
            this.openFirewallButton.Click += new System.EventHandler(this.OpenFirewallButton_Click);
            // 
            // forumLink
            // 
            this.forumLink.AutoSize = true;
            this.forumLink.Location = new System.Drawing.Point(29, 510);
            this.forumLink.Name = "forumLink";
            this.forumLink.Size = new System.Drawing.Size(140, 20);
            this.forumLink.TabIndex = 9;
            this.forumLink.TabStop = true;
            this.forumLink.Tag = "https://github.com/deminimis/minimalfirewall/discussions";
            this.forumLink.Text = "Forum / Discussions";
            this.forumLink.LinkClicked += new System.Windows.Forms.LinkLabelLinkClickedEventHandler(this.LinkLabel_LinkClicked);
            // 
            // reportProblemLink
            // 
            this.reportProblemLink.AutoSize = true;
            this.reportProblemLink.Location = new System.Drawing.Point(29, 530);
            this.reportProblemLink.Name = "reportProblemLink";
            this.reportProblemLink.Size = new System.Drawing.Size(126, 20);
            this.reportProblemLink.TabIndex = 8;
            this.reportProblemLink.TabStop = true;
            this.reportProblemLink.Tag = "https://github.com/deminimis/minimalfirewall/issues";
            this.reportProblemLink.Text = "Report a Problem";
            this.reportProblemLink.LinkClicked += new System.Windows.Forms.LinkLabelLinkClickedEventHandler(this.LinkLabel_LinkClicked);
            // 
            // helpLink
            // 
            this.helpLink.AutoSize = true;
            this.helpLink.Location = new System.Drawing.Point(29, 550);
            this.helpLink.Name = "helpLink";
            this.helpLink.Size = new System.Drawing.Size(158, 20);
            this.helpLink.TabIndex = 7;
            this.helpLink.TabStop = true;
            this.helpLink.Tag = "https://github.com/deminimis/minimalfirewall";
            this.helpLink.Text = "Help / Documentation";
            this.helpLink.LinkClicked += new System.Windows.Forms.LinkLabelLinkClickedEventHandler(this.LinkLabel_LinkClicked);
            // 
            // autoRefreshTextBox
            // 
            this.autoRefreshTextBox.Location = new System.Drawing.Point(171, 293);
            this.autoRefreshTextBox.Margin = new System.Windows.Forms.Padding(3, 4, 3, 4);
            this.autoRefreshTextBox.MaxLength = 3;
            this.autoRefreshTextBox.Name = "autoRefreshTextBox";
            this.autoRefreshTextBox.Size = new System.Drawing.Size(68, 27);
            this.autoRefreshTextBox.TabIndex = 5;
            this.autoRefreshTextBox.Text = "10";
            // 
            // loggingSwitch
            // 
            this.loggingSwitch.AutoSize = true;
            this.loggingSwitch.Location = new System.Drawing.Point(29, 247);
            this.loggingSwitch.Margin = new System.Windows.Forms.Padding(3, 4, 3, 4);
            this.loggingSwitch.Name = "loggingSwitch";
            this.loggingSwitch.Size = new System.Drawing.Size(132, 24);
            this.loggingSwitch.TabIndex = 4;
            this.loggingSwitch.Text = "Enable logging";
            this.loggingSwitch.UseVisualStyleBackColor = true;
            // 
            // popupsSwitch
            // 
            this.popupsSwitch.AutoSize = true;
            this.popupsSwitch.Location = new System.Drawing.Point(29, 200);
            this.popupsSwitch.Margin = new System.Windows.Forms.Padding(3, 4, 3, 4);
            this.popupsSwitch.Name = "popupsSwitch";
            this.popupsSwitch.Size = new System.Drawing.Size(216, 24);
            this.popupsSwitch.TabIndex = 3;
            this.popupsSwitch.Text = "Enable pop-up notifications";
            this.popupsSwitch.UseVisualStyleBackColor = true;
            this.popupsSwitch.CheckedChanged += new System.EventHandler(this.PopupsSwitch_CheckedChanged);
            // 
            // darkModeSwitch
            // 
            this.darkModeSwitch.AutoSize = true;
            this.darkModeSwitch.Location = new System.Drawing.Point(29, 153);
            this.darkModeSwitch.Margin = new System.Windows.Forms.Padding(3, 4, 3, 4);
            this.darkModeSwitch.Name = "darkModeSwitch";
            this.darkModeSwitch.Size = new System.Drawing.Size(105, 24);
            this.darkModeSwitch.TabIndex = 2;
            this.darkModeSwitch.Text = "Dark Mode";
            this.darkModeSwitch.UseVisualStyleBackColor = true;
            this.darkModeSwitch.CheckedChanged += new System.EventHandler(this.DarkModeSwitch_CheckedChanged);
            // 
            // startOnStartupSwitch
            // 
            this.startOnStartupSwitch.AutoSize = true;
            this.startOnStartupSwitch.Location = new System.Drawing.Point(29, 107);
            this.startOnStartupSwitch.Margin = new System.Windows.Forms.Padding(3, 4, 3, 4);
            this.startOnStartupSwitch.Name = "startOnStartupSwitch";
            this.startOnStartupSwitch.Size = new System.Drawing.Size(159, 24);
            this.startOnStartupSwitch.TabIndex = 1;
            this.startOnStartupSwitch.Text = "Start with Windows";
            this.startOnStartupSwitch.UseVisualStyleBackColor = true;
            this.startOnStartupSwitch.CheckedChanged += new System.EventHandler(this.startOnStartupSwitch_CheckedChanged);
            // 
            // closeToTraySwitch
            // 
            this.closeToTraySwitch.AutoSize = true;
            this.closeToTraySwitch.Checked = true;
            this.closeToTraySwitch.CheckState = System.Windows.Forms.CheckState.Checked;
            this.closeToTraySwitch.Location = new System.Drawing.Point(29, 60);
            this.closeToTraySwitch.Margin = new System.Windows.Forms.Padding(3, 4, 3, 4);
            this.closeToTraySwitch.Name = "closeToTraySwitch";
            this.closeToTraySwitch.Size = new System.Drawing.Size(114, 24);
            this.closeToTraySwitch.TabIndex = 0;
            this.closeToTraySwitch.Text = "Close to tray";
            this.closeToTraySwitch.UseVisualStyleBackColor = true;
            // 
            // mainSettingsPanel
            // 
            this.mainSettingsPanel.AutoScroll = true;
            this.mainSettingsPanel.Controls.Add(this.exportDiagnosticButton);
            this.mainSettingsPanel.Controls.Add(this.useAppDataSwitch);
            this.mainSettingsPanel.Controls.Add(this.importReplaceButton);
            this.mainSettingsPanel.Controls.Add(this.importMergeButton);
            this.mainSettingsPanel.Controls.Add(this.exportRulesButton);
            this.mainSettingsPanel.Controls.Add(this.cleanUpOrphanedRulesButton);
            this.mainSettingsPanel.Controls.Add(this.deleteAllRulesButton);
            this.mainSettingsPanel.Controls.Add(this.revertFirewallButton);
            this.mainSettingsPanel.Controls.Add(this.auditAlertsSwitch);
            this.mainSettingsPanel.Controls.Add(this.managePublishersButton);
            this.mainSettingsPanel.Controls.Add(this.autoAllowSystemTrustedCheck);
            this.mainSettingsPanel.Controls.Add(this.showAppIconsSwitch);
            this.mainSettingsPanel.Controls.Add(this.trafficMonitorSwitch);
            this.mainSettingsPanel.Controls.Add(this.autoRefreshLabel1);
            this.mainSettingsPanel.Controls.Add(this.autoRefreshLabel2);
            this.mainSettingsPanel.Controls.Add(this.coffeePanel);
            this.mainSettingsPanel.Controls.Add(this.versionLabel);
            this.mainSettingsPanel.Controls.Add(this.checkForUpdatesButton);
            this.mainSettingsPanel.Controls.Add(this.openFirewallButton);
            this.mainSettingsPanel.Controls.Add(this.forumLink);
            this.mainSettingsPanel.Controls.Add(this.reportProblemLink);
            this.mainSettingsPanel.Controls.Add(this.helpLink);
            this.mainSettingsPanel.Controls.Add(this.autoRefreshTextBox);
            this.mainSettingsPanel.Controls.Add(this.loggingSwitch);
            this.mainSettingsPanel.Controls.Add(this.popupsSwitch);
            this.mainSettingsPanel.Controls.Add(this.darkModeSwitch);
            this.mainSettingsPanel.Controls.Add(this.startOnStartupSwitch);
            this.mainSettingsPanel.Controls.Add(this.closeToTraySwitch);
            this.mainSettingsPanel.Dock = System.Windows.Forms.DockStyle.Fill;
            this.mainSettingsPanel.Location = new System.Drawing.Point(0, 0);
            this.mainSettingsPanel.Name = "mainSettingsPanel";
            this.mainSettingsPanel.Size = new System.Drawing.Size(1015, 925);
            this.mainSettingsPanel.TabIndex = 27;
            // 
            // exportDiagnosticButton
            // 
            this.exportDiagnosticButton.FlatAppearance.BorderSize = 0;
            this.exportDiagnosticButton.FlatStyle = System.Windows.Forms.FlatStyle.Flat;
            this.exportDiagnosticButton.Location = new System.Drawing.Point(29, 840);
            this.exportDiagnosticButton.Margin = new System.Windows.Forms.Padding(3, 4, 3, 4);
            this.exportDiagnosticButton.Name = "exportDiagnosticButton";
            this.exportDiagnosticButton.Size = new System.Drawing.Size(240, 37);
            this.exportDiagnosticButton.TabIndex = 32;
            this.exportDiagnosticButton.Text = "Export Diagnostic Package...";
            this.exportDiagnosticButton.UseVisualStyleBackColor = true;
            this.exportDiagnosticButton.Click += new System.EventHandler(this.exportDiagnosticButton_Click);
            // 
            // useAppDataSwitch
            // 
            this.useAppDataSwitch.AutoSize = true;
            this.useAppDataSwitch.Location = new System.Drawing.Point(350, 247);
            this.useAppDataSwitch.Margin = new System.Windows.Forms.Padding(3, 4, 3, 4);
            this.useAppDataSwitch.Name = "useAppDataSwitch";
            this.useAppDataSwitch.Size = new System.Drawing.Size(247, 24);
            this.useAppDataSwitch.TabIndex = 31;
            this.useAppDataSwitch.Text = "Store config files in %AppData%";
            this.useAppDataSwitch.UseVisualStyleBackColor = true;
            this.useAppDataSwitch.CheckedChanged += new System.EventHandler(this.useAppDataSwitch_CheckedChanged);
            // 
            // importReplaceButton
            // 
            this.importReplaceButton.FlatAppearance.BorderSize = 0;
            this.importReplaceButton.FlatStyle = System.Windows.Forms.FlatStyle.Flat;
            this.importReplaceButton.Location = new System.Drawing.Point(531, 790);
            this.importReplaceButton.Margin = new System.Windows.Forms.Padding(3, 4, 3, 4);
            this.importReplaceButton.Name = "importReplaceButton";
            this.importReplaceButton.Size = new System.Drawing.Size(240, 37);
            this.importReplaceButton.TabIndex = 30;
            this.importReplaceButton.Text = "Import && Replace Rules...";
            this.importReplaceButton.UseVisualStyleBackColor = true;
            this.importReplaceButton.Click += new System.EventHandler(this.importReplaceButton_Click);
            // 
            // importMergeButton
            // 
            this.importMergeButton.FlatAppearance.BorderSize = 0;
            this.importMergeButton.FlatStyle = System.Windows.Forms.FlatStyle.Flat;
            this.importMergeButton.Location = new System.Drawing.Point(280, 790);
            this.importMergeButton.Margin = new System.Windows.Forms.Padding(3, 4, 3, 4);
            this.importMergeButton.Name = "importMergeButton";
            this.importMergeButton.Size = new System.Drawing.Size(240, 37);
            this.importMergeButton.TabIndex = 29;
            this.importMergeButton.Text = "Import && Add Rules...";
            this.importMergeButton.UseVisualStyleBackColor = true;
            this.importMergeButton.Click += new System.EventHandler(this.importMergeButton_Click);
            // 
            // exportRulesButton
            // 
            this.exportRulesButton.FlatAppearance.BorderSize = 0;
            this.exportRulesButton.FlatStyle = System.Windows.Forms.FlatStyle.Flat;
            this.exportRulesButton.Location = new System.Drawing.Point(29, 790);
            this.exportRulesButton.Margin = new System.Windows.Forms.Padding(3, 4, 3, 4);
            this.exportRulesButton.Name = "exportRulesButton";
            this.exportRulesButton.Size = new System.Drawing.Size(240, 37);
            this.exportRulesButton.TabIndex = 28;
            this.exportRulesButton.Text = "Export Rules...";
            this.exportRulesButton.UseVisualStyleBackColor = true;
            this.exportRulesButton.Click += new System.EventHandler(this.exportRulesButton_Click);
            // 
            // cleanUpOrphanedRulesButton
            // 
            this.cleanUpOrphanedRulesButton.FlatAppearance.BorderSize = 0;
            this.cleanUpOrphanedRulesButton.FlatStyle = System.Windows.Forms.FlatStyle.Flat;
            this.cleanUpOrphanedRulesButton.Location = new System.Drawing.Point(530, 700);
            this.cleanUpOrphanedRulesButton.Margin = new System.Windows.Forms.Padding(3, 4, 3, 4);
            this.cleanUpOrphanedRulesButton.Name = "cleanUpOrphanedRulesButton";
            this.cleanUpOrphanedRulesButton.Size = new System.Drawing.Size(240, 37);
            this.cleanUpOrphanedRulesButton.TabIndex = 27;
            this.cleanUpOrphanedRulesButton.Text = "Clean Up Orphaned Rules";
            this.cleanUpOrphanedRulesButton.UseVisualStyleBackColor = true;
            this.cleanUpOrphanedRulesButton.Click += new System.EventHandler(this.cleanUpOrphanedRulesButton_Click);
            // 
            // SettingsControl
            // 
            this.AutoScaleDimensions = new System.Drawing.SizeF(8F, 20F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.Controls.Add(this.mainSettingsPanel);
            this.Name = "SettingsControl";
            this.Size = new System.Drawing.Size(1015, 925);
            this.coffeePanel.ResumeLayout(false);
            this.coffeePanel.PerformLayout();
            ((System.ComponentModel.ISupportInitialize)(this.coffeePictureBox)).EndInit();
            this.mainSettingsPanel.ResumeLayout(false);
            this.mainSettingsPanel.PerformLayout();
            this.ResumeLayout(false);

        }

        #endregion
        private System.Windows.Forms.Button deleteAllRulesButton;
        private System.Windows.Forms.Button revertFirewallButton;
        private System.Windows.Forms.CheckBox auditAlertsSwitch;
        private System.Windows.Forms.Button managePublishersButton;
        private System.Windows.Forms.CheckBox autoAllowSystemTrustedCheck;
        private System.Windows.Forms.CheckBox showAppIconsSwitch;
        private System.Windows.Forms.CheckBox trafficMonitorSwitch;
        private System.Windows.Forms.Label autoRefreshLabel1;
        private System.Windows.Forms.Label autoRefreshLabel2;
        private System.Windows.Forms.Panel coffeePanel;
        private System.Windows.Forms.LinkLabel coffeeLinkLabel;
        private System.Windows.Forms.PictureBox coffeePictureBox;
        private System.Windows.Forms.Label versionLabel;
        private System.Windows.Forms.Button checkForUpdatesButton;
        private System.Windows.Forms.Button openFirewallButton;
        private System.Windows.Forms.LinkLabel forumLink;
        private System.Windows.Forms.LinkLabel reportProblemLink;
        private System.Windows.Forms.LinkLabel helpLink;
        private System.Windows.Forms.TextBox autoRefreshTextBox;
        private System.Windows.Forms.CheckBox loggingSwitch;
        private System.Windows.Forms.CheckBox popupsSwitch;
        private System.Windows.Forms.CheckBox darkModeSwitch;
        private System.Windows.Forms.CheckBox startOnStartupSwitch;
        private System.Windows.Forms.CheckBox closeToTraySwitch;
        private System.Windows.Forms.Panel mainSettingsPanel;
        private System.Windows.Forms.Button cleanUpOrphanedRulesButton;
        private Button importReplaceButton;
        private Button importMergeButton;
        private Button exportRulesButton;
        private CheckBox useAppDataSwitch;
        private Button exportDiagnosticButton;
        private Button allowWindowsUpdateButton;
    }
}



--------------------------------------------------
// Full Path: C:/Users/anon/PROGRAMMING/C#/SimpleFirewall/VS Minimal Firewall/MinimalFirewall-NET8/Backups/v2.5.5 - ws/2.5.5.6 - security vulnerability fix 3/SignatureValidationService.cs
--------------------------------------------------------------------------------
// File: SignatureValidationService.cs
using System.Diagnostics;
using System.IO;
using System.Security.Cryptography;
using System.Security.Cryptography.X509Certificates;

namespace MinimalFirewall
{
    public static class SignatureValidationService
    {
        public static bool GetPublisherInfo(string filePath, out string? publisherName)
        {
            publisherName = null;
            if (string.IsNullOrEmpty(filePath) || !File.Exists(filePath))
            {
                return false;
            }

            try
            {
                using (var cert = X509Certificate.CreateFromSignedFile(filePath))
                {
                    publisherName = cert.Subject;
                    return !string.IsNullOrEmpty(publisherName);
                }
            }
            catch (CryptographicException)
            {
                return false;
            }
            catch (Exception ex) when (ex is IOException or UnauthorizedAccessException)
            {
                Debug.WriteLine($"[ERROR] Signature extraction failed for {filePath}: {ex.Message}");
                return false;
            }
        }

        public static bool IsSignatureTrusted(string filePath, out string? publisherName)
        {
            publisherName = null;
            if (!GetPublisherInfo(filePath, out publisherName))
            {
                return false;
            }

            try
            {
                using (var cert = X509Certificate.CreateFromSignedFile(filePath))
                using (var cert2 = new X509Certificate2(cert))
                using (var chain = new X509Chain())
                {
                    return chain.Build(cert2);
                }
            }
            catch (Exception ex) when (ex is CryptographicException or IOException or UnauthorizedAccessException)
            {
                Debug.WriteLine($"[ERROR] Signature chain validation failed for {filePath}: {ex.Message}");
                return false;
            }
        }
    }
}

--------------------------------------------------
// Full Path: C:/Users/anon/PROGRAMMING/C#/SimpleFirewall/VS Minimal Firewall/MinimalFirewall-NET8/Backups/v2.5.5 - ws/2.5.5.6 - security vulnerability fix 3/SortableBindingList.cs
--------------------------------------------------------------------------------
// File: SortableBindingList.cs
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Reflection;

namespace MinimalFirewall
{
    public class SortableBindingList<T> : BindingList<T>
    {
        private PropertyDescriptor? _sortProperty;
        private ListSortDirection _sortDirection;

        public SortableBindingList(IList<T> list) : base(list) { }

        protected override bool SupportsSortingCore => true;
        protected override bool IsSortedCore => _sortProperty != null;
        protected override PropertyDescriptor? SortPropertyCore => _sortProperty;
        protected override ListSortDirection SortDirectionCore => _sortDirection;

        private static object? GetNestedPropertyValue(object? obj, string propertyName)
        {
            if (obj == null || string.IsNullOrEmpty(propertyName)) return null;

            object? currentObject = obj;
            foreach (string part in propertyName.Split('.'))
            {
                if (currentObject == null) return null;
                Type type = currentObject.GetType();
                PropertyInfo? info = type.GetProperty(part);
                if (info == null) return null;
                currentObject = info.GetValue(currentObject, null);
            }
            return currentObject;
        }

        protected override void ApplySortCore(PropertyDescriptor prop, ListSortDirection direction)
        {
            _sortProperty = prop;
            _sortDirection = direction;

            if (Items is List<T> items)
            {
                items.Sort((a, b) =>
                {
                    var valueA = GetNestedPropertyValue(a, prop.Name);
                    var valueB = GetNestedPropertyValue(b, prop.Name);

                    int result = (valueA as IComparable)?.CompareTo(valueB) ?? 0;
                    return direction == ListSortDirection.Ascending ? result : -result;
                });

                ResetBindings();
            }
        }

        public void Sort(string propertyName, ListSortDirection direction)
        {
            var prop = TypeDescriptor.GetProperties(typeof(T)).Find(propertyName, true);
            if (prop != null)
            {
                ApplySortCore(prop, direction);
            }
        }
    }
}

--------------------------------------------------
// Full Path: C:/Users/anon/PROGRAMMING/C#/SimpleFirewall/VS Minimal Firewall/MinimalFirewall-NET8/Backups/v2.5.5 - ws/2.5.5.6 - security vulnerability fix 3/StatusForm.cs
--------------------------------------------------------------------------------
// File: StatusForm.cs
using DarkModeForms;
using System;
using System.Drawing;
using System.Windows.Forms;

namespace MinimalFirewall
{
    public partial class StatusForm : Form
    {
        private readonly DarkModeCS dm;
        private System.Windows.Forms.Timer _initialLoadTimer;
        private int _fakeProgress;
        private bool _realProgressStarted;

        public StatusForm(string title, AppSettings appSettings)
        {
            InitializeComponent();
            dm = new DarkModeCS(this);
            dm.ColorMode = appSettings.Theme == "Dark" ? DarkModeCS.DisplayMode.DarkMode : DarkModeCS.DisplayMode.ClearMode;
            dm.ApplyTheme(appSettings.Theme == "Dark");
            this.Text = title;
            this.statusLabel.Text = title;
            this.progressLabel.Text = "0%";
            this.progressBar.Value = 0;
            this.progressBar.Style = System.Windows.Forms.ProgressBarStyle.Blocks;

            _fakeProgress = 0;
            _realProgressStarted = false;

            _initialLoadTimer = new System.Windows.Forms.Timer
            {
                Interval = 150
            };
            _initialLoadTimer.Tick += InitialLoadTimer_Tick;
            _initialLoadTimer.Start();

            this.FormClosing += (s, e) => _initialLoadTimer?.Dispose();
        }

        private void InitialLoadTimer_Tick(object? sender, EventArgs e)
        {
            _fakeProgress++;
            progressBar.Value = _fakeProgress;
            progressLabel.Text = $"{_fakeProgress}%";

            if (_fakeProgress >= 10)
            {
                _initialLoadTimer.Stop();
            }
        }

        public void UpdateStatus(string message)
        {
            this.statusLabel.Text = message;
            Application.DoEvents();
        }

        public void UpdateProgress(int percentage)
        {
            if (this.InvokeRequired)
            {
                this.Invoke(() => UpdateProgress(percentage));
                return;
            }

            if (!_realProgressStarted)
            {
                _realProgressStarted = true;
                _initialLoadTimer.Stop();
            }

            int newProgress = Math.Max(_fakeProgress, percentage);
            progressBar.Value = Math.Clamp(newProgress, 0, 100);
            progressLabel.Text = $"{progressBar.Value}%";
        }

        protected override void OnLoad(EventArgs e)
        {
            base.OnLoad(e);
            if (Owner != null)
            {
                Location = new Point(Owner.Location.X + (Owner.Width - Width) / 2,
                                       Owner.Location.Y + (Owner.Height - Height) / 2);
            }
        }

        public void Complete(string message)
        {
            this.statusLabel.Text = message;
            this.progressBar.Visible = false;
            this.progressLabel.Visible = false;
            this.okButton.Visible = true;
            this.Text = "Scan Complete";
            this.okButton.Focus();
        }

        private void okButton_Click(object sender, EventArgs e)
        {
            this.Close();
        }
    }
}

--------------------------------------------------
// Full Path: C:/Users/anon/PROGRAMMING/C#/SimpleFirewall/VS Minimal Firewall/MinimalFirewall-NET8/Backups/v2.5.5 - ws/2.5.5.6 - security vulnerability fix 3/StatusForm.Designer.cs
--------------------------------------------------------------------------------
// File: StatusForm.Designer.cs
namespace MinimalFirewall
{
    public partial class StatusForm
    {
        private System.ComponentModel.IContainer components = null;
        private System.Windows.Forms.Label statusLabel;
        private System.Windows.Forms.ProgressBar progressBar;
        private System.Windows.Forms.Label progressLabel;
        private System.Windows.Forms.Button okButton;

        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        private void InitializeComponent()
        {
            this.statusLabel = new System.Windows.Forms.Label();
            this.okButton = new System.Windows.Forms.Button();
            this.progressBar = new System.Windows.Forms.ProgressBar();
            this.progressLabel = new System.Windows.Forms.Label();
            this.SuspendLayout();
            // 
            // statusLabel
            // 
            this.statusLabel.Location = new System.Drawing.Point(6, 20);
            this.statusLabel.Name = "statusLabel";
            this.statusLabel.Size = new System.Drawing.Size(388, 23);
            this.statusLabel.TabIndex = 0;
            this.statusLabel.Text = "Scanning, please wait...";
            this.statusLabel.TextAlign = System.Drawing.ContentAlignment.MiddleCenter;
            // 
            // okButton
            // 
            this.okButton.Location = new System.Drawing.Point(150, 90);
            this.okButton.Name = "okButton";
            this.okButton.Size = new System.Drawing.Size(100, 36);
            this.okButton.TabIndex = 2;
            this.okButton.Text = "OK";
            this.okButton.UseVisualStyleBackColor = true;
            this.okButton.Visible = false;
            this.okButton.Click += new System.EventHandler(this.okButton_Click);
            // 
            // progressBar
            // 
            this.progressBar.Location = new System.Drawing.Point(28, 60);
            this.progressBar.Name = "progressBar";
            this.progressBar.Size = new System.Drawing.Size(280, 23);
            this.progressBar.TabIndex = 1;
            // 
            // progressLabel
            // 
            this.progressLabel.Location = new System.Drawing.Point(314, 60);
            this.progressLabel.Name = "progressLabel";
            this.progressLabel.Size = new System.Drawing.Size(59, 23);
            this.progressLabel.TabIndex = 3;
            this.progressLabel.Text = "0%";
            this.progressLabel.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
            // 
            // StatusForm
            // 
            this.AutoScaleDimensions = new System.Drawing.SizeF(7F, 15F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.ClientSize = new System.Drawing.Size(400, 150);
            this.Controls.Add(this.progressLabel);
            this.Controls.Add(this.okButton);
            this.Controls.Add(this.progressBar);
            this.Controls.Add(this.statusLabel);
            this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedDialog;
            this.MaximizeBox = false;
            this.MinimizeBox = false;
            this.Name = "StatusForm";
            this.StartPosition = System.Windows.Forms.FormStartPosition.CenterParent;
            this.Text = "Scanning...";
            this.ResumeLayout(false);

        }

        #endregion
    }
}

--------------------------------------------------
// Full Path: C:/Users/anon/PROGRAMMING/C#/SimpleFirewall/VS Minimal Firewall/MinimalFirewall-NET8/Backups/v2.5.5 - ws/2.5.5.6 - security vulnerability fix 3/SystemDiscoveryService.cs
--------------------------------------------------------------------------------
// File: SystemDiscoveryService.cs
using DarkModeForms;
using System.IO;
using System.Management;
using System.Diagnostics;

namespace MinimalFirewall
{
    public static class SystemDiscoveryService
    {
        private static bool _wmiQueryFailedMessageShown = false;

        public static List<ServiceViewModel> GetServicesWithExePaths()
        {
            var services = new List<ServiceViewModel>();
            try
            {
                var wmiQuery = new ObjectQuery("SELECT Name, DisplayName, PathName FROM Win32_Service WHERE PathName IS NOT NULL");
                using var searcher = new ManagementObjectSearcher(wmiQuery);
                using var results = searcher.Get();
                foreach (ManagementBaseObject serviceBaseObject in results)
                {
                    using var service = (ManagementObject)serviceBaseObject;
                    string rawPath = service["PathName"]?.ToString() ?? string.Empty;
                    if (string.IsNullOrEmpty(rawPath)) continue;

                    string pathName = rawPath.Trim('"');
                    int exeIndex = pathName.IndexOf(".exe", StringComparison.OrdinalIgnoreCase);
                    if (exeIndex > 0)
                    {
                        pathName = pathName[..(exeIndex + 4)];
                    }

                    if (!string.IsNullOrEmpty(pathName))
                    {
                        services.Add(new ServiceViewModel
                        {
                            ExePath = pathName,
                            DisplayName = service["DisplayName"]?.ToString() ?? "",
                            ServiceName = service["Name"]?.ToString() ?? ""
                        });
                    }
                }
            }
            catch (Exception ex) when (ex is ManagementException or System.Runtime.InteropServices.COMException)
            {
                Debug.WriteLine("WMI Query failed: " + ex.Message);
                if (!_wmiQueryFailedMessageShown)
                {
                    Messenger.MessageBox("Could not query Windows Services (WMI).", "Feature Unavailable", MessageBoxButtons.OK, MessageBoxIcon.Warning);
                    _wmiQueryFailedMessageShown = true;
                }
            }
            return services;
        }

        public static string GetServicesByPID(string processId)
        {
            if (string.IsNullOrEmpty(processId) || processId == "0" || !uint.TryParse(processId, out _))
            {
                return string.Empty;
            }

            var serviceNames = new List<string?>();
            try
            {
                var query = new ObjectQuery($"SELECT Name FROM Win32_Service WHERE ProcessId = {processId}");
                using var searcher = new ManagementObjectSearcher(query);
                using var results = searcher.Get();
                foreach (ManagementBaseObject serviceBaseObject in results)
                {
                    using (var service = (ManagementObject)serviceBaseObject)
                    {
                        serviceNames.Add(service["Name"]?.ToString());
                    }
                }
                return string.Join(", ", serviceNames.Where(n => !string.IsNullOrEmpty(n)));
            }
            catch (Exception ex) when (ex is ManagementException or System.Runtime.InteropServices.COMException)
            {
                Debug.WriteLine($"WMI Query for PID failed: {ex.Message}");
                return string.Empty;
            }
        }

        public static List<string> GetFilesInFolder(string directoryPath, List<string> searchPatterns)
        {
            var files = new List<string>();
            if (searchPatterns == null || searchPatterns.Count == 0)
            {
                return files;
            }
            GetFilesInFolderRecursive(directoryPath, searchPatterns, files);
            return files;
        }

        private static void GetFilesInFolderRecursive(string directoryPath, List<string> searchPatterns, List<string> files)
        {
            try
            {
                foreach (string pattern in searchPatterns)
                {
                    files.AddRange(Directory.GetFiles(directoryPath, pattern));
                }
                foreach (var directory in Directory.GetDirectories(directoryPath))
                {
                    GetFilesInFolderRecursive(directory, searchPatterns, files);
                }
            }
            catch (UnauthorizedAccessException) { }
            catch (IOException ex)
            {
                Debug.WriteLine($"Error scanning folder {directoryPath}: {ex.Message}");
            }
        }
    }
}

--------------------------------------------------
// Full Path: C:/Users/anon/PROGRAMMING/C#/SimpleFirewall/VS Minimal Firewall/MinimalFirewall-NET8/Backups/v2.5.5 - ws/2.5.5.6 - security vulnerability fix 3/TemporaryRuleManager.cs
--------------------------------------------------------------------------------
// File: TemporaryRuleManager.cs
using System.Collections.Concurrent;
using System.Diagnostics;
using System.IO;
using System.Text.Json;
using System.Text.Json.Serialization;

namespace MinimalFirewall
{
    public class TemporaryRuleManager
    {
        private readonly string _storagePath;
        private readonly ConcurrentDictionary<string, DateTime> _temporaryRules;

        public TemporaryRuleManager()
        {
            _storagePath = ConfigPathManager.GetConfigPath("temporary_rules.json");
            _temporaryRules = Load();
        }

        private ConcurrentDictionary<string, DateTime> Load()
        {
            try
            {
                if (File.Exists(_storagePath))
                {
                    string json = File.ReadAllText(_storagePath);
                    var rules = JsonSerializer.Deserialize(json, TempRuleJsonContext.Default.DictionaryStringDateTime);
                    return new ConcurrentDictionary<string, DateTime>(rules ?? new Dictionary<string, DateTime>(), StringComparer.OrdinalIgnoreCase);
                }
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"[ERROR] Failed to load temporary rules: {ex.Message}");
            }
            return new ConcurrentDictionary<string, DateTime>(StringComparer.OrdinalIgnoreCase);
        }

        private void Save()
        {
            try
            {
                var rulesToSave = new Dictionary<string, DateTime>(_temporaryRules, StringComparer.OrdinalIgnoreCase);
                string json = JsonSerializer.Serialize(rulesToSave, TempRuleJsonContext.Default.DictionaryStringDateTime);
                File.WriteAllText(_storagePath, json);
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"[ERROR] Failed to save temporary rules: {ex.Message}");
            }
        }

        public void Add(string ruleName, DateTime expiryTimeUtc)
        {
            _temporaryRules[ruleName] = expiryTimeUtc;
            Save();
        }

        public void Remove(string ruleName)
        {
            if (_temporaryRules.TryRemove(ruleName, out _))
            {
                Save();
            }
        }

        public Dictionary<string, DateTime> GetExpiredRules()
        {
            var now = DateTime.UtcNow;
            return _temporaryRules
                .Where(kvp => kvp.Value <= now)
                .ToDictionary(kvp => kvp.Key, kvp => kvp.Value);
        }
    }

    [JsonSourceGenerationOptions(WriteIndented = true)]
    [JsonSerializable(typeof(Dictionary<string, DateTime>))]
    internal partial class TempRuleJsonContext : JsonSerializerContext { }
}

--------------------------------------------------
// Full Path: C:/Users/anon/PROGRAMMING/C#/SimpleFirewall/VS Minimal Firewall/MinimalFirewall-NET8/Backups/v2.5.5 - ws/2.5.5.6 - security vulnerability fix 3/TypedObjects.cs
--------------------------------------------------------------------------------
// File: TypedObjects.cs
using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Net;
namespace MinimalFirewall.TypedObjects
{
    public enum Actions : byte
    {
        Block = 0,
        Allow = 1
    }

    [Flags]
    public enum Directions : byte
    {
        Incoming = 1,
        Outgoing = 2
    }

    [Flags]
    public enum InterfaceTypes : byte
    {

        All = RemoteAccess | Wireless | Lan,
        RemoteAccess = 1,
        Wireless = 2,
        Lan = 4
    }

    public enum SpecificLocalPort : byte
    {
        RPC,
        RPC_EPMap,
        IPHTTPS
    }

    public interface IFixedRange<TUnit>
    {
        TUnit
 Begin
        { get; }
        TUnit End
        {
            get;
        }
    }

    [Serializable]
    public class PortRange : IFixedRange<ushort>, IEquatable<PortRange>
    {
        private readonly bool _isSinglePort;
        private readonly SpecificLocalPort? _specificLocalPort;
        public ushort Begin { get; }
        public ushort End
        {
            get;
        }

        public PortRange(ushort singlePort) : this(singlePort, singlePort) { }

        public PortRange(ushort first, ushort second)
        {
            if (first > second)
            {
                Begin = second;
                End = first;
            }
            else
            {
                Begin = first;
                End = second;
            }
            _isSinglePort = (Begin == End);
            _specificLocalPort = null;
        }

        public PortRange(SpecificLocalPort specificLocalPort)
        {
            _specificLocalPort = specificLocalPort;
        }

        public static implicit operator PortRange(ushort port) => new PortRange(port);
        public static implicit operator PortRange(SpecificLocalPort port) => new PortRange(port);

        public static bool TryParse(string rangeString, [NotNullWhen(true)] out PortRange? range)
        {
            range = null;
            if (string.IsNullOrWhiteSpace(rangeString)) return false;

            if (Enum.TryParse<SpecificLocalPort>(rangeString.Replace("-", "_"), true, out var sp))
            {
                range = new PortRange(sp);
                return true;
            }

            var parts = rangeString.Split('-');
            if (parts.Length == 1 && ushort.TryParse(parts[0], out var port))
            {
                range = new PortRange(port);
                return true;
            }
            if (parts.Length == 2 && ushort.TryParse(parts[0], out var begin) && ushort.TryParse(parts[1], out var end))
            {
                range = new PortRange(begin, end);
                return true;
            }

            return false;
        }

        public bool Equals(PortRange? other)
        {
            if (other is null) return false;
            if (_specificLocalPort.HasValue) return _specificLocalPort.Value == other._specificLocalPort;
            return Begin == other.Begin && End == other.End;
        }

        public override int GetHashCode() => ToString().GetHashCode();
        public override string ToString()
        {
            if (_specificLocalPort.HasValue) return _specificLocalPort.Value.ToString().Replace("_", "-");
            if (_isSinglePort) return Begin.ToString();
            return $"{Begin}-{End}";
        }
    }

    [Serializable]
    public class IPAddressRange : IEnumerable<IPAddress>, IEquatable<IPAddressRange>, IFixedRange<IPAddress>
    {
        public IPAddress Begin
        {
            get;
            set;
        }
        public IPAddress End
        {
            get; set;
        }

        public IPAddressRange(IPAddress singleAddress)
        {
            if (singleAddress == null) throw new ArgumentNullException(nameof(singleAddress));
            Begin = End = singleAddress;
        }

        public IPAddressRange(IPAddress begin, IPAddress end)
        {
            if (begin.AddressFamily != end.AddressFamily) throw new ArgumentException("Addresses must be of the same family.");
            if (!Internal.Bits.GtECore(end.GetAddressBytes(), begin.GetAddressBytes())) throw new ArgumentException("Begin address must be smaller than End address.");
            Begin = begin;
            End = end;
        }

        public static IPAddressRange Parse(string ipRangeString)
        {
            if (!TryParse(ipRangeString, out IPAddressRange? range) || range == null)
            {
                throw new FormatException("Unknown IP range string format.");
            }
            return range;
        }

        public static bool TryParse(string ipRangeString, [NotNullWhen(true)] out IPAddressRange? range)
        {
            range = null;
            if (string.IsNullOrWhiteSpace(ipRangeString)) return false;
            ipRangeString = ipRangeString.Trim();

            var cidrParts = ipRangeString.Split('/');
            if (cidrParts.Length == 2 && IPAddress.TryParse(cidrParts[0], out var baseAddress) && int.TryParse(cidrParts[1], out var maskLen))
            {
                var baseAdrBytes = baseAddress.GetAddressBytes();
                if (baseAdrBytes.Length * 8 < maskLen) return false;
                var maskBytes = Internal.Bits.GetBitMask(baseAdrBytes.Length, maskLen);
                var beginBytes = Internal.Bits.And(baseAdrBytes, maskBytes);
                var endBytes = Internal.Bits.Or(beginBytes, Internal.Bits.Not(maskBytes));
                range = new IPAddressRange(new IPAddress(beginBytes), new IPAddress(endBytes));
                return true;
            }

            var rangeParts = ipRangeString.Split('-');
            if (rangeParts.Length == 2 && IPAddress.TryParse(rangeParts[0], out var begin) && IPAddress.TryParse(rangeParts[1], out var end))
            {
                range = new IPAddressRange(begin, end);
                return true;
            }

            if (IPAddress.TryParse(ipRangeString, out var singleAddress))
            {
                range = new IPAddressRange(singleAddress);
                return true;
            }

            return false;
        }


        public bool Contains(IPAddress ipaddress)
        {
            if (ipaddress.AddressFamily != Begin.AddressFamily) return false;
            var adrBytes = ipaddress.GetAddressBytes();
            return Internal.Bits.LtECore(Begin.GetAddressBytes(), adrBytes) && Internal.Bits.GtECore(End.GetAddressBytes(), adrBytes);
        }

        public bool Equals(IPAddressRange? other)
        {
            if (other is null) return false;
            return Begin.Equals(other.Begin) && End.Equals(other.End);
        }

        public override int GetHashCode() => (Begin, End).GetHashCode();
        public override string ToString()
        {
            return Begin.Equals(End) ?
 Begin.ToString() : $"{Begin}-{End}";
        }

        public IEnumerator<IPAddress> GetEnumerator()
        {
            var first = Begin.GetAddressBytes();
            var last = End.GetAddressBytes();
            for (var ip = first; Internal.Bits.LtECore(ip, last); ip = Internal.Bits.Increment(ip))
                yield return new IPAddress(ip);
        }

        IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();
    }

    public static class RangeExtensions
    {
        public static PortRange To(this ushort from, ushort to)
        {
            return new PortRange(from, to);
        }
        public static IPAddressRange To(this IPAddress from, IPAddress to)
        {
            return new IPAddressRange(from, to);
        }
    }

    public struct ProtocolTypes : IEquatable<ProtocolTypes>
    {
        public static ProtocolTypes Any { get; } = new ProtocolTypes("Any", 256, false, false);
        public static ProtocolTypes TCP { get; } = new ProtocolTypes("TCP", 6, true, false);
        public static ProtocolTypes UDP { get; } = new ProtocolTypes("UDP", 17, true, false);
        public static ProtocolTypes ICMPv4 { get; } = new ProtocolTypes("ICMPv4", 1, false, true);
        public static ProtocolTypes ICMPv6 { get; } = new ProtocolTypes("ICMPv6", 58, false, true);
        public static ProtocolTypes IGMP { get; } = new ProtocolTypes("IGMP", 2, false, false);

        public string Name { get; }
        public int Value { get; }
        public bool SupportsPorts { get; }
        public bool SupportsIcmp { get; }

        private ProtocolTypes(string name, int value, bool supportsPorts, bool supportsIcmp)
        {
            Name = name;
            Value = value;
            SupportsPorts = supportsPorts;
            SupportsIcmp = supportsIcmp;
        }

        public override string ToString() => Name;
        public bool Equals(ProtocolTypes other) => this.Value == other.Value;
        public override bool Equals(object? obj) => obj is ProtocolTypes other && Equals(other);
        public override int GetHashCode() => Value.GetHashCode();
    }
}

namespace MinimalFirewall.TypedObjects.Internal
{
    internal static class Bits
    {
        public static byte[] Not(byte[] bytes) => bytes.Select(b => (byte)~b).ToArray();
        public static byte[] And(byte[] A, byte[] B) => A.Zip(B, (a, b) => (byte)(a & b)).ToArray();
        public static byte[] Or(byte[] A, byte[] B) => A.Zip(B, (a, b) => (byte)(a | b)).ToArray();
        public static bool GtECore(byte[] A, byte[] B, int offset = 0)
        {
            int length = Math.Min(A.Length, B.Length);
            for (var i = offset; i < length; i++)
            {
                if (A[i] != B[i]) return A[i] >= B[i];
            }
            return true;
        }
        public static bool LtECore(byte[] A, byte[] B, int offset = 0)
        {
            int length = Math.Min(A.Length, B.Length);
            for (var i = offset; i < length; i++)
            {
                if (A[i] != B[i]) return A[i] <= B[i];
            }
            return true;
        }
        public static byte[] GetBitMask(int sizeOfBuff, int bitLen)
        {
            var maskBytes = new byte[sizeOfBuff];
            int bytesLen = bitLen / 8;
            int bitsLen = bitLen % 8;
            for (var i = 0; i < bytesLen; i++) maskBytes[i] = 0xff;
            if (bitsLen > 0) maskBytes[bytesLen] = (byte)~(255 >> bitsLen);
            return maskBytes;
        }
        public static byte[] Increment(byte[] bytes)
        {
            var incrementIndex = Array.FindLastIndex(bytes, x => x < byte.MaxValue);
            if (incrementIndex < 0) throw new OverflowException();
            return bytes.Take(incrementIndex)
                        .Concat(new byte[] { (byte)(bytes[incrementIndex] + 1) })
                        .Concat(new byte[bytes.Length - incrementIndex - 1])
                        .ToArray();
        }
    }
}

--------------------------------------------------
// Full Path: C:/Users/anon/PROGRAMMING/C#/SimpleFirewall/VS Minimal Firewall/MinimalFirewall-NET8/Backups/v2.5.5 - ws/2.5.5.6 - security vulnerability fix 3/UserActivityLogger.cs
--------------------------------------------------------------------------------
// File: UserActivityLogger.cs
using System.IO;
using System.Text.Json;
using System.Collections.Generic;
using System.Diagnostics;

namespace MinimalFirewall
{
    public class UserActivityLogger
    {
        private readonly string _debugLogFilePath;
        private readonly string _changeLogFilePath;
        public bool IsEnabled { get; set; }

        public UserActivityLogger()
        {
            _debugLogFilePath = ConfigPathManager.GetConfigPath("debug_log.txt");
            _changeLogFilePath = ConfigPathManager.GetConfigPath("changelog.json");
        }

        public void LogChange(string action, string details)
        {
            if (!IsEnabled) return;
            try
            {
                var newLogEntry = new { Timestamp = DateTime.Now, Action = action, Details = details };
                List<object> logEntries;

                if (File.Exists(_changeLogFilePath))
                {
                    string json = File.ReadAllText(_changeLogFilePath);
                    logEntries = JsonSerializer.Deserialize<List<object>>(json) ?? new List<object>();
                }
                else
                {
                    logEntries = new List<object>();
                }

                logEntries.Add(newLogEntry);
                string newJson = JsonSerializer.Serialize(logEntries, new JsonSerializerOptions { WriteIndented = true });
                File.WriteAllText(_changeLogFilePath, newJson);
            }
            catch (Exception ex) when (ex is IOException or UnauthorizedAccessException or JsonException)
            {
                Debug.WriteLine($"[FATAL LOGGING ERROR] {ex.Message}");
            }
        }

        public void LogDebug(string message)
        {
            if (!IsEnabled) return;
            try
            {
                string timestamp = DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss");
                string logEntry = $"[{timestamp}] {message}{Environment.NewLine}";
                File.AppendAllText(_debugLogFilePath, logEntry);
            }
            catch (Exception ex) when (ex is IOException or UnauthorizedAccessException)
            {
                Debug.WriteLine($"[FATAL DEBUG LOGGING ERROR] {ex.Message}");
            }
        }

        public void LogException(string context, Exception ex)
        {
            if (!IsEnabled) return;
            try
            {
                string timestamp = DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss");
                string hex = $"0x{ex.HResult:X8}";
                string type = ex.GetType().Name;
                string msg = ex.Message?.Replace(Environment.NewLine, " ").Trim() ?? "";
                string line = $"[{timestamp}] ERROR {context} {type} HResult={hex} Message={msg}{Environment.NewLine}";
                File.AppendAllText(_debugLogFilePath, line);
            }
            catch (Exception e) when (e is IOException or UnauthorizedAccessException)
            {
                Debug.WriteLine($"[FATAL EXCEPTION LOGGING ERROR] {e.Message}");
            }
        }
    }
}

--------------------------------------------------
// Full Path: C:/Users/anon/PROGRAMMING/C#/SimpleFirewall/VS Minimal Firewall/MinimalFirewall-NET8/Backups/v2.5.5 - ws/2.5.5.6 - security vulnerability fix 3/Utilities.cs
--------------------------------------------------------------------------------
// File: Utilities.cs
using System.Diagnostics.CodeAnalysis;
using System.Runtime.InteropServices;
using System.Text;
using System.Net;

namespace MinimalFirewall
{
    public delegate bool TryParseHandler<T>(string value, [NotNullWhen(true)] out T? result);

    public static class ParsingUtility
    {
        public static List<T> ParseStringToList<T>(string? input, TryParseHandler<T> tryParse)
        {
            if (string.IsNullOrEmpty(input) || input.Trim() == "*")
            {
                return [];
            }
            var results = new List<T>();
            var parts = input.Split(',');
            foreach (var part in parts)
            {
                if (tryParse(part.Trim(), out T? result) && result != null)
                {
                    results.Add(result);
                }
            }
            return results;
        }
    }

    public static class ValidationUtility
    {
        public static bool ValidatePortString(string portString, out string errorMessage)
        {
            errorMessage = string.Empty;
            if (string.IsNullOrWhiteSpace(portString) || portString == "*") return true;

            var parts = portString.Split(',');
            foreach (var part in parts)
            {
                var trimmedPart = part.Trim();
                if (string.IsNullOrEmpty(trimmedPart)) continue;

                if (trimmedPart.Contains('-'))
                {
                    var rangeParts = trimmedPart.Split('-');
                    if (rangeParts.Length != 2 ||
                        !ushort.TryParse(rangeParts[0], out ushort start) ||
                        !ushort.TryParse(rangeParts[1], out ushort end) ||
                        start > end)
                    {
                        errorMessage = $"Invalid port range '{trimmedPart}'. Must be in 'start-end' format (e.g., 80-88).";
                        return false;
                    }
                }
                else if (!ushort.TryParse(trimmedPart, out _))
                {
                    errorMessage = $"Invalid port number '{trimmedPart}'. Must be a number between 0 and 65535.";
                    return false;
                }
            }
            return true;
        }

        public static bool ValidateAddressString(string addressString, out string errorMessage)
        {
            errorMessage = string.Empty;
            if (string.IsNullOrWhiteSpace(addressString) || addressString == "*") return true;

            var parts = addressString.Split(',');
            foreach (var part in parts)
            {
                var trimmedPart = part.Trim();
                if (string.IsNullOrEmpty(trimmedPart)) continue;

                if (trimmedPart.Equals("LocalSubnet", StringComparison.OrdinalIgnoreCase) ||
                    trimmedPart.Equals("DNS", StringComparison.OrdinalIgnoreCase) ||
                    trimmedPart.Equals("DHCP", StringComparison.OrdinalIgnoreCase) ||
                    trimmedPart.Equals("WINS", StringComparison.OrdinalIgnoreCase) ||
                    trimmedPart.Equals("DefaultGateway", StringComparison.OrdinalIgnoreCase))
                {
                    continue;
                }

                if (!IPAddress.TryParse(trimmedPart, out _) && !TypedObjects.IPAddressRange.TryParse(trimmedPart, out _))
                {
                    errorMessage = $"Invalid IP address, range, or keyword: '{trimmedPart}'.";
                    return false;
                }
            }
            return true;
        }

        public static bool ValidateIcmpString(string icmpString, out string errorMessage)
        {
            errorMessage = string.Empty;
            if (string.IsNullOrWhiteSpace(icmpString) || icmpString == "*") return true;

            var parts = icmpString.Split(',');
            foreach (var part in parts)
            {
                var trimmedPart = part.Trim();
                if (string.IsNullOrEmpty(trimmedPart)) continue;

                var icmpParts = trimmedPart.Split(':');
                if (icmpParts.Length > 2)
                {
                    errorMessage = $"Invalid ICMP format '{trimmedPart}'. Use 'type' or 'type:code'.";
                    return false;
                }

                if (!byte.TryParse(icmpParts[0], out _))
                {
                    errorMessage = $"Invalid ICMP type '{icmpParts[0]}'. Must be a number between 0 and 255.";
                    return false;
                }

                if (icmpParts.Length == 2 && !byte.TryParse(icmpParts[1], out _))
                {
                    errorMessage = $"Invalid ICMP code '{icmpParts[1]}'. Must be a number between 0 and 255.";
                    return false;
                }
            }
            return true;
        }
    }


    public static partial class PathResolver
    {
        private static readonly Dictionary<string, string> _deviceMap = [];
        private static readonly Dictionary<string, string> _envVarMap = [];

        static PathResolver()
        {
            var driveLetters = Directory.GetLogicalDrives().Select(d => d[0..2]);
            foreach (var drive in driveLetters)
            {
                var targetPath = new StringBuilder(260);
                if (QueryDosDevice(drive, targetPath, targetPath.Capacity) != 0)
                {
                    _deviceMap[targetPath.ToString()] = drive;
                }
            }

            var specialFolders = new[]
            {
                Environment.SpecialFolder.UserProfile,
                Environment.SpecialFolder.ApplicationData,
                Environment.SpecialFolder.LocalApplicationData,
                Environment.SpecialFolder.CommonApplicationData,
                Environment.SpecialFolder.System,
                Environment.SpecialFolder.ProgramFiles,
                Environment.SpecialFolder.ProgramFilesX86,
                Environment.SpecialFolder.Windows
            };

            foreach (var folder in specialFolders)
            {
                string path = Environment.GetFolderPath(folder, Environment.SpecialFolderOption.DoNotVerify);
                if (!string.IsNullOrEmpty(path))
                {
                    string envVar = $"%{folder}%";
                    _envVarMap[path] = envVar;
                }
            }
        }

        public static string ConvertToEnvironmentPath(string absolutePath)
        {
            if (string.IsNullOrEmpty(absolutePath)) return absolutePath;

            foreach (var kvp in _envVarMap.OrderByDescending(x => x.Key.Length))
            {
                if (absolutePath.StartsWith(kvp.Key, StringComparison.OrdinalIgnoreCase))
                {
                    return kvp.Value + absolutePath.Substring(kvp.Key.Length);
                }
            }

            return absolutePath;
        }

        public static string ConvertFromEnvironmentPath(string environmentPath)
        {
            if (string.IsNullOrEmpty(environmentPath)) return environmentPath;
            return Environment.ExpandEnvironmentVariables(environmentPath);
        }

        public static string NormalizePath(string path)
        {
            if (string.IsNullOrEmpty(path)) return string.Empty;
            try
            {
                string expandedPath = Environment.ExpandEnvironmentVariables(path);
                if (Path.IsPathRooted(expandedPath))
                {
                    return Path.GetFullPath(expandedPath);
                }

                string basePath = AppContext.BaseDirectory;
                return Path.GetFullPath(Path.Combine(basePath, expandedPath));
            }
            catch (ArgumentException)
            {
                return path;
            }
        }

        public static string ConvertDevicePathToDrivePath(string devicePath)
        {
            if (string.IsNullOrEmpty(devicePath) || (devicePath.Length > 1 && devicePath[1] == ':' && char.IsLetter(devicePath[0])))
                return devicePath;
            var matchingDevice = _deviceMap.Keys.FirstOrDefault(d => devicePath.StartsWith(d, StringComparison.OrdinalIgnoreCase));
            return matchingDevice != null ? string.Concat(_deviceMap[matchingDevice], devicePath.AsSpan(matchingDevice.Length)) : devicePath;
        }

        [DllImport("kernel32.dll", EntryPoint = "QueryDosDeviceW", CharSet = CharSet.Unicode, SetLastError = true)]
        private static extern uint QueryDosDevice(string lpDeviceName, StringBuilder lpTargetPath, int ucchMax);
    }
}

--------------------------------------------------
// Full Path: C:/Users/anon/PROGRAMMING/C#/SimpleFirewall/VS Minimal Firewall/MinimalFirewall-NET8/Backups/v2.5.5 - ws/2.5.5.6 - security vulnerability fix 3/UtilityServices.cs
--------------------------------------------------------------------------------
// File: UtilityServices.cs
using DarkModeForms;
using System.Diagnostics;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading;
using NetFwTypeLib;
using System;

namespace MinimalFirewall
{
    public static class AdminTaskService
    {
        public static void ResetFirewall()
        {
            try
            {
                Type fwMgrType = Type.GetTypeFromProgID("HNetCfg.FwMgr");
                if (fwMgrType != null)
                {
                    INetFwMgr fwMgr = (INetFwMgr)Activator.CreateInstance(fwMgrType);
                    fwMgr.RestoreDefaults();
                    Debug.WriteLine("[AdminTask] Firewall reset to defaults using COM interface.");
                }
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"[AdminTask ERROR] Firewall reset failed: {ex.Message}");
                Messenger.MessageBox($"Could not reset Windows Firewall.\n\nError: {ex.Message}", "Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
            }
        }

        public static void SetAuditPolicy(bool enable)
        {
            string[] guids =
            {
                "{0CCE9225-69AE-11D9-BED3-505054503030}",
                "{0CCE9226-69AE-11D9-BED3-505054503030}"
            };
            foreach (var guid in guids)
            {
                string arguments = $"/set /subcategory:{guid} /failure:{(enable ? "enable" : "disable")}";
                Execute(arguments, "auditpol.exe", out _);
            }
        }

        public static bool IsAuditPolicyEnabled()
        {
            var packetDropGuid = new Guid("{0CCE9225-69AE-11D9-BED3-505054503030}");
            var connectionGuid = new Guid("{0CCE9226-69AE-11D9-BED3-505054503030}");

            return IsAuditingEnabledForSubcategory(packetDropGuid) && IsAuditingEnabledForSubcategory(connectionGuid);
        }

        private const uint AUDIT_FAILURE = 0x00000002;
        [DllImport("advapi32.dll", SetLastError = true)]
        private static extern bool AuditQuerySystemPolicy(
            [In] Guid pSubCategoryGuids,
            [In] uint PolicyCount,
            [Out] out IntPtr ppPolicy
        );
        [DllImport("advapi32.dll", SetLastError = true)]
        private static extern bool AuditFree(
            [In] IntPtr pBuffer
        );
        [StructLayout(LayoutKind.Sequential)]
        private struct AUDIT_POLICY_INFORMATION
        {
            public Guid AuditSubCategoryGuid;
            public uint AuditingInformation;
        }

        private static bool IsAuditingEnabledForSubcategory(Guid subcategoryGuid)
        {
            if (!AuditQuerySystemPolicy(subcategoryGuid, 1, out IntPtr pPolicy))
            {
                int error = Marshal.GetLastWin32Error();
                Debug.WriteLine($"[AdminTask ERROR] AuditQuerySystemPolicy failed for GUID {subcategoryGuid}, Win32 Error: {error}");
                return false;
            }

            try
            {
                var policyInfo = Marshal.PtrToStructure<AUDIT_POLICY_INFORMATION>(pPolicy);
                return (policyInfo.AuditingInformation & AUDIT_FAILURE) == AUDIT_FAILURE;
            }
            finally
            {
                if (pPolicy != IntPtr.Zero)
                {
                    AuditFree(pPolicy);
                }
            }
        }

        private static void Execute(string arguments, string fileName, out string? output)
        {
            Debug.WriteLine($"[AdminTask] Preparing to execute: {fileName} {arguments}");
            output = null;
            var startInfo = new ProcessStartInfo()
            {
                FileName = fileName,
                Arguments = arguments,
                UseShellExecute = false,
                CreateNoWindow = true,
                RedirectStandardError = true,
                RedirectStandardOutput = true,
                StandardOutputEncoding = Encoding.UTF8,
                StandardErrorEncoding = Encoding.UTF8
            };
            try
            {
                using var process = new Process { StartInfo = startInfo };
                var outputBuilder = new StringBuilder();
                var errorBuilder = new StringBuilder();

                using var outputWaitHandle = new AutoResetEvent(false);
                using var errorWaitHandle = new AutoResetEvent(false);
                process.OutputDataReceived += (sender, e) =>
                {
                    if (e.Data == null) outputWaitHandle.Set();
                    else outputBuilder.AppendLine(e.Data);
                };
                process.ErrorDataReceived += (sender, e) =>
                {
                    if (e.Data == null) errorWaitHandle.Set();
                    else errorBuilder.AppendLine(e.Data);
                };

                process.Start();
                process.BeginOutputReadLine();
                process.BeginErrorReadLine();
                if (process.WaitForExit(5000) && outputWaitHandle.WaitOne(5000) && errorWaitHandle.WaitOne(5000))
                {
                    output = outputBuilder.ToString();
                    string errors = errorBuilder.ToString();

                    Debug.WriteLine($"[AdminTask] Exit Code: {process.ExitCode}");
                    if (!string.IsNullOrWhiteSpace(output))
                        Debug.WriteLine($"[AdminTask] Standard Output:\n{output}");
                    if (!string.IsNullOrWhiteSpace(errors))
                        Messenger.MessageBox($"An error occurred during an administrative task:\n\n{errors}", "Admin Task Error", MessageBoxButtons.OK, MessageBoxIcon.Warning);
                }
                else
                {
                    Debug.WriteLine("[AdminTask ERROR] Process timed out or streams did not close.");
                    if (!process.HasExited) process.Kill();
                    Messenger.MessageBox("An administrative task timed out and may not have completed successfully.", "Execution Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
                }
                Debug.WriteLine($"[AdminTask] Execution finished for: {fileName}");
            }
            catch (Exception ex) when (ex is System.ComponentModel.Win32Exception or ObjectDisposedException or InvalidOperationException)
            {
                Debug.WriteLine($"[AdminTask FATAL ERROR] {ex}");
                Messenger.MessageBox($"A critical error occurred while trying to run an administrative task:\n\n{ex.Message}", "Execution Exception", MessageBoxButtons.OK, MessageBoxIcon.Error);
            }
        }
    }

    public class StartupService
    {
        private const string RegistryKeyPath = "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run";
        private readonly string? _appName;
        private readonly string? _appPath;
        private readonly string _taskName;

        public StartupService()
        {
            _appName = Assembly.GetExecutingAssembly().GetName().Name;
            _appPath = Environment.ProcessPath;
            if (_appName != null)
            {
                _taskName = _appName + " Startup";
            }
            else
            {
                _taskName = "MinimalFirewall Startup";
            }
        }

        public void SetStartup(bool isEnabled)
        {
            if (string.IsNullOrEmpty(_appName) || string.IsNullOrEmpty(_appPath)) return;

            try
            {
                using var key = Microsoft.Win32.Registry.CurrentUser.OpenSubKey(RegistryKeyPath, true);
                if (key?.GetValue(_appName) != null)
                {
                    key.DeleteValue(_appName, false);
                }
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"[Startup] Failed to remove old registry key: {ex.Message}");
            }

            if (isEnabled)
            {
                string arguments = $"/create /tn \"{_taskName}\" /tr \"\\\"{_appPath}\\\" -tray\" /sc onlogon /rl highest /f";
                Execute("schtasks.exe", arguments, out _, out _);
            }
            else
            {
                string arguments = $"/delete /tn \"{_taskName}\" /f";
                Execute("schtasks.exe", arguments, out _, out _);
            }
        }

        public void VerifyAndCorrectStartupTaskPath()
        {
            if (string.IsNullOrEmpty(_taskName) || string.IsNullOrEmpty(_appPath)) return;
            string arguments = $"/query /tn \"{_taskName}\" /v /fo CSV /nh";
            Execute("schtasks.exe", arguments, out string? output, out string? error);
            if (!string.IsNullOrEmpty(error) || string.IsNullOrEmpty(output))
            {
                Debug.WriteLine($"[Startup] Could not query task '{_taskName}'. It might not exist. Error: {error}");
                return;
            }
            try
            {
                var parts = output.Split('"');
                string storedPath = string.Empty;
                foreach (var part in parts)
                {
                    if (part.EndsWith(".exe", StringComparison.OrdinalIgnoreCase))
                    {
                        storedPath = part;
                        break;
                    }
                }
                if (string.IsNullOrEmpty(storedPath))
                {
                    Debug.WriteLine($"[Startup] Could not parse executable path from schtasks output: {output}");
                    return;
                }
                string normalizedStoredPath = PathResolver.NormalizePath(storedPath);
                string normalizedCurrentPath = PathResolver.NormalizePath(_appPath);
                if (!normalizedStoredPath.Equals(normalizedCurrentPath, StringComparison.OrdinalIgnoreCase))
                {
                    Debug.WriteLine($"[Startup] Mismatch detected. Stored: '{normalizedStoredPath}', Current: '{normalizedCurrentPath}'. Correcting task.");
                    SetStartup(true);
                }
                else
                {
                    Debug.WriteLine($"[Startup] Startup task path is correct.");
                }
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"[Startup] Error during startup path verification: {ex.Message}");
            }
        }

        private void Execute(string fileName, string arguments, out string output, out string error)
        {
            Debug.WriteLine($"[Startup] Executing: {fileName} {arguments}");
            var startInfo = new ProcessStartInfo()
            {
                FileName = fileName,
                Arguments = arguments,
                UseShellExecute = false,
                CreateNoWindow = true,
                RedirectStandardError = true,
                RedirectStandardOutput = true,
                StandardOutputEncoding = Encoding.UTF8,
                StandardErrorEncoding = Encoding.UTF8,
            };
            try
            {
                using var process = Process.Start(startInfo);
                if (process != null)
                {
                    output = process.StandardOutput.ReadToEnd();
                    error = process.StandardError.ReadToEnd();
                    process.WaitForExit(5000);

                    if (process.ExitCode != 0)
                    {
                        Debug.WriteLine($"[Startup ERROR] Process exited with code {process.ExitCode}.");
                        if (!string.IsNullOrEmpty(output)) Debug.WriteLine($"[Startup ERROR] STDOUT: {output}");
                        if (!string.IsNullOrEmpty(error)) Debug.WriteLine($"[Startup ERROR] STDERR: {error}");
                    }
                }
                else
                {
                    output = string.Empty;
                    error = "Failed to start process.";
                }
            }
            catch (Exception ex)
            {
                output = string.Empty;
                error = ex.Message;
                Debug.WriteLine($"[Startup FATAL ERROR] {ex.Message}");
            }
        }
    }
}


--------------------------------------------------
// Full Path: C:/Users/anon/PROGRAMMING/C#/SimpleFirewall/VS Minimal Firewall/MinimalFirewall-NET8/Backups/v2.5.5 - ws/2.5.5.6 - security vulnerability fix 3/UwpService.cs
--------------------------------------------------------------------------------
// File: UwpService.cs
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using NetFwTypeLib;

namespace MinimalFirewall
{
    public class UwpService
    {
        private readonly string _cachePath;
        private readonly FirewallRuleService _firewallRuleService;

        public UwpService(FirewallRuleService firewallRuleService)
        {
            _cachePath = ConfigPathManager.GetConfigPath("uwp_apps.json");
            _firewallRuleService = firewallRuleService;
        }

        public async Task<List<UwpApp>> GetUwpAppsAsync(CancellationToken token)
        {
            return await Task.Run(() =>
            {
                var allRules = _firewallRuleService.GetAllRules();
                var uwpApps = new Dictionary<string, UwpApp>(StringComparer.OrdinalIgnoreCase);

                try
                {
                    foreach (INetFwRule2 rule in allRules)
                    {
                        if (token.IsCancellationRequested) return new List<UwpApp>();

                        string? pfn = null;
                        string name = rule.Name ?? string.Empty;

                        if (name.StartsWith("@{") && name.Contains("}"))
                        {
                            int startIndex = 2;
                            int endIndex = name.IndexOf("?ms-resource");
                            if (endIndex == -1)
                            {
                                endIndex = name.IndexOf("}");
                            }
                            if (endIndex > startIndex)
                            {
                                pfn = name.Substring(startIndex, endIndex - startIndex);
                            }
                        }

                        if (!string.IsNullOrEmpty(pfn) && !uwpApps.ContainsKey(pfn))
                        {
                            uwpApps[pfn] = new UwpApp
                            {
                                Name = name,
                                PackageFamilyName = pfn,
                                Publisher = ""
                            };
                        }
                    }

                    var sortedApps = uwpApps.Values.OrderBy(app => app.Name).ToList();
                    SaveUwpAppsToCache(sortedApps);
                    return sortedApps;
                }
                finally
                {
                    foreach (var rule in allRules)
                    {
                        if (rule != null)
                        {
                            Marshal.ReleaseComObject(rule);
                        }
                    }
                }
            }, token).ConfigureAwait(false);
        }

        public List<UwpApp> LoadUwpAppsFromCache()
        {
            try
            {
                if (File.Exists(_cachePath))
                {
                    string json = File.ReadAllText(_cachePath);
                    var apps = JsonSerializer.Deserialize(json, UwpAppJsonContext.Default.ListUwpApp);
                    return apps ?? new List<UwpApp>();
                }
            }
            catch (Exception ex) when (ex is IOException or UnauthorizedAccessException or JsonException)
            {
                Debug.WriteLine("[ERROR] Failed to load UWP cache: " + ex.Message);
            }
            return new List<UwpApp>();
        }

        private void SaveUwpAppsToCache(List<UwpApp> apps)
        {
            try
            {
                string json = JsonSerializer.Serialize(apps, UwpAppJsonContext.Default.ListUwpApp);
                File.WriteAllText(_cachePath, json);
            }
            catch (Exception ex) when (ex is IOException or UnauthorizedAccessException)
            {
                Debug.WriteLine("[ERROR] Failed to save UWP cache: " + ex.Message);
            }
        }
    }
}

--------------------------------------------------
// Full Path: C:/Users/anon/PROGRAMMING/C#/SimpleFirewall/VS Minimal Firewall/MinimalFirewall-NET8/Backups/v2.5.5 - ws/2.5.5.6 - security vulnerability fix 3/WildcardCreatorForm.cs
--------------------------------------------------------------------------------
// File: WildcardCreatorForm.cs
using System.IO;
using DarkModeForms;
using MinimalFirewall.TypedObjects;
using System.ComponentModel;

namespace MinimalFirewall
{
    public partial class WildcardCreatorForm : Form
    {
        private readonly WildcardRuleService _wildcardRuleService;
        private readonly DarkModeCS dm;
        private readonly WildcardRule? _originalRule;

        public WildcardRule NewRule { get; private set; } = new();

        public WildcardCreatorForm(WildcardRuleService wildcardRuleService, AppSettings appSettings, WildcardRule? ruleToEdit = null)
        {
            InitializeComponent();
            dm = new DarkModeCS(this);
            dm.ColorMode = appSettings.Theme == "Dark" ? DarkModeCS.DisplayMode.DarkMode : DarkModeCS.DisplayMode.ClearMode;
            dm.ApplyTheme(appSettings.Theme == "Dark");
            _wildcardRuleService = wildcardRuleService;
            directionCombo.SelectedIndex = 0;
            protocolComboBox.Items.AddRange(new object[] { "Any", "TCP", "UDP" });
            protocolComboBox.SelectedItem = "Any";

            _originalRule = ruleToEdit;
            if (_originalRule != null)
            {
                this.Text = "Edit Wildcard Rule";
                PopulateForm(_originalRule);
            }
        }

        public WildcardCreatorForm(WildcardRuleService wildcardRuleService, string initialAppPath, AppSettings appSettings) : this(wildcardRuleService, appSettings)
        {
            string? dirPath = Path.GetDirectoryName(initialAppPath);
            if (!string.IsNullOrEmpty(dirPath) && Directory.Exists(dirPath))
            {
                folderPathTextBox.Text = dirPath;
                exeNameTextBox.Text = Path.GetFileName(initialAppPath);
            }
        }

        private void PopulateForm(WildcardRule rule)
        {
            folderPathTextBox.Text = rule.FolderPath;
            exeNameTextBox.Text = rule.ExeName;

            if (rule.Action.StartsWith("Allow"))
            {
                allowRadio.Checked = true;
            }
            else
            {
                blockRadio.Checked = true;
            }

            if (rule.Action.Contains("Inbound"))
            {
                directionCombo.SelectedItem = "Inbound";
            }
            else if (rule.Action.Contains("All"))
            {
                directionCombo.SelectedItem = "All";
            }
            else
            {
                directionCombo.SelectedItem = "Outbound";
            }

            switch (rule.Protocol)
            {
                case 6:
                    protocolComboBox.SelectedItem = "TCP";
                    break;
                case 17:
                    protocolComboBox.SelectedItem = "UDP";
                    break;
                default:
                    protocolComboBox.SelectedItem = "Any";
                    break;
            }

            localPortsTextBox.Text = rule.LocalPorts;
            remotePortsTextBox.Text = rule.RemotePorts;
            remoteAddressTextBox.Text = rule.RemoteAddresses;
        }

        private void browseButton_Click(object sender, EventArgs e)
        {
            using (var dialog = new FolderBrowserDialog())
            {
                if (dialog.ShowDialog() == DialogResult.OK)
                {
                    folderPathTextBox.Text = dialog.SelectedPath;
                }
            }
        }

        private void okButton_Click(object sender, EventArgs e)
        {
            string folderPath = folderPathTextBox.Text;
            string expandedPath = Environment.ExpandEnvironmentVariables(folderPath);
            errorProvider1.SetError(folderPathTextBox, string.Empty);
            errorProvider1.SetError(localPortsTextBox, string.Empty);
            errorProvider1.SetError(remotePortsTextBox, string.Empty);
            errorProvider1.SetError(remoteAddressTextBox, string.Empty);

            if (string.IsNullOrWhiteSpace(folderPath))
            {
                errorProvider1.SetError(folderPathTextBox, "Folder path cannot be empty.");
                return;
            }

            if (!Directory.Exists(expandedPath))
            {
                errorProvider1.SetError(folderPathTextBox, "The specified directory does not exist.");
                return;
            }

            if (!ValidationUtility.ValidatePortString(localPortsTextBox.Text, out string localPortError))
            {
                errorProvider1.SetError(localPortsTextBox, localPortError);
                return;
            }

            if (!ValidationUtility.ValidatePortString(remotePortsTextBox.Text, out string remotePortError))
            {
                errorProvider1.SetError(remotePortsTextBox, remotePortError);
                return;
            }

            if (!ValidationUtility.ValidateAddressString(remoteAddressTextBox.Text, out string remoteAddressError))
            {
                errorProvider1.SetError(remoteAddressTextBox, remoteAddressError);
                return;
            }

            NewRule.FolderPath = PathResolver.NormalizePath(folderPath);
            NewRule.ExeName = exeNameTextBox.Text;
            string action = allowRadio.Checked ? "Allow" : "Block";
            string direction = directionCombo.Text;
            NewRule.Action = $"{action} ({direction})";

            NewRule.Protocol = protocolComboBox.SelectedItem switch
            {
                "TCP" => 6,
                "UDP" => 17,
                _ => 256,
            };

            NewRule.LocalPorts = string.IsNullOrWhiteSpace(localPortsTextBox.Text) ? "*" : localPortsTextBox.Text;
            NewRule.RemotePorts = string.IsNullOrWhiteSpace(remotePortsTextBox.Text) ? "*" : remotePortsTextBox.Text;
            NewRule.RemoteAddresses = string.IsNullOrWhiteSpace(remoteAddressTextBox.Text) ? "*" : remoteAddressTextBox.Text;

            DialogResult = DialogResult.OK;
        }

        private void cancelButton_Click(object sender, EventArgs e)
        {
            DialogResult = DialogResult.Cancel;
        }

        private void advancedButton_Click(object sender, EventArgs e)
        {
            bool isVisible = advancedGroupBox.Visible;
            advancedGroupBox.Visible = !isVisible;
            this.Height += isVisible ? -advancedGroupBox.Height : advancedGroupBox.Height;
        }

        private void localPortsTextBox_Validating(object sender, CancelEventArgs e)
        {
            if (sender is TextBox textBox)
            {
                if (!ValidationUtility.ValidatePortString(textBox.Text, out string errorMessage))
                {
                    errorProvider1.SetError(textBox, errorMessage);
                    e.Cancel = true;
                }
                else
                {
                    errorProvider1.SetError(textBox, string.Empty);
                }
            }
        }

        private void remotePortsTextBox_Validating(object sender, CancelEventArgs e)
        {
            if (sender is TextBox textBox)
            {
                if (!ValidationUtility.ValidatePortString(textBox.Text, out string errorMessage))
                {
                    errorProvider1.SetError(textBox, errorMessage);
                    e.Cancel = true;
                }
                else
                {
                    errorProvider1.SetError(textBox, string.Empty);
                }
            }
        }

        private void remoteAddressTextBox_Validating(object sender, CancelEventArgs e)
        {
            if (sender is TextBox textBox)
            {
                if (!ValidationUtility.ValidateAddressString(textBox.Text, out string errorMessage))
                {
                    errorProvider1.SetError(textBox, errorMessage);
                    e.Cancel = true;
                }
                else
                {
                    errorProvider1.SetError(textBox, string.Empty);
                }
            }
        }
    }
}

--------------------------------------------------
// Full Path: C:/Users/anon/PROGRAMMING/C#/SimpleFirewall/VS Minimal Firewall/MinimalFirewall-NET8/Backups/v2.5.5 - ws/2.5.5.6 - security vulnerability fix 3/WildcardCreatorForm.Designer.cs
--------------------------------------------------------------------------------
// File: WildcardCreatorForm.Designer.cs
namespace MinimalFirewall
{
    public partial class WildcardCreatorForm
    {
        private System.ComponentModel.IContainer components = null;
        private System.Windows.Forms.Button browseButton;
        private System.Windows.Forms.TextBox folderPathTextBox;
        private System.Windows.Forms.TextBox exeNameTextBox;
        private System.Windows.Forms.RadioButton allowRadio;
        private System.Windows.Forms.RadioButton blockRadio;
        private DarkModeForms.FlatComboBox directionCombo;
        private System.Windows.Forms.Button okButton;
        private System.Windows.Forms.Button cancelButton;
        private System.Windows.Forms.GroupBox actionGroupBox;
        private System.Windows.Forms.Label instructionLabel;
        private System.Windows.Forms.Label exeNameNoteLabel;
        private System.Windows.Forms.ErrorProvider errorProvider1;
        private System.Windows.Forms.Button advancedButton;
        private System.Windows.Forms.GroupBox advancedGroupBox;
        private DarkModeForms.FlatComboBox protocolComboBox;
        private System.Windows.Forms.Label labelProtocol;
        private System.Windows.Forms.TextBox remotePortsTextBox;
        private System.Windows.Forms.Label labelRemotePorts;
        private System.Windows.Forms.TextBox localPortsTextBox;
        private System.Windows.Forms.Label labelLocalPorts;
        private System.Windows.Forms.TextBox remoteAddressTextBox;
        private System.Windows.Forms.Label labelRemoteAddress;

        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        private void InitializeComponent()
        {
            this.components = new System.ComponentModel.Container();
            this.browseButton = new System.Windows.Forms.Button();
            this.folderPathTextBox = new System.Windows.Forms.TextBox();
            this.exeNameTextBox = new System.Windows.Forms.TextBox();
            this.actionGroupBox = new System.Windows.Forms.GroupBox();
            this.directionCombo = new DarkModeForms.FlatComboBox();
            this.blockRadio = new System.Windows.Forms.RadioButton();
            this.allowRadio = new System.Windows.Forms.RadioButton();
            this.okButton = new System.Windows.Forms.Button();
            this.cancelButton = new System.Windows.Forms.Button();
            this.instructionLabel = new System.Windows.Forms.Label();
            this.exeNameNoteLabel = new System.Windows.Forms.Label();
            this.errorProvider1 = new System.Windows.Forms.ErrorProvider(this.components);
            this.advancedButton = new System.Windows.Forms.Button();
            this.advancedGroupBox = new System.Windows.Forms.GroupBox();
            this.remoteAddressTextBox = new System.Windows.Forms.TextBox();
            this.labelRemoteAddress = new System.Windows.Forms.Label();
            this.remotePortsTextBox = new System.Windows.Forms.TextBox();
            this.labelRemotePorts = new System.Windows.Forms.Label();
            this.localPortsTextBox = new System.Windows.Forms.TextBox();
            this.labelLocalPorts = new System.Windows.Forms.Label();
            this.protocolComboBox = new DarkModeForms.FlatComboBox();
            this.labelProtocol = new System.Windows.Forms.Label();
            this.actionGroupBox.SuspendLayout();
            ((System.ComponentModel.ISupportInitialize)(this.errorProvider1)).BeginInit();
            this.advancedGroupBox.SuspendLayout();
            this.SuspendLayout();
            // 
            // browseButton
            // 
            this.browseButton.Location = new System.Drawing.Point(377, 120);
            this.browseButton.Name = "browseButton";
            this.browseButton.Size = new System.Drawing.Size(100, 29);
            this.browseButton.TabIndex = 0;
            this.browseButton.Text = "Browse...";
            this.browseButton.UseVisualStyleBackColor = true;
            this.browseButton.Click += new System.EventHandler(this.browseButton_Click);
            // 
            // folderPathTextBox
            // 
            this.folderPathTextBox.Location = new System.Drawing.Point(23, 120);
            this.folderPathTextBox.Name = "folderPathTextBox";
            this.folderPathTextBox.Size = new System.Drawing.Size(347, 27);
            this.folderPathTextBox.TabIndex = 1;
            this.folderPathTextBox.PlaceholderText = "Enter folder path";
            // 
            // exeNameTextBox
            // 
            this.exeNameTextBox.Location = new System.Drawing.Point(23, 170);
            this.exeNameTextBox.Name = "exeNameTextBox";
            this.exeNameTextBox.Size = new System.Drawing.Size(454, 27);
            this.exeNameTextBox.TabIndex = 2;
            this.exeNameTextBox.PlaceholderText = "Optional: Filter by .exe name (e.g., svchost.exe or vs_*.exe)";
            // 
            // actionGroupBox
            // 
            this.actionGroupBox.Controls.Add(this.directionCombo);
            this.actionGroupBox.Controls.Add(this.blockRadio);
            this.actionGroupBox.Controls.Add(this.allowRadio);
            this.actionGroupBox.Location = new System.Drawing.Point(23, 240);
            this.actionGroupBox.Name = "actionGroupBox";
            this.actionGroupBox.Size = new System.Drawing.Size(454, 150);
            this.actionGroupBox.TabIndex = 3;
            this.actionGroupBox.TabStop = false;
            this.actionGroupBox.Text = "Action";
            // 
            // directionCombo
            // 
            this.directionCombo.BorderColor = System.Drawing.Color.Gray;
            this.directionCombo.ButtonColor = System.Drawing.Color.LightGray;
            this.directionCombo.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;
            this.directionCombo.FormattingEnabled = true;
            this.directionCombo.Items.AddRange(new object[] {
            "Outbound",
            "Inbound",
            "All"});
            this.directionCombo.Location = new System.Drawing.Point(150, 60);
            this.directionCombo.Name = "directionCombo";
            this.directionCombo.Size = new System.Drawing.Size(280, 28);
            this.directionCombo.TabIndex = 2;
            // 
            // blockRadio
            // 
            this.blockRadio.AutoSize = true;
            this.blockRadio.Location = new System.Drawing.Point(20, 90);
            this.blockRadio.Name = "blockRadio";
            this.blockRadio.Size = new System.Drawing.Size(66, 24);
            this.blockRadio.TabIndex = 1;
            this.blockRadio.TabStop = true;
            this.blockRadio.Text = "Block";
            this.blockRadio.UseVisualStyleBackColor = true;
            // 
            // allowRadio
            // 
            this.allowRadio.AutoSize = true;
            this.allowRadio.Checked = true;
            this.allowRadio.Location = new System.Drawing.Point(20, 30);
            this.allowRadio.Name = "allowRadio";
            this.allowRadio.Size = new System.Drawing.Size(68, 24);
            this.allowRadio.TabIndex = 0;
            this.allowRadio.TabStop = true;
            this.allowRadio.Text = "Allow";
            this.allowRadio.UseVisualStyleBackColor = true;
            // 
            // okButton
            // 
            this.okButton.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
            this.okButton.Location = new System.Drawing.Point(260, 622);
            this.okButton.Name = "okButton";
            this.okButton.Size = new System.Drawing.Size(100, 36);
            this.okButton.TabIndex = 4;
            this.okButton.Text = "OK";
            this.okButton.UseVisualStyleBackColor = true;
            this.okButton.Click += new System.EventHandler(this.okButton_Click);
            // 
            // cancelButton
            // 
            this.cancelButton.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
            this.cancelButton.DialogResult = System.Windows.Forms.DialogResult.Cancel;
            this.cancelButton.Location = new System.Drawing.Point(377, 622);
            this.cancelButton.Name = "cancelButton";
            this.cancelButton.Size = new System.Drawing.Size(100, 36);
            this.cancelButton.TabIndex = 5;
            this.cancelButton.Text = "Cancel";
            this.cancelButton.UseVisualStyleBackColor = true;
            this.cancelButton.Click += new System.EventHandler(this.cancelButton_Click);
            // 
            // instructionLabel
            // 
            this.instructionLabel.Location = new System.Drawing.Point(23, 20);
            this.instructionLabel.Name = "instructionLabel";
            this.instructionLabel.Size = new System.Drawing.Size(454, 80);
            this.instructionLabel.TabIndex = 6;
            this.instructionLabel.Text = "Enter a folder path below, or use the Browse button. The rule will apply to all " +
    "matching executables within that folder and its subfolders.\r\n\r\nFor temporary f" +
    "olders, you can type in environment variables directly. Common examples: %APPDATA% ; %Temp% ;  %LOCALAPPDATA%\\Temp ";
            // 
            // exeNameNoteLabel
            // 
            this.exeNameNoteLabel.AutoSize = true;
            this.exeNameNoteLabel.ForeColor = System.Drawing.SystemColors.GrayText;
            this.exeNameNoteLabel.Location = new System.Drawing.Point(23, 196);
            this.exeNameNoteLabel.Name = "exeNameNoteLabel";
            this.exeNameNoteLabel.Size = new System.Drawing.Size(465, 20);
            this.exeNameNoteLabel.TabIndex = 7;
            this.exeNameNoteLabel.Text = "If left blank, the rule will apply to all executables in the selected folder.";
            // 
            // errorProvider1
            // 
            this.errorProvider1.ContainerControl = this;
            // 
            // advancedButton
            // 
            this.advancedButton.Location = new System.Drawing.Point(23, 397);
            this.advancedButton.Name = "advancedButton";
            this.advancedButton.Size = new System.Drawing.Size(121, 29);
            this.advancedButton.TabIndex = 8;
            this.advancedButton.Text = "Advanced...";
            this.advancedButton.UseVisualStyleBackColor = true;
            this.advancedButton.Click += new System.EventHandler(this.advancedButton_Click);
            // 
            // advancedGroupBox
            // 
            this.advancedGroupBox.Controls.Add(this.remoteAddressTextBox);
            this.advancedGroupBox.Controls.Add(this.labelRemoteAddress);
            this.advancedGroupBox.Controls.Add(this.remotePortsTextBox);
            this.advancedGroupBox.Controls.Add(this.labelRemotePorts);
            this.advancedGroupBox.Controls.Add(this.localPortsTextBox);
            this.advancedGroupBox.Controls.Add(this.labelLocalPorts);
            this.advancedGroupBox.Controls.Add(this.protocolComboBox);
            this.advancedGroupBox.Controls.Add(this.labelProtocol);
            this.advancedGroupBox.Location = new System.Drawing.Point(23, 432);
            this.advancedGroupBox.Name = "advancedGroupBox";
            this.advancedGroupBox.Size = new System.Drawing.Size(454, 172);
            this.advancedGroupBox.TabIndex = 9;
            this.advancedGroupBox.TabStop = false;
            this.advancedGroupBox.Text = "Advanced Settings";
            this.advancedGroupBox.Visible = false;
            // 
            // remoteAddressTextBox
            // 
            this.remoteAddressTextBox.Location = new System.Drawing.Point(124, 127);
            this.remoteAddressTextBox.Name = "remoteAddressTextBox";
            this.remoteAddressTextBox.Size = new System.Drawing.Size(306, 27);
            this.remoteAddressTextBox.TabIndex = 7;
            this.remoteAddressTextBox.Text = "*";
            this.remoteAddressTextBox.Validating += new System.ComponentModel.CancelEventHandler(this.remoteAddressTextBox_Validating);
            // 
            // labelRemoteAddress
            // 
            this.labelRemoteAddress.AutoSize = true;
            this.labelRemoteAddress.Location = new System.Drawing.Point(6, 130);
            this.labelRemoteAddress.Name = "labelRemoteAddress";
            this.labelRemoteAddress.Size = new System.Drawing.Size(117, 20);
            this.labelRemoteAddress.TabIndex = 6;
            this.labelRemoteAddress.Text = "Remote Address";
            // 
            // remotePortsTextBox
            // 
            this.remotePortsTextBox.Location = new System.Drawing.Point(124, 94);
            this.remotePortsTextBox.Name = "remotePortsTextBox";
            this.remotePortsTextBox.Size = new System.Drawing.Size(306, 27);
            this.remotePortsTextBox.TabIndex = 5;
            this.remotePortsTextBox.Text = "*";
            this.remotePortsTextBox.Validating += new System.ComponentModel.CancelEventHandler(this.remotePortsTextBox_Validating);
            // 
            // labelRemotePorts
            // 
            this.labelRemotePorts.AutoSize = true;
            this.labelRemotePorts.Location = new System.Drawing.Point(6, 97);
            this.labelRemotePorts.Name = "labelRemotePorts";
            this.labelRemotePorts.Size = new System.Drawing.Size(95, 20);
            this.labelRemotePorts.TabIndex = 4;
            this.labelRemotePorts.Text = "Remote Ports";
            // 
            // localPortsTextBox
            // 
            this.localPortsTextBox.Location = new System.Drawing.Point(124, 61);
            this.localPortsTextBox.Name = "localPortsTextBox";
            this.localPortsTextBox.Size = new System.Drawing.Size(306, 27);
            this.localPortsTextBox.TabIndex = 3;
            this.localPortsTextBox.Text = "*";
            this.localPortsTextBox.Validating += new System.ComponentModel.CancelEventHandler(this.localPortsTextBox_Validating);
            // 
            // labelLocalPorts
            // 
            this.labelLocalPorts.AutoSize = true;
            this.labelLocalPorts.Location = new System.Drawing.Point(6, 64);
            this.labelLocalPorts.Name = "labelLocalPorts";
            this.labelLocalPorts.Size = new System.Drawing.Size(81, 20);
            this.labelLocalPorts.TabIndex = 2;
            this.labelLocalPorts.Text = "Local Ports";
            // 
            // protocolComboBox
            // 
            this.protocolComboBox.BorderColor = System.Drawing.Color.Gray;
            this.protocolComboBox.ButtonColor = System.Drawing.Color.LightGray;
            this.protocolComboBox.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;
            this.protocolComboBox.FormattingEnabled = true;
            this.protocolComboBox.Location = new System.Drawing.Point(124, 27);
            this.protocolComboBox.Name = "protocolComboBox";
            this.protocolComboBox.Size = new System.Drawing.Size(151, 28);
            this.protocolComboBox.TabIndex = 1;
            // 
            // labelProtocol
            // 
            this.labelProtocol.AutoSize = true;
            this.labelProtocol.Location = new System.Drawing.Point(6, 30);
            this.labelProtocol.Name = "labelProtocol";
            this.labelProtocol.Size = new System.Drawing.Size(64, 20);
            this.labelProtocol.TabIndex = 0;
            this.labelProtocol.Text = "Protocol";
            // 
            // WildcardCreatorForm
            // 
            this.AutoScaleDimensions = new System.Drawing.SizeF(8F, 20F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.ClientSize = new System.Drawing.Size(500, 670);
            this.Controls.Add(this.advancedGroupBox);
            this.Controls.Add(this.advancedButton);
            this.Controls.Add(this.exeNameNoteLabel);
            this.Controls.Add(this.instructionLabel);
            this.Controls.Add(this.cancelButton);
            this.Controls.Add(this.okButton);
            this.Controls.Add(this.actionGroupBox);
            this.Controls.Add(this.exeNameTextBox);
            this.Controls.Add(this.folderPathTextBox);
            this.Controls.Add(this.browseButton);
            this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedDialog;
            this.MaximizeBox = false;
            this.MinimizeBox = false;
            this.Name = "WildcardCreatorForm";
            this.StartPosition = System.Windows.Forms.FormStartPosition.CenterParent;
            this.Text = "Create Wildcard Rule";
            this.actionGroupBox.ResumeLayout(false);
            this.actionGroupBox.PerformLayout();
            ((System.ComponentModel.ISupportInitialize)(this.errorProvider1)).EndInit();
            this.advancedGroupBox.ResumeLayout(false);
            this.advancedGroupBox.PerformLayout();
            this.ResumeLayout(false);
            this.PerformLayout();
        }
        #endregion
    }
}

--------------------------------------------------
// Full Path: C:/Users/anon/PROGRAMMING/C#/SimpleFirewall/VS Minimal Firewall/MinimalFirewall-NET8/Backups/v2.5.5 - ws/2.5.5.6 - security vulnerability fix 3/WildcardRulesControl.cs
--------------------------------------------------------------------------------
// File: WildcardRulesControl.cs
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;
using MinimalFirewall.TypedObjects;

namespace MinimalFirewall
{
    public partial class WildcardRulesControl : UserControl
    {
        private WildcardRuleService _wildcardRuleService = null!;
        private BackgroundFirewallTaskService _backgroundTaskService = null!;
        private AppSettings _appSettings = null!;
        private BindingSource _bindingSource;

        public WildcardRulesControl()
        {
            InitializeComponent();
            this.DoubleBuffered = true;
        }

        public void Initialize(WildcardRuleService wildcardRuleService, BackgroundFirewallTaskService backgroundTaskService, AppSettings appSettings)
        {
            _wildcardRuleService = wildcardRuleService;
            _backgroundTaskService = backgroundTaskService;
            _appSettings = appSettings;

            wildcardDataGridView.AutoGenerateColumns = false;
            _bindingSource = new BindingSource();
            wildcardDataGridView.DataSource = _bindingSource;
        }

        public void LoadRules()
        {
            if (_wildcardRuleService != null)
            {
                _bindingSource.DataSource = _wildcardRuleService.GetRules();
                _bindingSource.ResetBindings(false);
                wildcardDataGridView.Refresh();
            }
        }

        public void ClearRules()
        {
            _bindingSource.DataSource = null;
        }

        private void addRuleButton_Click(object sender, EventArgs e)
        {
            using var form = new WildcardCreatorForm(_wildcardRuleService, _appSettings);
            if (form.ShowDialog(this.FindForm()) == DialogResult.OK)
            {
                var newRule = form.NewRule;
                _backgroundTaskService.EnqueueTask(new FirewallTask(FirewallTaskType.AddWildcardRule, newRule));
                LoadRules();
            }
        }

        private void editRuleButton_Click(object sender, EventArgs e)
        {
            if (wildcardDataGridView.SelectedRows.Count != 1 || wildcardDataGridView.SelectedRows[0].DataBoundItem is not WildcardRule selectedRule)
            {
                MessageBox.Show("Please select a single rule to edit.", "Edit Rule", MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            using var form = new WildcardCreatorForm(_wildcardRuleService, _appSettings, selectedRule);
            if (form.ShowDialog(this.FindForm()) == DialogResult.OK)
            {
                var updatedRule = form.NewRule;
                var payload = new UpdateWildcardRulePayload { OldRule = selectedRule, NewRule = updatedRule };
                _backgroundTaskService.EnqueueTask(new FirewallTask(FirewallTaskType.UpdateWildcardRule, payload));
                LoadRules();
            }
        }

        private void deleteRuleButton_Click(object sender, EventArgs e)
        {
            if (wildcardDataGridView.SelectedRows.Count == 0 || _backgroundTaskService == null || _bindingSource.DataSource == null)
            {
                return;
            }

            var result = MessageBox.Show($"Are you sure you want to delete {wildcardDataGridView.SelectedRows.Count} rule definition(s)? This will also remove any firewall rules created by them.", "Confirm Deletion", MessageBoxButtons.YesNo, MessageBoxIcon.Warning);
            if (result == DialogResult.Yes)
            {
                var rulesToRemoveFromBindingSource = new List<WildcardRule>();
                foreach (DataGridViewRow row in wildcardDataGridView.SelectedRows)
                {
                    if (row.DataBoundItem is WildcardRule ruleToDelete)
                    {
                        rulesToRemoveFromBindingSource.Add(ruleToDelete);
                        var payload = new DeleteWildcardRulePayload { Wildcard = ruleToDelete };
                        _backgroundTaskService.EnqueueTask(new FirewallTask(FirewallTaskType.RemoveWildcardRule, payload));
                    }
                }

                if (_bindingSource.List is IList<WildcardRule> list) 
                {
                    foreach (var rule in rulesToRemoveFromBindingSource)
                    {
                        int indexToRemove = -1;
                        for (int i = 0; i < list.Count; i++)
                        {
                            if (list[i].FolderPath.Equals(rule.FolderPath, StringComparison.OrdinalIgnoreCase) &&
                                list[i].ExeName.Equals(rule.ExeName, StringComparison.OrdinalIgnoreCase))
                            {
                                indexToRemove = i;
                                break;
                            }
                        }
                        if (indexToRemove != -1)
                        {
                            _bindingSource.RemoveAt(indexToRemove);
                        }
                    }
                }
                else 
                {
                    LoadRules();
                }

                _bindingSource.ResetBindings(false); 
                wildcardDataGridView.Refresh(); 
            }
        }

        private void deleteDefinitionOnlyToolStripMenuItem_Click(object sender, EventArgs e)
        {
            if (wildcardDataGridView.SelectedRows.Count == 0)
            {
                return;
            }

            var result = MessageBox.Show($"Are you sure you want to delete the selected {wildcardDataGridView.SelectedRows.Count} wildcard definition(s)? Any existing rules already generated by them will NOT be deleted.", "Confirm Action", MessageBoxButtons.YesNo, MessageBoxIcon.Warning);
            if (result == DialogResult.Yes)
            {
                foreach (DataGridViewRow row in wildcardDataGridView.SelectedRows)
                {
                    if (row.DataBoundItem is WildcardRule ruleToDelete)
                    {
                        var payload = new DeleteWildcardRulePayload { Wildcard = ruleToDelete };
                        _backgroundTaskService.EnqueueTask(new FirewallTask(FirewallTaskType.RemoveWildcardDefinitionOnly, payload));
                    }
                }
                LoadRules();
            }
        }

        private void deleteAllGeneratedRulesToolStripMenuItem_Click(object sender, EventArgs e)
        {
            if (wildcardDataGridView.SelectedRows.Count == 0)
            {
                return;
            }

            var result = MessageBox.Show($"Are you sure you want to delete all individual firewall rules generated by the selected {wildcardDataGridView.SelectedRows.Count} wildcard definition(s)? The definitions themselves will not be deleted.", "Confirm Action", MessageBoxButtons.YesNo, MessageBoxIcon.Warning);
            if (result == DialogResult.Yes)
            {
                foreach (DataGridViewRow row in wildcardDataGridView.SelectedRows)
                {
                    if (row.DataBoundItem is WildcardRule rule)
                    {
                        var payload = new DeleteWildcardRulePayload { Wildcard = rule };
                        _backgroundTaskService.EnqueueTask(new FirewallTask(FirewallTaskType.DeleteWildcardRules, payload));
                    }
                }
                MessageBox.Show("The generated rules for the selected definitions have been queued for deletion.", "Task Queued", MessageBoxButtons.OK, MessageBoxIcon.Information);
            }
        }

        private void wildcardDataGridView_CellFormatting(object sender, DataGridViewCellFormattingEventArgs e)
        {
            if (e.RowIndex < 0 || e.RowIndex >= _bindingSource.Count) return;

            if (_bindingSource.List[e.RowIndex] is WildcardRule rule)
            {
                var column = wildcardDataGridView.Columns[e.ColumnIndex];
                if (column.DataPropertyName == "Protocol")
                {
                    e.Value = rule.Protocol switch
                    {
                        6 => "TCP",
                        17 => "UDP",
                        _ => "Any",
                    };
                    e.FormattingApplied = true;
                }
            }
        }
    }
}

--------------------------------------------------
// Full Path: C:/Users/anon/PROGRAMMING/C#/SimpleFirewall/VS Minimal Firewall/MinimalFirewall-NET8/Backups/v2.5.5 - ws/2.5.5.6 - security vulnerability fix 3/WildcardRulesControl.Designer.cs
--------------------------------------------------------------------------------
// File: WildcardRulesControl.Designer.cs
namespace MinimalFirewall
{
    partial class WildcardRulesControl
    {
        private System.ComponentModel.IContainer components = null;

        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Component Designer generated code

        private void InitializeComponent()
        {
            this.components = new System.ComponentModel.Container();
            this.topPanel = new System.Windows.Forms.Panel();
            this.deleteRuleButton = new System.Windows.Forms.Button();
            this.editRuleButton = new System.Windows.Forms.Button();
            this.addRuleButton = new System.Windows.Forms.Button();
            this.wildcardDataGridView = new System.Windows.Forms.DataGridView();
            this.colFolderPath = new System.Windows.Forms.DataGridViewTextBoxColumn();
            this.colExeName = new System.Windows.Forms.DataGridViewTextBoxColumn();
            this.colAction = new System.Windows.Forms.DataGridViewTextBoxColumn();
            this.colProtocol = new System.Windows.Forms.DataGridViewTextBoxColumn();
            this.colLocalPorts = new System.Windows.Forms.DataGridViewTextBoxColumn();
            this.colRemotePorts = new System.Windows.Forms.DataGridViewTextBoxColumn();
            this.colRemoteAddresses = new System.Windows.Forms.DataGridViewTextBoxColumn();
            this.wildcardContextMenu = new System.Windows.Forms.ContextMenuStrip(this.components);
            this.editToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.toolStripSeparator1 = new System.Windows.Forms.ToolStripSeparator();
            this.deleteDefinitionAndRulesToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.deleteDefinitionOnlyToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.deleteGeneratedRulesOnlyToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.topPanel.SuspendLayout();
            ((System.ComponentModel.ISupportInitialize)(this.wildcardDataGridView)).BeginInit();
            this.wildcardContextMenu.SuspendLayout();
            this.SuspendLayout();
            // 
            // topPanel
            // 
            this.topPanel.Controls.Add(this.deleteRuleButton);
            this.topPanel.Controls.Add(this.editRuleButton);
            this.topPanel.Controls.Add(this.addRuleButton);
            this.topPanel.Dock = System.Windows.Forms.DockStyle.Top;
            this.topPanel.Location = new System.Drawing.Point(0, 0);
            this.topPanel.Name = "topPanel";
            this.topPanel.Size = new System.Drawing.Size(800, 50);
            this.topPanel.TabIndex = 0;
            // 
            // deleteRuleButton
            // 
            this.deleteRuleButton.Location = new System.Drawing.Point(225, 10);
            this.deleteRuleButton.Name = "deleteRuleButton";
            this.deleteRuleButton.Size = new System.Drawing.Size(100, 30);
            this.deleteRuleButton.TabIndex = 2;
            this.deleteRuleButton.Text = "Delete Rule(s)";
            this.deleteRuleButton.UseVisualStyleBackColor = true;
            this.deleteRuleButton.Click += new System.EventHandler(this.deleteRuleButton_Click);
            // 
            // editRuleButton
            // 
            this.editRuleButton.Location = new System.Drawing.Point(119, 10);
            this.editRuleButton.Name = "editRuleButton";
            this.editRuleButton.Size = new System.Drawing.Size(100, 30);
            this.editRuleButton.TabIndex = 1;
            this.editRuleButton.Text = "Edit Rule...";
            this.editRuleButton.UseVisualStyleBackColor = true;
            this.editRuleButton.Click += new System.EventHandler(this.editRuleButton_Click);
            // 
            // addRuleButton
            // 
            this.addRuleButton.Location = new System.Drawing.Point(13, 10);
            this.addRuleButton.Name = "addRuleButton";
            this.addRuleButton.Size = new System.Drawing.Size(100, 30);
            this.addRuleButton.TabIndex = 0;
            this.addRuleButton.Text = "Add Rule...";
            this.addRuleButton.UseVisualStyleBackColor = true;
            this.addRuleButton.Click += new System.EventHandler(this.addRuleButton_Click);
            // 
            // wildcardDataGridView
            // 
            this.wildcardDataGridView.AllowUserToAddRows = false;
            this.wildcardDataGridView.AllowUserToDeleteRows = false;
            this.wildcardDataGridView.AllowUserToResizeRows = false;
            this.wildcardDataGridView.AutoSizeColumnsMode = System.Windows.Forms.DataGridViewAutoSizeColumnsMode.Fill;
            this.wildcardDataGridView.BorderStyle = System.Windows.Forms.BorderStyle.None;
            this.wildcardDataGridView.ColumnHeadersHeightSizeMode = System.Windows.Forms.DataGridViewColumnHeadersHeightSizeMode.AutoSize;
            this.wildcardDataGridView.Columns.AddRange(new System.Windows.Forms.DataGridViewColumn[] {
            this.colFolderPath,
            this.colExeName,
            this.colAction,
            this.colProtocol,
            this.colLocalPorts,
            this.colRemotePorts,
            this.colRemoteAddresses});
            this.wildcardDataGridView.ContextMenuStrip = this.wildcardContextMenu;
            this.wildcardDataGridView.Dock = System.Windows.Forms.DockStyle.Fill;
            this.wildcardDataGridView.Location = new System.Drawing.Point(0, 50);
            this.wildcardDataGridView.Name = "wildcardDataGridView";
            this.wildcardDataGridView.ReadOnly = true;
            this.wildcardDataGridView.RowHeadersVisible = false;
            this.wildcardDataGridView.RowTemplate.Height = 25;
            this.wildcardDataGridView.SelectionMode = System.Windows.Forms.DataGridViewSelectionMode.FullRowSelect;
            this.wildcardDataGridView.Size = new System.Drawing.Size(800, 550);
            this.wildcardDataGridView.TabIndex = 1;
            // 
            // colFolderPath
            // 
            this.colFolderPath.DataPropertyName = "FolderPath";
            this.colFolderPath.FillWeight = 30F;
            this.colFolderPath.HeaderText = "Folder Path";
            this.colFolderPath.Name = "colFolderPath";
            this.colFolderPath.ReadOnly = true;
            // 
            // colExeName
            // 
            this.colExeName.DataPropertyName = "ExeName";
            this.colExeName.FillWeight = 15F;
            this.colExeName.HeaderText = "Executable Name";
            this.colExeName.Name = "colExeName";
            this.colExeName.ReadOnly = true;
            // 
            // colAction
            // 
            this.colAction.DataPropertyName = "Action";
            this.colAction.FillWeight = 10F;
            this.colAction.HeaderText = "Action";
            this.colAction.Name = "colAction";
            this.colAction.ReadOnly = true;
            // 
            // colProtocol
            // 
            this.colProtocol.DataPropertyName = "Protocol";
            this.colProtocol.FillWeight = 8F;
            this.colProtocol.HeaderText = "Protocol";
            this.colProtocol.Name = "colProtocol";
            this.colProtocol.ReadOnly = true;
            // 
            // colLocalPorts
            // 
            this.colLocalPorts.DataPropertyName = "LocalPorts";
            this.colLocalPorts.FillWeight = 10F;
            this.colLocalPorts.HeaderText = "Local Ports";
            this.colLocalPorts.Name = "colLocalPorts";
            this.colLocalPorts.ReadOnly = true;
            // 
            // colRemotePorts
            // 
            this.colRemotePorts.DataPropertyName = "RemotePorts";
            this.colRemotePorts.FillWeight = 10F;
            this.colRemotePorts.HeaderText = "Remote Ports";
            this.colRemotePorts.Name = "colRemotePorts";
            this.colRemotePorts.ReadOnly = true;
            // 
            // colRemoteAddresses
            // 
            this.colRemoteAddresses.DataPropertyName = "RemoteAddresses";
            this.colRemoteAddresses.FillWeight = 17F;
            this.colRemoteAddresses.HeaderText = "Remote Addresses";
            this.colRemoteAddresses.Name = "colRemoteAddresses";
            this.colRemoteAddresses.ReadOnly = true;
            // 
            // wildcardContextMenu
            // 
            this.wildcardContextMenu.ImageScalingSize = new System.Drawing.Size(20, 20);
            this.wildcardContextMenu.Items.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.editToolStripMenuItem,
            this.toolStripSeparator1,
            this.deleteDefinitionAndRulesToolStripMenuItem,
            this.deleteDefinitionOnlyToolStripMenuItem,
            this.deleteGeneratedRulesOnlyToolStripMenuItem});
            this.wildcardContextMenu.Name = "wildcardContextMenu";
            this.wildcardContextMenu.Size = new System.Drawing.Size(286, 106);
            // 
            // editToolStripMenuItem
            // 
            this.editToolStripMenuItem.Name = "editToolStripMenuItem";
            this.editToolStripMenuItem.Size = new System.Drawing.Size(285, 24);
            this.editToolStripMenuItem.Text = "Edit...";
            this.editToolStripMenuItem.Click += new System.EventHandler(this.editRuleButton_Click);
            // 
            // toolStripSeparator1
            // 
            this.toolStripSeparator1.Name = "toolStripSeparator1";
            this.toolStripSeparator1.Size = new System.Drawing.Size(282, 6);
            // 
            // deleteDefinitionAndRulesToolStripMenuItem
            // 
            this.deleteDefinitionAndRulesToolStripMenuItem.Name = "deleteDefinitionAndRulesToolStripMenuItem";
            this.deleteDefinitionAndRulesToolStripMenuItem.Size = new System.Drawing.Size(285, 24);
            this.deleteDefinitionAndRulesToolStripMenuItem.Text = "Delete Definition && Rules";
            this.deleteDefinitionAndRulesToolStripMenuItem.Click += new System.EventHandler(this.deleteRuleButton_Click);
            // 
            // deleteDefinitionOnlyToolStripMenuItem
            // 
            this.deleteDefinitionOnlyToolStripMenuItem.Name = "deleteDefinitionOnlyToolStripMenuItem";
            this.deleteDefinitionOnlyToolStripMenuItem.Size = new System.Drawing.Size(285, 24);
            this.deleteDefinitionOnlyToolStripMenuItem.Text = "Delete Definition Only";
            this.deleteDefinitionOnlyToolStripMenuItem.Click += new System.EventHandler(this.deleteDefinitionOnlyToolStripMenuItem_Click);
            // 
            // deleteGeneratedRulesOnlyToolStripMenuItem
            // 
            this.deleteGeneratedRulesOnlyToolStripMenuItem.Name = "deleteGeneratedRulesOnlyToolStripMenuItem";
            this.deleteGeneratedRulesOnlyToolStripMenuItem.Size = new System.Drawing.Size(285, 24);
            this.deleteGeneratedRulesOnlyToolStripMenuItem.Text = "Delete Generated Rules Only";
            this.deleteGeneratedRulesOnlyToolStripMenuItem.Click += new System.EventHandler(this.deleteAllGeneratedRulesToolStripMenuItem_Click);
            // 
            // WildcardRulesControl
            // 
            this.AutoScaleDimensions = new System.Drawing.SizeF(8F, 20F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.Controls.Add(this.wildcardDataGridView);
            this.Controls.Add(this.topPanel);
            this.Name = "WildcardRulesControl";
            this.Size = new System.Drawing.Size(800, 600);
            this.topPanel.ResumeLayout(false);
            ((System.ComponentModel.ISupportInitialize)(this.wildcardDataGridView)).EndInit();
            this.wildcardContextMenu.ResumeLayout(false);
            this.ResumeLayout(false);

        }

        #endregion

        private Panel topPanel;
        private Button deleteRuleButton;
        private Button editRuleButton;
        private Button addRuleButton;
        private DataGridView wildcardDataGridView;
        private ContextMenuStrip wildcardContextMenu;
        private ToolStripMenuItem editToolStripMenuItem;
        private DataGridViewTextBoxColumn colFolderPath;
        private DataGridViewTextBoxColumn colExeName;
        private DataGridViewTextBoxColumn colAction;
        private DataGridViewTextBoxColumn colProtocol;
        private DataGridViewTextBoxColumn colLocalPorts;
        private DataGridViewTextBoxColumn colRemotePorts;
        private DataGridViewTextBoxColumn colRemoteAddresses;
        private ToolStripSeparator toolStripSeparator1;
        private ToolStripMenuItem deleteDefinitionAndRulesToolStripMenuItem;
        private ToolStripMenuItem deleteDefinitionOnlyToolStripMenuItem;
        private ToolStripMenuItem deleteGeneratedRulesOnlyToolStripMenuItem;
    }
}

--------------------------------------------------
// Full Path: C:/Users/anon/PROGRAMMING/C#/SimpleFirewall/VS Minimal Firewall/MinimalFirewall-NET8/Backups/v2.5.5 - ws/2.5.5.6 - security vulnerability fix 3/WildCardRuleService.cs
--------------------------------------------------------------------------------
// File: WildcardRuleService.cs
using System.Diagnostics;
using System.IO;
using System.Text.Json;

namespace MinimalFirewall
{
    public class WildcardRuleService
    {
        private readonly string _configPath;
        private List<WildcardRule> _rules = [];
        private readonly object _rulesLock = new object();

        public WildcardRuleService()
        {
            _configPath = ConfigPathManager.GetConfigPath("wildcard_rules.json");
            LoadRules();
        }

        public List<WildcardRule> GetRules()
        {
            lock (_rulesLock)
            {
                return new List<WildcardRule>(_rules);
            }
        }

        public void AddRule(WildcardRule rule)
        {
            lock (_rulesLock)
            {
                if (!_rules.Any(r => r.FolderPath.Equals(rule.FolderPath, StringComparison.OrdinalIgnoreCase) && r.ExeName.Equals(rule.ExeName, StringComparison.OrdinalIgnoreCase)))
                {
                    _rules.Add(rule);
                    SaveRules();
                }
            }
        }

        public void UpdateRule(WildcardRule oldRule, WildcardRule newRule)
        {
            RemoveRule(oldRule);
            AddRule(newRule);
        }

        public void RemoveRule(WildcardRule rule)
        {
            lock (_rulesLock)
            {
                var ruleToRemove = _rules.FirstOrDefault(r =>
                    r.FolderPath.Equals(rule.FolderPath, StringComparison.OrdinalIgnoreCase) &&
                    r.ExeName.Equals(rule.ExeName, StringComparison.OrdinalIgnoreCase) &&
                    r.Action.Equals(rule.Action, StringComparison.OrdinalIgnoreCase) &&
                    r.Protocol == rule.Protocol &&
                    r.LocalPorts.Equals(rule.LocalPorts, StringComparison.OrdinalIgnoreCase) &&
                    r.RemotePorts.Equals(rule.RemotePorts, StringComparison.OrdinalIgnoreCase) &&
                    r.RemoteAddresses.Equals(rule.RemoteAddresses, StringComparison.OrdinalIgnoreCase));

                if (ruleToRemove != null)
                {
                    _rules.Remove(ruleToRemove);
                    SaveRules();
                }
            }
        }

        public void ClearRules()
        {
            lock (_rulesLock)
            {
                _rules.Clear();
                SaveRules();
            }
        }

        private void LoadRules()
        {
            try
            {
                if (File.Exists(_configPath))
                {
                    string json = File.ReadAllText(_configPath);
                    var loadedRules = JsonSerializer.Deserialize(json, WildcardRuleJsonContext.Default.ListWildcardRule);
                    lock (_rulesLock)
                    {
                        _rules = loadedRules ?? [];
                    }
                }
                else
                {
                    lock (_rulesLock)
                    {
                        _rules = [];
                    }
                }
            }
            catch (Exception ex) when (ex is IOException or UnauthorizedAccessException or JsonException)
            {
                Debug.WriteLine("[ERROR] Failed to load wildcard rules: " + ex.Message);
                lock (_rulesLock)
                {
                    _rules = [];
                }
            }
        }

        private void SaveRules()
        {
            try
            {
                string json = JsonSerializer.Serialize(_rules, WildcardRuleJsonContext.Default.ListWildcardRule);
                File.WriteAllText(_configPath, json);
            }
            catch (Exception ex) when (ex is IOException or UnauthorizedAccessException)
            {
                Debug.WriteLine("[ERROR] Failed to save wildcard rules: " + ex.Message);
            }
        }

        public WildcardRule? Match(string path)
        {
            if (string.IsNullOrEmpty(path))
            {
                return null;
            }

            string normalizedPath = PathResolver.NormalizePath(path);
            string fileName = Path.GetFileName(normalizedPath);

            List<WildcardRule> rulesSnapshot;
            lock (_rulesLock)
            {
                rulesSnapshot = new List<WildcardRule>(_rules);
            }

            foreach (var rule in rulesSnapshot)
            {
                string expandedFolderPath = PathResolver.NormalizePath(rule.FolderPath);

                if (normalizedPath.StartsWith(expandedFolderPath, StringComparison.OrdinalIgnoreCase))
                {
                    string exePattern = string.IsNullOrWhiteSpace(rule.ExeName) ? "*" : rule.ExeName.Trim();

                    if (exePattern == "*" || exePattern == "*.exe")
                    {
                        return rule;
                    }

                    if (exePattern.StartsWith("*") && exePattern.EndsWith("*"))
                    {
                        if (fileName.Contains(exePattern.Trim('*'), StringComparison.OrdinalIgnoreCase)) return rule;
                    }
                    else if (exePattern.StartsWith("*"))
                    {
                        if (fileName.EndsWith(exePattern.TrimStart('*'), StringComparison.OrdinalIgnoreCase)) return rule;
                    }
                    else if (exePattern.EndsWith("*"))
                    {
                        if (fileName.StartsWith(exePattern.TrimEnd('*'), StringComparison.OrdinalIgnoreCase)) return rule;
                    }
                    else
                    {
                        if (fileName.Equals(exePattern, StringComparison.OrdinalIgnoreCase)) return rule;
                    }
                }
            }
            return null;
        }
    }
}

